// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Model
{
    /// <summary>
    /// Cheermote
    /// </summary>
    public partial class Cheermote : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Cheermote" /> class.
        /// </summary>
        /// <param name="prefix">The name portion of the Cheermote string that you use in chat to cheer Bits. The full Cheermote string is the concatenation of {prefix} + {number of Bits}. For example, if the prefix is “Cheer” and you want to cheer 100 Bits, the full Cheermote string is Cheer100\\. When the Cheermote string is entered in chat, Twitch converts it to the image associated with the Bits tier that was cheered.</param>
        /// <param name="tiers">A list of tier levels that the Cheermote supports. Each tier identifies the range of Bits that you can cheer at that tier level and an image that graphically identifies the tier level.</param>
        /// <param name="type">The type of Cheermote. Possible values are:      * global\\_first\\_party — A Twitch-defined Cheermote that is shown in the Bits card. * global\\_third\\_party — A Twitch-defined Cheermote that is not shown in the Bits card. * channel\\_custom — A broadcaster-defined Cheermote. * display\\_only — Do not use; for internal use only. * sponsored — A sponsor-defined Cheermote. When used, the sponsor adds additional Bits to the amount that the user cheered. For example, if the user cheered Terminator100, the broadcaster might receive 110 Bits, which includes the sponsor&#39;s 10 Bits contribution.</param>
        /// <param name="order">The order that the Cheermotes are shown in the Bits card. The numbers may not be consecutive. For example, the numbers may jump from 1 to 7 to 13\\. The order numbers are unique within a Cheermote type (for example, global\\_first\\_party) but may not be unique amongst all Cheermotes in the response.</param>
        /// <param name="lastUpdated">The date and time, in RFC3339 format, when this Cheermote was last updated.</param>
        /// <param name="isCharitable">A Boolean value that indicates whether this Cheermote provides a charitable contribution match during charity campaigns.</param>
        [JsonConstructor]
        public Cheermote(string prefix, List<CheermoteTiersInner> tiers, TypeEnum type, int order, DateTime lastUpdated, bool isCharitable)
        {
            Prefix = prefix;
            Tiers = tiers;
            Type = type;
            Order = order;
            LastUpdated = lastUpdated;
            IsCharitable = isCharitable;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// The type of Cheermote. Possible values are:      * global\\_first\\_party — A Twitch-defined Cheermote that is shown in the Bits card. * global\\_third\\_party — A Twitch-defined Cheermote that is not shown in the Bits card. * channel\\_custom — A broadcaster-defined Cheermote. * display\\_only — Do not use; for internal use only. * sponsored — A sponsor-defined Cheermote. When used, the sponsor adds additional Bits to the amount that the user cheered. For example, if the user cheered Terminator100, the broadcaster might receive 110 Bits, which includes the sponsor&#39;s 10 Bits contribution.
        /// </summary>
        /// <value>The type of Cheermote. Possible values are:      * global\\_first\\_party — A Twitch-defined Cheermote that is shown in the Bits card. * global\\_third\\_party — A Twitch-defined Cheermote that is not shown in the Bits card. * channel\\_custom — A broadcaster-defined Cheermote. * display\\_only — Do not use; for internal use only. * sponsored — A sponsor-defined Cheermote. When used, the sponsor adds additional Bits to the amount that the user cheered. For example, if the user cheered Terminator100, the broadcaster might receive 110 Bits, which includes the sponsor&#39;s 10 Bits contribution.</value>
        public enum TypeEnum
        {
            /// <summary>
            /// Enum GlobalFirstParty for value: global_first_party
            /// </summary>
            GlobalFirstParty = 1,

            /// <summary>
            /// Enum GlobalThirdParty for value: global_third_party
            /// </summary>
            GlobalThirdParty = 2,

            /// <summary>
            /// Enum ChannelCustom for value: channel_custom
            /// </summary>
            ChannelCustom = 3,

            /// <summary>
            /// Enum DisplayOnly for value: display_only
            /// </summary>
            DisplayOnly = 4,

            /// <summary>
            /// Enum Sponsored for value: sponsored
            /// </summary>
            Sponsored = 5
        }

        /// <summary>
        /// Returns a <see cref="TypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static TypeEnum TypeEnumFromString(string value)
        {
            if (value.Equals("global_first_party"))
                return TypeEnum.GlobalFirstParty;

            if (value.Equals("global_third_party"))
                return TypeEnum.GlobalThirdParty;

            if (value.Equals("channel_custom"))
                return TypeEnum.ChannelCustom;

            if (value.Equals("display_only"))
                return TypeEnum.DisplayOnly;

            if (value.Equals("sponsored"))
                return TypeEnum.Sponsored;

            throw new NotImplementedException($"Could not convert value to type TypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="TypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static TypeEnum? TypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("global_first_party"))
                return TypeEnum.GlobalFirstParty;

            if (value.Equals("global_third_party"))
                return TypeEnum.GlobalThirdParty;

            if (value.Equals("channel_custom"))
                return TypeEnum.ChannelCustom;

            if (value.Equals("display_only"))
                return TypeEnum.DisplayOnly;

            if (value.Equals("sponsored"))
                return TypeEnum.Sponsored;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="TypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string TypeEnumToJsonValue(TypeEnum value)
        {
            if (value == TypeEnum.GlobalFirstParty)
                return "global_first_party";

            if (value == TypeEnum.GlobalThirdParty)
                return "global_third_party";

            if (value == TypeEnum.ChannelCustom)
                return "channel_custom";

            if (value == TypeEnum.DisplayOnly)
                return "display_only";

            if (value == TypeEnum.Sponsored)
                return "sponsored";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// The type of Cheermote. Possible values are:      * global\\_first\\_party — A Twitch-defined Cheermote that is shown in the Bits card. * global\\_third\\_party — A Twitch-defined Cheermote that is not shown in the Bits card. * channel\\_custom — A broadcaster-defined Cheermote. * display\\_only — Do not use; for internal use only. * sponsored — A sponsor-defined Cheermote. When used, the sponsor adds additional Bits to the amount that the user cheered. For example, if the user cheered Terminator100, the broadcaster might receive 110 Bits, which includes the sponsor&#39;s 10 Bits contribution.
        /// </summary>
        /// <value>The type of Cheermote. Possible values are:      * global\\_first\\_party — A Twitch-defined Cheermote that is shown in the Bits card. * global\\_third\\_party — A Twitch-defined Cheermote that is not shown in the Bits card. * channel\\_custom — A broadcaster-defined Cheermote. * display\\_only — Do not use; for internal use only. * sponsored — A sponsor-defined Cheermote. When used, the sponsor adds additional Bits to the amount that the user cheered. For example, if the user cheered Terminator100, the broadcaster might receive 110 Bits, which includes the sponsor&#39;s 10 Bits contribution.</value>
        [JsonPropertyName("type")]
        public TypeEnum Type { get; set; }

        /// <summary>
        /// The name portion of the Cheermote string that you use in chat to cheer Bits. The full Cheermote string is the concatenation of {prefix} + {number of Bits}. For example, if the prefix is “Cheer” and you want to cheer 100 Bits, the full Cheermote string is Cheer100\\. When the Cheermote string is entered in chat, Twitch converts it to the image associated with the Bits tier that was cheered.
        /// </summary>
        /// <value>The name portion of the Cheermote string that you use in chat to cheer Bits. The full Cheermote string is the concatenation of {prefix} + {number of Bits}. For example, if the prefix is “Cheer” and you want to cheer 100 Bits, the full Cheermote string is Cheer100\\. When the Cheermote string is entered in chat, Twitch converts it to the image associated with the Bits tier that was cheered.</value>
        [JsonPropertyName("prefix")]
        public string Prefix { get; set; }

        /// <summary>
        /// A list of tier levels that the Cheermote supports. Each tier identifies the range of Bits that you can cheer at that tier level and an image that graphically identifies the tier level.
        /// </summary>
        /// <value>A list of tier levels that the Cheermote supports. Each tier identifies the range of Bits that you can cheer at that tier level and an image that graphically identifies the tier level.</value>
        [JsonPropertyName("tiers")]
        public List<CheermoteTiersInner> Tiers { get; set; }

        /// <summary>
        /// The order that the Cheermotes are shown in the Bits card. The numbers may not be consecutive. For example, the numbers may jump from 1 to 7 to 13\\. The order numbers are unique within a Cheermote type (for example, global\\_first\\_party) but may not be unique amongst all Cheermotes in the response.
        /// </summary>
        /// <value>The order that the Cheermotes are shown in the Bits card. The numbers may not be consecutive. For example, the numbers may jump from 1 to 7 to 13\\. The order numbers are unique within a Cheermote type (for example, global\\_first\\_party) but may not be unique amongst all Cheermotes in the response.</value>
        [JsonPropertyName("order")]
        public int Order { get; set; }

        /// <summary>
        /// The date and time, in RFC3339 format, when this Cheermote was last updated.
        /// </summary>
        /// <value>The date and time, in RFC3339 format, when this Cheermote was last updated.</value>
        [JsonPropertyName("last_updated")]
        public DateTime LastUpdated { get; set; }

        /// <summary>
        /// A Boolean value that indicates whether this Cheermote provides a charitable contribution match during charity campaigns.
        /// </summary>
        /// <value>A Boolean value that indicates whether this Cheermote provides a charitable contribution match during charity campaigns.</value>
        [JsonPropertyName("is_charitable")]
        public bool IsCharitable { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Cheermote {\n");
            sb.Append("  Prefix: ").Append(Prefix).Append("\n");
            sb.Append("  Tiers: ").Append(Tiers).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Order: ").Append(Order).Append("\n");
            sb.Append("  LastUpdated: ").Append(LastUpdated).Append("\n");
            sb.Append("  IsCharitable: ").Append(IsCharitable).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="Cheermote" />
    /// </summary>
    public class CheermoteJsonConverter : JsonConverter<Cheermote>
    {
        /// <summary>
        /// The format to use to serialize LastUpdated
        /// </summary>
        public static string LastUpdatedFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="Cheermote" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override Cheermote Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> prefix = default;
            Option<List<CheermoteTiersInner>?> tiers = default;
            Option<Cheermote.TypeEnum?> type = default;
            Option<int?> order = default;
            Option<DateTime?> lastUpdated = default;
            Option<bool?> isCharitable = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "prefix":
                            prefix = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "tiers":
                            tiers = new Option<List<CheermoteTiersInner>?>(JsonSerializer.Deserialize<List<CheermoteTiersInner>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "type":
                            string? typeRawValue = utf8JsonReader.GetString();
                            if (typeRawValue != null)
                                type = new Option<Cheermote.TypeEnum?>(Cheermote.TypeEnumFromStringOrDefault(typeRawValue));
                            break;
                        case "order":
                            order = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "last_updated":
                            lastUpdated = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "is_charitable":
                            isCharitable = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!prefix.IsSet)
                throw new ArgumentException("Property is required for class Cheermote.", nameof(prefix));

            if (!tiers.IsSet)
                throw new ArgumentException("Property is required for class Cheermote.", nameof(tiers));

            if (!type.IsSet)
                throw new ArgumentException("Property is required for class Cheermote.", nameof(type));

            if (!order.IsSet)
                throw new ArgumentException("Property is required for class Cheermote.", nameof(order));

            if (!lastUpdated.IsSet)
                throw new ArgumentException("Property is required for class Cheermote.", nameof(lastUpdated));

            if (!isCharitable.IsSet)
                throw new ArgumentException("Property is required for class Cheermote.", nameof(isCharitable));

            if (prefix.IsSet && prefix.Value == null)
                throw new ArgumentNullException(nameof(prefix), "Property is not nullable for class Cheermote.");

            if (tiers.IsSet && tiers.Value == null)
                throw new ArgumentNullException(nameof(tiers), "Property is not nullable for class Cheermote.");

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type), "Property is not nullable for class Cheermote.");

            if (order.IsSet && order.Value == null)
                throw new ArgumentNullException(nameof(order), "Property is not nullable for class Cheermote.");

            if (lastUpdated.IsSet && lastUpdated.Value == null)
                throw new ArgumentNullException(nameof(lastUpdated), "Property is not nullable for class Cheermote.");

            if (isCharitable.IsSet && isCharitable.Value == null)
                throw new ArgumentNullException(nameof(isCharitable), "Property is not nullable for class Cheermote.");

            return new Cheermote(prefix.Value!, tiers.Value!, type.Value!.Value!, order.Value!.Value!, lastUpdated.Value!.Value!, isCharitable.Value!.Value!);
        }

        /// <summary>
        /// Serializes a <see cref="Cheermote" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="cheermote"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, Cheermote cheermote, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, cheermote, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="Cheermote" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="cheermote"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, Cheermote cheermote, JsonSerializerOptions jsonSerializerOptions)
        {
            if (cheermote.Prefix == null)
                throw new ArgumentNullException(nameof(cheermote.Prefix), "Property is required for class Cheermote.");

            if (cheermote.Tiers == null)
                throw new ArgumentNullException(nameof(cheermote.Tiers), "Property is required for class Cheermote.");

            writer.WriteString("prefix", cheermote.Prefix);

            writer.WritePropertyName("tiers");
            JsonSerializer.Serialize(writer, cheermote.Tiers, jsonSerializerOptions);
            var typeRawValue = Cheermote.TypeEnumToJsonValue(cheermote.Type);
            writer.WriteString("type", typeRawValue);
            writer.WriteNumber("order", cheermote.Order);

            writer.WriteString("last_updated", cheermote.LastUpdated.ToString(LastUpdatedFormat));

            writer.WriteBoolean("is_charitable", cheermote.IsCharitable);
        }
    }
}
