// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Model
{
    /// <summary>
    /// UpdateChannelStreamScheduleSegmentBody
    /// </summary>
    public partial class UpdateChannelStreamScheduleSegmentBody : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="UpdateChannelStreamScheduleSegmentBody" /> class.
        /// </summary>
        /// <param name="startTime">The date and time that the broadcast segment starts. Specify the date and time in RFC3339 format (for example, 2022-08-02T06:00:00Z).      **NOTE**: Only partners and affiliates may update a broadcast’s start time and only for non-recurring segments.</param>
        /// <param name="duration">The length of time, in minutes, that the broadcast is scheduled to run. The duration must be in the range 30 through 1380 (23 hours).</param>
        /// <param name="categoryId">The ID of the category that best represents the broadcast’s content. To get the category ID, use the [Search Categories](https://dev.twitch.tv/docs/api/reference#search-categories) endpoint.</param>
        /// <param name="title">The broadcast’s title. The title may contain a maximum of 140 characters.</param>
        /// <param name="isCanceled">A Boolean value that indicates whether the broadcast is canceled. Set to **true** to cancel the segment.      **NOTE**: For recurring segments, the API cancels the first segment after the current UTC date and time and not the specified segment (unless the specified segment is the next segment after the current UTC date and time).</param>
        /// <param name="timezone">The time zone where the broadcast takes place. Specify the time zone using [IANA time zone database](https://www.iana.org/time-zones) format (for example, America/New\\_York).</param>
        [JsonConstructor]
        public UpdateChannelStreamScheduleSegmentBody(Option<DateTime?> startTime = default, Option<string?> duration = default, Option<string?> categoryId = default, Option<string?> title = default, Option<bool?> isCanceled = default, Option<string?> timezone = default)
        {
            StartTimeOption = startTime;
            DurationOption = duration;
            CategoryIdOption = categoryId;
            TitleOption = title;
            IsCanceledOption = isCanceled;
            TimezoneOption = timezone;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Used to track the state of StartTime
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> StartTimeOption { get; private set; }

        /// <summary>
        /// The date and time that the broadcast segment starts. Specify the date and time in RFC3339 format (for example, 2022-08-02T06:00:00Z).      **NOTE**: Only partners and affiliates may update a broadcast’s start time and only for non-recurring segments.
        /// </summary>
        /// <value>The date and time that the broadcast segment starts. Specify the date and time in RFC3339 format (for example, 2022-08-02T06:00:00Z).      **NOTE**: Only partners and affiliates may update a broadcast’s start time and only for non-recurring segments.</value>
        [JsonPropertyName("start_time")]
        public DateTime? StartTime { get { return this.StartTimeOption; } set { this.StartTimeOption = new(value); } }

        /// <summary>
        /// Used to track the state of Duration
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> DurationOption { get; private set; }

        /// <summary>
        /// The length of time, in minutes, that the broadcast is scheduled to run. The duration must be in the range 30 through 1380 (23 hours).
        /// </summary>
        /// <value>The length of time, in minutes, that the broadcast is scheduled to run. The duration must be in the range 30 through 1380 (23 hours).</value>
        [JsonPropertyName("duration")]
        public string? Duration { get { return this.DurationOption; } set { this.DurationOption = new(value); } }

        /// <summary>
        /// Used to track the state of CategoryId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> CategoryIdOption { get; private set; }

        /// <summary>
        /// The ID of the category that best represents the broadcast’s content. To get the category ID, use the [Search Categories](https://dev.twitch.tv/docs/api/reference#search-categories) endpoint.
        /// </summary>
        /// <value>The ID of the category that best represents the broadcast’s content. To get the category ID, use the [Search Categories](https://dev.twitch.tv/docs/api/reference#search-categories) endpoint.</value>
        [JsonPropertyName("category_id")]
        public string? CategoryId { get { return this.CategoryIdOption; } set { this.CategoryIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of Title
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TitleOption { get; private set; }

        /// <summary>
        /// The broadcast’s title. The title may contain a maximum of 140 characters.
        /// </summary>
        /// <value>The broadcast’s title. The title may contain a maximum of 140 characters.</value>
        [JsonPropertyName("title")]
        public string? Title { get { return this.TitleOption; } set { this.TitleOption = new(value); } }

        /// <summary>
        /// Used to track the state of IsCanceled
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsCanceledOption { get; private set; }

        /// <summary>
        /// A Boolean value that indicates whether the broadcast is canceled. Set to **true** to cancel the segment.      **NOTE**: For recurring segments, the API cancels the first segment after the current UTC date and time and not the specified segment (unless the specified segment is the next segment after the current UTC date and time).
        /// </summary>
        /// <value>A Boolean value that indicates whether the broadcast is canceled. Set to **true** to cancel the segment.      **NOTE**: For recurring segments, the API cancels the first segment after the current UTC date and time and not the specified segment (unless the specified segment is the next segment after the current UTC date and time).</value>
        [JsonPropertyName("is_canceled")]
        public bool? IsCanceled { get { return this.IsCanceledOption; } set { this.IsCanceledOption = new(value); } }

        /// <summary>
        /// Used to track the state of Timezone
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TimezoneOption { get; private set; }

        /// <summary>
        /// The time zone where the broadcast takes place. Specify the time zone using [IANA time zone database](https://www.iana.org/time-zones) format (for example, America/New\\_York).
        /// </summary>
        /// <value>The time zone where the broadcast takes place. Specify the time zone using [IANA time zone database](https://www.iana.org/time-zones) format (for example, America/New\\_York).</value>
        [JsonPropertyName("timezone")]
        public string? Timezone { get { return this.TimezoneOption; } set { this.TimezoneOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class UpdateChannelStreamScheduleSegmentBody {\n");
            sb.Append("  StartTime: ").Append(StartTime).Append("\n");
            sb.Append("  Duration: ").Append(Duration).Append("\n");
            sb.Append("  CategoryId: ").Append(CategoryId).Append("\n");
            sb.Append("  Title: ").Append(Title).Append("\n");
            sb.Append("  IsCanceled: ").Append(IsCanceled).Append("\n");
            sb.Append("  Timezone: ").Append(Timezone).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="UpdateChannelStreamScheduleSegmentBody" />
    /// </summary>
    public class UpdateChannelStreamScheduleSegmentBodyJsonConverter : JsonConverter<UpdateChannelStreamScheduleSegmentBody>
    {
        /// <summary>
        /// The format to use to serialize StartTime
        /// </summary>
        public static string StartTimeFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="UpdateChannelStreamScheduleSegmentBody" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override UpdateChannelStreamScheduleSegmentBody Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<DateTime?> startTime = default;
            Option<string?> duration = default;
            Option<string?> categoryId = default;
            Option<string?> title = default;
            Option<bool?> isCanceled = default;
            Option<string?> timezone = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "start_time":
                            startTime = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "duration":
                            duration = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "category_id":
                            categoryId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "title":
                            title = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "is_canceled":
                            isCanceled = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "timezone":
                            timezone = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (startTime.IsSet && startTime.Value == null)
                throw new ArgumentNullException(nameof(startTime), "Property is not nullable for class UpdateChannelStreamScheduleSegmentBody.");

            if (duration.IsSet && duration.Value == null)
                throw new ArgumentNullException(nameof(duration), "Property is not nullable for class UpdateChannelStreamScheduleSegmentBody.");

            if (categoryId.IsSet && categoryId.Value == null)
                throw new ArgumentNullException(nameof(categoryId), "Property is not nullable for class UpdateChannelStreamScheduleSegmentBody.");

            if (title.IsSet && title.Value == null)
                throw new ArgumentNullException(nameof(title), "Property is not nullable for class UpdateChannelStreamScheduleSegmentBody.");

            if (isCanceled.IsSet && isCanceled.Value == null)
                throw new ArgumentNullException(nameof(isCanceled), "Property is not nullable for class UpdateChannelStreamScheduleSegmentBody.");

            if (timezone.IsSet && timezone.Value == null)
                throw new ArgumentNullException(nameof(timezone), "Property is not nullable for class UpdateChannelStreamScheduleSegmentBody.");

            return new UpdateChannelStreamScheduleSegmentBody(startTime, duration, categoryId, title, isCanceled, timezone);
        }

        /// <summary>
        /// Serializes a <see cref="UpdateChannelStreamScheduleSegmentBody" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="updateChannelStreamScheduleSegmentBody"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, UpdateChannelStreamScheduleSegmentBody updateChannelStreamScheduleSegmentBody, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, updateChannelStreamScheduleSegmentBody, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="UpdateChannelStreamScheduleSegmentBody" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="updateChannelStreamScheduleSegmentBody"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, UpdateChannelStreamScheduleSegmentBody updateChannelStreamScheduleSegmentBody, JsonSerializerOptions jsonSerializerOptions)
        {
            if (updateChannelStreamScheduleSegmentBody.DurationOption.IsSet && updateChannelStreamScheduleSegmentBody.Duration == null)
                throw new ArgumentNullException(nameof(updateChannelStreamScheduleSegmentBody.Duration), "Property is required for class UpdateChannelStreamScheduleSegmentBody.");

            if (updateChannelStreamScheduleSegmentBody.CategoryIdOption.IsSet && updateChannelStreamScheduleSegmentBody.CategoryId == null)
                throw new ArgumentNullException(nameof(updateChannelStreamScheduleSegmentBody.CategoryId), "Property is required for class UpdateChannelStreamScheduleSegmentBody.");

            if (updateChannelStreamScheduleSegmentBody.TitleOption.IsSet && updateChannelStreamScheduleSegmentBody.Title == null)
                throw new ArgumentNullException(nameof(updateChannelStreamScheduleSegmentBody.Title), "Property is required for class UpdateChannelStreamScheduleSegmentBody.");

            if (updateChannelStreamScheduleSegmentBody.TimezoneOption.IsSet && updateChannelStreamScheduleSegmentBody.Timezone == null)
                throw new ArgumentNullException(nameof(updateChannelStreamScheduleSegmentBody.Timezone), "Property is required for class UpdateChannelStreamScheduleSegmentBody.");

            if (updateChannelStreamScheduleSegmentBody.StartTimeOption.IsSet)
                writer.WriteString("start_time", updateChannelStreamScheduleSegmentBody.StartTimeOption.Value!.Value.ToString(StartTimeFormat));

            if (updateChannelStreamScheduleSegmentBody.DurationOption.IsSet)
                writer.WriteString("duration", updateChannelStreamScheduleSegmentBody.Duration);

            if (updateChannelStreamScheduleSegmentBody.CategoryIdOption.IsSet)
                writer.WriteString("category_id", updateChannelStreamScheduleSegmentBody.CategoryId);

            if (updateChannelStreamScheduleSegmentBody.TitleOption.IsSet)
                writer.WriteString("title", updateChannelStreamScheduleSegmentBody.Title);

            if (updateChannelStreamScheduleSegmentBody.IsCanceledOption.IsSet)
                writer.WriteBoolean("is_canceled", updateChannelStreamScheduleSegmentBody.IsCanceledOption.Value!.Value);

            if (updateChannelStreamScheduleSegmentBody.TimezoneOption.IsSet)
                writer.WriteString("timezone", updateChannelStreamScheduleSegmentBody.Timezone);
        }
    }
}
