// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Model
{
    /// <summary>
    /// UpdateCustomRewardBody
    /// </summary>
    public partial class UpdateCustomRewardBody : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="UpdateCustomRewardBody" /> class.
        /// </summary>
        /// <param name="title">The reward’s title. The title may contain a maximum of 45 characters and it must be unique amongst all of the broadcaster’s custom rewards.</param>
        /// <param name="prompt">The prompt shown to the viewer when they redeem the reward. Specify a prompt if &#x60;is_user_input_required&#x60; is **true**. The prompt is limited to a maximum of 200 characters.</param>
        /// <param name="cost">The cost of the reward, in channel points. The minimum is 1 point.</param>
        /// <param name="backgroundColor">The background color to use for the reward. Specify the color using Hex format (for example, \\\\#00E5CB).</param>
        /// <param name="isEnabled">A Boolean value that indicates whether the reward is enabled. Set to **true** to enable the reward. Viewers see only enabled rewards.</param>
        /// <param name="isUserInputRequired">A Boolean value that determines whether users must enter information to redeem the reward. Set to **true** if user input is required. See the &#x60;prompt&#x60; field.</param>
        /// <param name="isMaxPerStreamEnabled">A Boolean value that determines whether to limit the maximum number of redemptions allowed per live stream (see the &#x60;max_per_stream&#x60; field). Set to **true** to limit redemptions.</param>
        /// <param name="maxPerStream">The maximum number of redemptions allowed per live stream. Applied only if &#x60;is_max_per_stream_enabled&#x60; is **true**. The minimum value is 1.</param>
        /// <param name="isMaxPerUserPerStreamEnabled">A Boolean value that determines whether to limit the maximum number of redemptions allowed per user per stream (see &#x60;max_per_user_per_stream&#x60;). The minimum value is 1\\. Set to **true** to limit redemptions.</param>
        /// <param name="maxPerUserPerStream">The maximum number of redemptions allowed per user per stream. Applied only if &#x60;is_max_per_user_per_stream_enabled&#x60; is **true**.</param>
        /// <param name="isGlobalCooldownEnabled">A Boolean value that determines whether to apply a cooldown period between redemptions. Set to **true** to apply a cooldown period. For the duration of the cooldown period, see &#x60;global_cooldown_seconds&#x60;.</param>
        /// <param name="globalCooldownSeconds">The cooldown period, in seconds. Applied only if &#x60;is_global_cooldown_enabled&#x60; is **true**. The minimum value is 1; however, for it to be shown in the Twitch UX, the minimum value is 60.</param>
        /// <param name="isPaused">A Boolean value that determines whether to pause the reward. Set to **true** to pause the reward. Viewers can’t redeem paused rewards..</param>
        /// <param name="shouldRedemptionsSkipRequestQueue">A Boolean value that determines whether redemptions should be set to FULFILLED status immediately when a reward is redeemed. If **false**, status is set to UNFULFILLED and follows the normal request queue process.</param>
        [JsonConstructor]
        public UpdateCustomRewardBody(Option<string?> title = default, Option<string?> prompt = default, Option<long?> cost = default, Option<string?> backgroundColor = default, Option<bool?> isEnabled = default, Option<bool?> isUserInputRequired = default, Option<bool?> isMaxPerStreamEnabled = default, Option<long?> maxPerStream = default, Option<bool?> isMaxPerUserPerStreamEnabled = default, Option<long?> maxPerUserPerStream = default, Option<bool?> isGlobalCooldownEnabled = default, Option<long?> globalCooldownSeconds = default, Option<bool?> isPaused = default, Option<bool?> shouldRedemptionsSkipRequestQueue = default)
        {
            TitleOption = title;
            PromptOption = prompt;
            CostOption = cost;
            BackgroundColorOption = backgroundColor;
            IsEnabledOption = isEnabled;
            IsUserInputRequiredOption = isUserInputRequired;
            IsMaxPerStreamEnabledOption = isMaxPerStreamEnabled;
            MaxPerStreamOption = maxPerStream;
            IsMaxPerUserPerStreamEnabledOption = isMaxPerUserPerStreamEnabled;
            MaxPerUserPerStreamOption = maxPerUserPerStream;
            IsGlobalCooldownEnabledOption = isGlobalCooldownEnabled;
            GlobalCooldownSecondsOption = globalCooldownSeconds;
            IsPausedOption = isPaused;
            ShouldRedemptionsSkipRequestQueueOption = shouldRedemptionsSkipRequestQueue;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Used to track the state of Title
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TitleOption { get; private set; }

        /// <summary>
        /// The reward’s title. The title may contain a maximum of 45 characters and it must be unique amongst all of the broadcaster’s custom rewards.
        /// </summary>
        /// <value>The reward’s title. The title may contain a maximum of 45 characters and it must be unique amongst all of the broadcaster’s custom rewards.</value>
        [JsonPropertyName("title")]
        public string? Title { get { return this.TitleOption; } set { this.TitleOption = new(value); } }

        /// <summary>
        /// Used to track the state of Prompt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> PromptOption { get; private set; }

        /// <summary>
        /// The prompt shown to the viewer when they redeem the reward. Specify a prompt if &#x60;is_user_input_required&#x60; is **true**. The prompt is limited to a maximum of 200 characters.
        /// </summary>
        /// <value>The prompt shown to the viewer when they redeem the reward. Specify a prompt if &#x60;is_user_input_required&#x60; is **true**. The prompt is limited to a maximum of 200 characters.</value>
        [JsonPropertyName("prompt")]
        public string? Prompt { get { return this.PromptOption; } set { this.PromptOption = new(value); } }

        /// <summary>
        /// Used to track the state of Cost
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> CostOption { get; private set; }

        /// <summary>
        /// The cost of the reward, in channel points. The minimum is 1 point.
        /// </summary>
        /// <value>The cost of the reward, in channel points. The minimum is 1 point.</value>
        [JsonPropertyName("cost")]
        public long? Cost { get { return this.CostOption; } set { this.CostOption = new(value); } }

        /// <summary>
        /// Used to track the state of BackgroundColor
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> BackgroundColorOption { get; private set; }

        /// <summary>
        /// The background color to use for the reward. Specify the color using Hex format (for example, \\\\#00E5CB).
        /// </summary>
        /// <value>The background color to use for the reward. Specify the color using Hex format (for example, \\\\#00E5CB).</value>
        [JsonPropertyName("background_color")]
        public string? BackgroundColor { get { return this.BackgroundColorOption; } set { this.BackgroundColorOption = new(value); } }

        /// <summary>
        /// Used to track the state of IsEnabled
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsEnabledOption { get; private set; }

        /// <summary>
        /// A Boolean value that indicates whether the reward is enabled. Set to **true** to enable the reward. Viewers see only enabled rewards.
        /// </summary>
        /// <value>A Boolean value that indicates whether the reward is enabled. Set to **true** to enable the reward. Viewers see only enabled rewards.</value>
        [JsonPropertyName("is_enabled")]
        public bool? IsEnabled { get { return this.IsEnabledOption; } set { this.IsEnabledOption = new(value); } }

        /// <summary>
        /// Used to track the state of IsUserInputRequired
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsUserInputRequiredOption { get; private set; }

        /// <summary>
        /// A Boolean value that determines whether users must enter information to redeem the reward. Set to **true** if user input is required. See the &#x60;prompt&#x60; field.
        /// </summary>
        /// <value>A Boolean value that determines whether users must enter information to redeem the reward. Set to **true** if user input is required. See the &#x60;prompt&#x60; field.</value>
        [JsonPropertyName("is_user_input_required")]
        public bool? IsUserInputRequired { get { return this.IsUserInputRequiredOption; } set { this.IsUserInputRequiredOption = new(value); } }

        /// <summary>
        /// Used to track the state of IsMaxPerStreamEnabled
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsMaxPerStreamEnabledOption { get; private set; }

        /// <summary>
        /// A Boolean value that determines whether to limit the maximum number of redemptions allowed per live stream (see the &#x60;max_per_stream&#x60; field). Set to **true** to limit redemptions.
        /// </summary>
        /// <value>A Boolean value that determines whether to limit the maximum number of redemptions allowed per live stream (see the &#x60;max_per_stream&#x60; field). Set to **true** to limit redemptions.</value>
        [JsonPropertyName("is_max_per_stream_enabled")]
        public bool? IsMaxPerStreamEnabled { get { return this.IsMaxPerStreamEnabledOption; } set { this.IsMaxPerStreamEnabledOption = new(value); } }

        /// <summary>
        /// Used to track the state of MaxPerStream
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> MaxPerStreamOption { get; private set; }

        /// <summary>
        /// The maximum number of redemptions allowed per live stream. Applied only if &#x60;is_max_per_stream_enabled&#x60; is **true**. The minimum value is 1.
        /// </summary>
        /// <value>The maximum number of redemptions allowed per live stream. Applied only if &#x60;is_max_per_stream_enabled&#x60; is **true**. The minimum value is 1.</value>
        [JsonPropertyName("max_per_stream")]
        public long? MaxPerStream { get { return this.MaxPerStreamOption; } set { this.MaxPerStreamOption = new(value); } }

        /// <summary>
        /// Used to track the state of IsMaxPerUserPerStreamEnabled
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsMaxPerUserPerStreamEnabledOption { get; private set; }

        /// <summary>
        /// A Boolean value that determines whether to limit the maximum number of redemptions allowed per user per stream (see &#x60;max_per_user_per_stream&#x60;). The minimum value is 1\\. Set to **true** to limit redemptions.
        /// </summary>
        /// <value>A Boolean value that determines whether to limit the maximum number of redemptions allowed per user per stream (see &#x60;max_per_user_per_stream&#x60;). The minimum value is 1\\. Set to **true** to limit redemptions.</value>
        [JsonPropertyName("is_max_per_user_per_stream_enabled")]
        public bool? IsMaxPerUserPerStreamEnabled { get { return this.IsMaxPerUserPerStreamEnabledOption; } set { this.IsMaxPerUserPerStreamEnabledOption = new(value); } }

        /// <summary>
        /// Used to track the state of MaxPerUserPerStream
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> MaxPerUserPerStreamOption { get; private set; }

        /// <summary>
        /// The maximum number of redemptions allowed per user per stream. Applied only if &#x60;is_max_per_user_per_stream_enabled&#x60; is **true**.
        /// </summary>
        /// <value>The maximum number of redemptions allowed per user per stream. Applied only if &#x60;is_max_per_user_per_stream_enabled&#x60; is **true**.</value>
        [JsonPropertyName("max_per_user_per_stream")]
        public long? MaxPerUserPerStream { get { return this.MaxPerUserPerStreamOption; } set { this.MaxPerUserPerStreamOption = new(value); } }

        /// <summary>
        /// Used to track the state of IsGlobalCooldownEnabled
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsGlobalCooldownEnabledOption { get; private set; }

        /// <summary>
        /// A Boolean value that determines whether to apply a cooldown period between redemptions. Set to **true** to apply a cooldown period. For the duration of the cooldown period, see &#x60;global_cooldown_seconds&#x60;.
        /// </summary>
        /// <value>A Boolean value that determines whether to apply a cooldown period between redemptions. Set to **true** to apply a cooldown period. For the duration of the cooldown period, see &#x60;global_cooldown_seconds&#x60;.</value>
        [JsonPropertyName("is_global_cooldown_enabled")]
        public bool? IsGlobalCooldownEnabled { get { return this.IsGlobalCooldownEnabledOption; } set { this.IsGlobalCooldownEnabledOption = new(value); } }

        /// <summary>
        /// Used to track the state of GlobalCooldownSeconds
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> GlobalCooldownSecondsOption { get; private set; }

        /// <summary>
        /// The cooldown period, in seconds. Applied only if &#x60;is_global_cooldown_enabled&#x60; is **true**. The minimum value is 1; however, for it to be shown in the Twitch UX, the minimum value is 60.
        /// </summary>
        /// <value>The cooldown period, in seconds. Applied only if &#x60;is_global_cooldown_enabled&#x60; is **true**. The minimum value is 1; however, for it to be shown in the Twitch UX, the minimum value is 60.</value>
        [JsonPropertyName("global_cooldown_seconds")]
        public long? GlobalCooldownSeconds { get { return this.GlobalCooldownSecondsOption; } set { this.GlobalCooldownSecondsOption = new(value); } }

        /// <summary>
        /// Used to track the state of IsPaused
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsPausedOption { get; private set; }

        /// <summary>
        /// A Boolean value that determines whether to pause the reward. Set to **true** to pause the reward. Viewers can’t redeem paused rewards..
        /// </summary>
        /// <value>A Boolean value that determines whether to pause the reward. Set to **true** to pause the reward. Viewers can’t redeem paused rewards..</value>
        [JsonPropertyName("is_paused")]
        public bool? IsPaused { get { return this.IsPausedOption; } set { this.IsPausedOption = new(value); } }

        /// <summary>
        /// Used to track the state of ShouldRedemptionsSkipRequestQueue
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> ShouldRedemptionsSkipRequestQueueOption { get; private set; }

        /// <summary>
        /// A Boolean value that determines whether redemptions should be set to FULFILLED status immediately when a reward is redeemed. If **false**, status is set to UNFULFILLED and follows the normal request queue process.
        /// </summary>
        /// <value>A Boolean value that determines whether redemptions should be set to FULFILLED status immediately when a reward is redeemed. If **false**, status is set to UNFULFILLED and follows the normal request queue process.</value>
        [JsonPropertyName("should_redemptions_skip_request_queue")]
        public bool? ShouldRedemptionsSkipRequestQueue { get { return this.ShouldRedemptionsSkipRequestQueueOption; } set { this.ShouldRedemptionsSkipRequestQueueOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class UpdateCustomRewardBody {\n");
            sb.Append("  Title: ").Append(Title).Append("\n");
            sb.Append("  Prompt: ").Append(Prompt).Append("\n");
            sb.Append("  Cost: ").Append(Cost).Append("\n");
            sb.Append("  BackgroundColor: ").Append(BackgroundColor).Append("\n");
            sb.Append("  IsEnabled: ").Append(IsEnabled).Append("\n");
            sb.Append("  IsUserInputRequired: ").Append(IsUserInputRequired).Append("\n");
            sb.Append("  IsMaxPerStreamEnabled: ").Append(IsMaxPerStreamEnabled).Append("\n");
            sb.Append("  MaxPerStream: ").Append(MaxPerStream).Append("\n");
            sb.Append("  IsMaxPerUserPerStreamEnabled: ").Append(IsMaxPerUserPerStreamEnabled).Append("\n");
            sb.Append("  MaxPerUserPerStream: ").Append(MaxPerUserPerStream).Append("\n");
            sb.Append("  IsGlobalCooldownEnabled: ").Append(IsGlobalCooldownEnabled).Append("\n");
            sb.Append("  GlobalCooldownSeconds: ").Append(GlobalCooldownSeconds).Append("\n");
            sb.Append("  IsPaused: ").Append(IsPaused).Append("\n");
            sb.Append("  ShouldRedemptionsSkipRequestQueue: ").Append(ShouldRedemptionsSkipRequestQueue).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="UpdateCustomRewardBody" />
    /// </summary>
    public class UpdateCustomRewardBodyJsonConverter : JsonConverter<UpdateCustomRewardBody>
    {
        /// <summary>
        /// Deserializes json to <see cref="UpdateCustomRewardBody" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override UpdateCustomRewardBody Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> title = default;
            Option<string?> prompt = default;
            Option<long?> cost = default;
            Option<string?> backgroundColor = default;
            Option<bool?> isEnabled = default;
            Option<bool?> isUserInputRequired = default;
            Option<bool?> isMaxPerStreamEnabled = default;
            Option<long?> maxPerStream = default;
            Option<bool?> isMaxPerUserPerStreamEnabled = default;
            Option<long?> maxPerUserPerStream = default;
            Option<bool?> isGlobalCooldownEnabled = default;
            Option<long?> globalCooldownSeconds = default;
            Option<bool?> isPaused = default;
            Option<bool?> shouldRedemptionsSkipRequestQueue = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "title":
                            title = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "prompt":
                            prompt = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "cost":
                            cost = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "background_color":
                            backgroundColor = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "is_enabled":
                            isEnabled = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "is_user_input_required":
                            isUserInputRequired = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "is_max_per_stream_enabled":
                            isMaxPerStreamEnabled = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "max_per_stream":
                            maxPerStream = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "is_max_per_user_per_stream_enabled":
                            isMaxPerUserPerStreamEnabled = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "max_per_user_per_stream":
                            maxPerUserPerStream = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "is_global_cooldown_enabled":
                            isGlobalCooldownEnabled = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "global_cooldown_seconds":
                            globalCooldownSeconds = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "is_paused":
                            isPaused = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "should_redemptions_skip_request_queue":
                            shouldRedemptionsSkipRequestQueue = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (title.IsSet && title.Value == null)
                throw new ArgumentNullException(nameof(title), "Property is not nullable for class UpdateCustomRewardBody.");

            if (prompt.IsSet && prompt.Value == null)
                throw new ArgumentNullException(nameof(prompt), "Property is not nullable for class UpdateCustomRewardBody.");

            if (cost.IsSet && cost.Value == null)
                throw new ArgumentNullException(nameof(cost), "Property is not nullable for class UpdateCustomRewardBody.");

            if (backgroundColor.IsSet && backgroundColor.Value == null)
                throw new ArgumentNullException(nameof(backgroundColor), "Property is not nullable for class UpdateCustomRewardBody.");

            if (isEnabled.IsSet && isEnabled.Value == null)
                throw new ArgumentNullException(nameof(isEnabled), "Property is not nullable for class UpdateCustomRewardBody.");

            if (isUserInputRequired.IsSet && isUserInputRequired.Value == null)
                throw new ArgumentNullException(nameof(isUserInputRequired), "Property is not nullable for class UpdateCustomRewardBody.");

            if (isMaxPerStreamEnabled.IsSet && isMaxPerStreamEnabled.Value == null)
                throw new ArgumentNullException(nameof(isMaxPerStreamEnabled), "Property is not nullable for class UpdateCustomRewardBody.");

            if (maxPerStream.IsSet && maxPerStream.Value == null)
                throw new ArgumentNullException(nameof(maxPerStream), "Property is not nullable for class UpdateCustomRewardBody.");

            if (isMaxPerUserPerStreamEnabled.IsSet && isMaxPerUserPerStreamEnabled.Value == null)
                throw new ArgumentNullException(nameof(isMaxPerUserPerStreamEnabled), "Property is not nullable for class UpdateCustomRewardBody.");

            if (maxPerUserPerStream.IsSet && maxPerUserPerStream.Value == null)
                throw new ArgumentNullException(nameof(maxPerUserPerStream), "Property is not nullable for class UpdateCustomRewardBody.");

            if (isGlobalCooldownEnabled.IsSet && isGlobalCooldownEnabled.Value == null)
                throw new ArgumentNullException(nameof(isGlobalCooldownEnabled), "Property is not nullable for class UpdateCustomRewardBody.");

            if (globalCooldownSeconds.IsSet && globalCooldownSeconds.Value == null)
                throw new ArgumentNullException(nameof(globalCooldownSeconds), "Property is not nullable for class UpdateCustomRewardBody.");

            if (isPaused.IsSet && isPaused.Value == null)
                throw new ArgumentNullException(nameof(isPaused), "Property is not nullable for class UpdateCustomRewardBody.");

            if (shouldRedemptionsSkipRequestQueue.IsSet && shouldRedemptionsSkipRequestQueue.Value == null)
                throw new ArgumentNullException(nameof(shouldRedemptionsSkipRequestQueue), "Property is not nullable for class UpdateCustomRewardBody.");

            return new UpdateCustomRewardBody(title, prompt, cost, backgroundColor, isEnabled, isUserInputRequired, isMaxPerStreamEnabled, maxPerStream, isMaxPerUserPerStreamEnabled, maxPerUserPerStream, isGlobalCooldownEnabled, globalCooldownSeconds, isPaused, shouldRedemptionsSkipRequestQueue);
        }

        /// <summary>
        /// Serializes a <see cref="UpdateCustomRewardBody" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="updateCustomRewardBody"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, UpdateCustomRewardBody updateCustomRewardBody, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, updateCustomRewardBody, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="UpdateCustomRewardBody" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="updateCustomRewardBody"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, UpdateCustomRewardBody updateCustomRewardBody, JsonSerializerOptions jsonSerializerOptions)
        {
            if (updateCustomRewardBody.TitleOption.IsSet && updateCustomRewardBody.Title == null)
                throw new ArgumentNullException(nameof(updateCustomRewardBody.Title), "Property is required for class UpdateCustomRewardBody.");

            if (updateCustomRewardBody.PromptOption.IsSet && updateCustomRewardBody.Prompt == null)
                throw new ArgumentNullException(nameof(updateCustomRewardBody.Prompt), "Property is required for class UpdateCustomRewardBody.");

            if (updateCustomRewardBody.BackgroundColorOption.IsSet && updateCustomRewardBody.BackgroundColor == null)
                throw new ArgumentNullException(nameof(updateCustomRewardBody.BackgroundColor), "Property is required for class UpdateCustomRewardBody.");

            if (updateCustomRewardBody.TitleOption.IsSet)
                writer.WriteString("title", updateCustomRewardBody.Title);

            if (updateCustomRewardBody.PromptOption.IsSet)
                writer.WriteString("prompt", updateCustomRewardBody.Prompt);

            if (updateCustomRewardBody.CostOption.IsSet)
                writer.WriteNumber("cost", updateCustomRewardBody.CostOption.Value!.Value);

            if (updateCustomRewardBody.BackgroundColorOption.IsSet)
                writer.WriteString("background_color", updateCustomRewardBody.BackgroundColor);

            if (updateCustomRewardBody.IsEnabledOption.IsSet)
                writer.WriteBoolean("is_enabled", updateCustomRewardBody.IsEnabledOption.Value!.Value);

            if (updateCustomRewardBody.IsUserInputRequiredOption.IsSet)
                writer.WriteBoolean("is_user_input_required", updateCustomRewardBody.IsUserInputRequiredOption.Value!.Value);

            if (updateCustomRewardBody.IsMaxPerStreamEnabledOption.IsSet)
                writer.WriteBoolean("is_max_per_stream_enabled", updateCustomRewardBody.IsMaxPerStreamEnabledOption.Value!.Value);

            if (updateCustomRewardBody.MaxPerStreamOption.IsSet)
                writer.WriteNumber("max_per_stream", updateCustomRewardBody.MaxPerStreamOption.Value!.Value);

            if (updateCustomRewardBody.IsMaxPerUserPerStreamEnabledOption.IsSet)
                writer.WriteBoolean("is_max_per_user_per_stream_enabled", updateCustomRewardBody.IsMaxPerUserPerStreamEnabledOption.Value!.Value);

            if (updateCustomRewardBody.MaxPerUserPerStreamOption.IsSet)
                writer.WriteNumber("max_per_user_per_stream", updateCustomRewardBody.MaxPerUserPerStreamOption.Value!.Value);

            if (updateCustomRewardBody.IsGlobalCooldownEnabledOption.IsSet)
                writer.WriteBoolean("is_global_cooldown_enabled", updateCustomRewardBody.IsGlobalCooldownEnabledOption.Value!.Value);

            if (updateCustomRewardBody.GlobalCooldownSecondsOption.IsSet)
                writer.WriteNumber("global_cooldown_seconds", updateCustomRewardBody.GlobalCooldownSecondsOption.Value!.Value);

            if (updateCustomRewardBody.IsPausedOption.IsSet)
                writer.WriteBoolean("is_paused", updateCustomRewardBody.IsPausedOption.Value!.Value);

            if (updateCustomRewardBody.ShouldRedemptionsSkipRequestQueueOption.IsSet)
                writer.WriteBoolean("should_redemptions_skip_request_queue", updateCustomRewardBody.ShouldRedemptionsSkipRequestQueueOption.Value!.Value);
        }
    }
}
