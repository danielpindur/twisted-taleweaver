// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Model
{
    /// <summary>
    /// BlockedTerm
    /// </summary>
    public partial class BlockedTerm : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="BlockedTerm" /> class.
        /// </summary>
        /// <param name="broadcasterId">The broadcaster that owns the list of blocked terms.</param>
        /// <param name="moderatorId">The moderator that blocked the word or phrase from being used in the broadcaster’s chat room.</param>
        /// <param name="id">An ID that identifies this blocked term.</param>
        /// <param name="text">The blocked word or phrase.</param>
        /// <param name="createdAt">The UTC date and time (in RFC3339 format) that the term was blocked.</param>
        /// <param name="updatedAt">The UTC date and time (in RFC3339 format) that the term was updated.      When the term is added, this timestamp is the same as &#x60;created_at&#x60;. The timestamp changes as AutoMod continues to deny the term.</param>
        /// <param name="expiresAt">The UTC date and time (in RFC3339 format) that the blocked term is set to expire. After the block expires, users may use the term in the broadcaster’s chat room.      This field is **null** if the term was added manually or was permanently blocked by AutoMod.</param>
        [JsonConstructor]
        public BlockedTerm(string broadcasterId, string moderatorId, string id, string text, DateTime createdAt, DateTime updatedAt, DateTime? expiresAt = default)
        {
            BroadcasterId = broadcasterId;
            ModeratorId = moderatorId;
            Id = id;
            Text = text;
            CreatedAt = createdAt;
            UpdatedAt = updatedAt;
            ExpiresAt = expiresAt;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// The broadcaster that owns the list of blocked terms.
        /// </summary>
        /// <value>The broadcaster that owns the list of blocked terms.</value>
        [JsonPropertyName("broadcaster_id")]
        public string BroadcasterId { get; set; }

        /// <summary>
        /// The moderator that blocked the word or phrase from being used in the broadcaster’s chat room.
        /// </summary>
        /// <value>The moderator that blocked the word or phrase from being used in the broadcaster’s chat room.</value>
        [JsonPropertyName("moderator_id")]
        public string ModeratorId { get; set; }

        /// <summary>
        /// An ID that identifies this blocked term.
        /// </summary>
        /// <value>An ID that identifies this blocked term.</value>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// The blocked word or phrase.
        /// </summary>
        /// <value>The blocked word or phrase.</value>
        [JsonPropertyName("text")]
        public string Text { get; set; }

        /// <summary>
        /// The UTC date and time (in RFC3339 format) that the term was blocked.
        /// </summary>
        /// <value>The UTC date and time (in RFC3339 format) that the term was blocked.</value>
        [JsonPropertyName("created_at")]
        public DateTime CreatedAt { get; set; }

        /// <summary>
        /// The UTC date and time (in RFC3339 format) that the term was updated.      When the term is added, this timestamp is the same as &#x60;created_at&#x60;. The timestamp changes as AutoMod continues to deny the term.
        /// </summary>
        /// <value>The UTC date and time (in RFC3339 format) that the term was updated.      When the term is added, this timestamp is the same as &#x60;created_at&#x60;. The timestamp changes as AutoMod continues to deny the term.</value>
        [JsonPropertyName("updated_at")]
        public DateTime UpdatedAt { get; set; }

        /// <summary>
        /// The UTC date and time (in RFC3339 format) that the blocked term is set to expire. After the block expires, users may use the term in the broadcaster’s chat room.      This field is **null** if the term was added manually or was permanently blocked by AutoMod.
        /// </summary>
        /// <value>The UTC date and time (in RFC3339 format) that the blocked term is set to expire. After the block expires, users may use the term in the broadcaster’s chat room.      This field is **null** if the term was added manually or was permanently blocked by AutoMod.</value>
        [JsonPropertyName("expires_at")]
        public DateTime? ExpiresAt { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class BlockedTerm {\n");
            sb.Append("  BroadcasterId: ").Append(BroadcasterId).Append("\n");
            sb.Append("  ModeratorId: ").Append(ModeratorId).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Text: ").Append(Text).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  UpdatedAt: ").Append(UpdatedAt).Append("\n");
            sb.Append("  ExpiresAt: ").Append(ExpiresAt).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="BlockedTerm" />
    /// </summary>
    public class BlockedTermJsonConverter : JsonConverter<BlockedTerm>
    {
        /// <summary>
        /// The format to use to serialize CreatedAt
        /// </summary>
        public static string CreatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize UpdatedAt
        /// </summary>
        public static string UpdatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize ExpiresAt
        /// </summary>
        public static string ExpiresAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="BlockedTerm" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override BlockedTerm Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> broadcasterId = default;
            Option<string?> moderatorId = default;
            Option<string?> id = default;
            Option<string?> text = default;
            Option<DateTime?> createdAt = default;
            Option<DateTime?> updatedAt = default;
            Option<DateTime?> expiresAt = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "broadcaster_id":
                            broadcasterId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "moderator_id":
                            moderatorId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "id":
                            id = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "text":
                            text = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "created_at":
                            createdAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "updated_at":
                            updatedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "expires_at":
                            expiresAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime?>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!broadcasterId.IsSet)
                throw new ArgumentException("Property is required for class BlockedTerm.", nameof(broadcasterId));

            if (!moderatorId.IsSet)
                throw new ArgumentException("Property is required for class BlockedTerm.", nameof(moderatorId));

            if (!id.IsSet)
                throw new ArgumentException("Property is required for class BlockedTerm.", nameof(id));

            if (!text.IsSet)
                throw new ArgumentException("Property is required for class BlockedTerm.", nameof(text));

            if (!createdAt.IsSet)
                throw new ArgumentException("Property is required for class BlockedTerm.", nameof(createdAt));

            if (!updatedAt.IsSet)
                throw new ArgumentException("Property is required for class BlockedTerm.", nameof(updatedAt));

            if (!expiresAt.IsSet)
                throw new ArgumentException("Property is required for class BlockedTerm.", nameof(expiresAt));

            if (broadcasterId.IsSet && broadcasterId.Value == null)
                throw new ArgumentNullException(nameof(broadcasterId), "Property is not nullable for class BlockedTerm.");

            if (moderatorId.IsSet && moderatorId.Value == null)
                throw new ArgumentNullException(nameof(moderatorId), "Property is not nullable for class BlockedTerm.");

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class BlockedTerm.");

            if (text.IsSet && text.Value == null)
                throw new ArgumentNullException(nameof(text), "Property is not nullable for class BlockedTerm.");

            if (createdAt.IsSet && createdAt.Value == null)
                throw new ArgumentNullException(nameof(createdAt), "Property is not nullable for class BlockedTerm.");

            if (updatedAt.IsSet && updatedAt.Value == null)
                throw new ArgumentNullException(nameof(updatedAt), "Property is not nullable for class BlockedTerm.");

            return new BlockedTerm(broadcasterId.Value!, moderatorId.Value!, id.Value!, text.Value!, createdAt.Value!.Value!, updatedAt.Value!.Value!, expiresAt.Value!);
        }

        /// <summary>
        /// Serializes a <see cref="BlockedTerm" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="blockedTerm"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, BlockedTerm blockedTerm, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, blockedTerm, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="BlockedTerm" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="blockedTerm"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, BlockedTerm blockedTerm, JsonSerializerOptions jsonSerializerOptions)
        {
            if (blockedTerm.BroadcasterId == null)
                throw new ArgumentNullException(nameof(blockedTerm.BroadcasterId), "Property is required for class BlockedTerm.");

            if (blockedTerm.ModeratorId == null)
                throw new ArgumentNullException(nameof(blockedTerm.ModeratorId), "Property is required for class BlockedTerm.");

            if (blockedTerm.Id == null)
                throw new ArgumentNullException(nameof(blockedTerm.Id), "Property is required for class BlockedTerm.");

            if (blockedTerm.Text == null)
                throw new ArgumentNullException(nameof(blockedTerm.Text), "Property is required for class BlockedTerm.");

            writer.WriteString("broadcaster_id", blockedTerm.BroadcasterId);

            writer.WriteString("moderator_id", blockedTerm.ModeratorId);

            writer.WriteString("id", blockedTerm.Id);

            writer.WriteString("text", blockedTerm.Text);

            writer.WriteString("created_at", blockedTerm.CreatedAt.ToString(CreatedAtFormat));

            writer.WriteString("updated_at", blockedTerm.UpdatedAt.ToString(UpdatedAtFormat));

            if (blockedTerm.ExpiresAt != null)
                writer.WriteString("expires_at", blockedTerm.ExpiresAt.Value.ToString(ExpiresAtFormat));
            else
                writer.WriteNull("expires_at");
        }
    }
}
