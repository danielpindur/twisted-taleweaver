// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Model
{
    /// <summary>
    /// EndPredictionBody
    /// </summary>
    public partial class EndPredictionBody : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EndPredictionBody" /> class.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that’s running the prediction. This ID must match the user ID in the user access token.</param>
        /// <param name="id">The ID of the prediction to update.</param>
        /// <param name="status">The status to set the prediction to. Possible case-sensitive values are:      * RESOLVED — The winning outcome is determined and the Channel Points are distributed to the viewers who predicted the correct outcome. * CANCELED — The broadcaster is canceling the prediction and sending refunds to the participants. * LOCKED — The broadcaster is locking the prediction, which means viewers may no longer make predictions.    The broadcaster can update an active prediction to LOCKED, RESOLVED, or CANCELED; and update a locked prediction to RESOLVED or CANCELED.      The broadcaster has up to 24 hours after the prediction window closes to resolve the prediction. If not, Twitch sets the status to CANCELED and returns the points.</param>
        /// <param name="winningOutcomeId">The ID of the winning outcome. You must set this parameter if you set &#x60;status&#x60; to RESOLVED.</param>
        [JsonConstructor]
        public EndPredictionBody(string broadcasterId, string id, StatusEnum status, Option<string?> winningOutcomeId = default)
        {
            BroadcasterId = broadcasterId;
            Id = id;
            Status = status;
            WinningOutcomeIdOption = winningOutcomeId;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// The status to set the prediction to. Possible case-sensitive values are:      * RESOLVED — The winning outcome is determined and the Channel Points are distributed to the viewers who predicted the correct outcome. * CANCELED — The broadcaster is canceling the prediction and sending refunds to the participants. * LOCKED — The broadcaster is locking the prediction, which means viewers may no longer make predictions.    The broadcaster can update an active prediction to LOCKED, RESOLVED, or CANCELED; and update a locked prediction to RESOLVED or CANCELED.      The broadcaster has up to 24 hours after the prediction window closes to resolve the prediction. If not, Twitch sets the status to CANCELED and returns the points.
        /// </summary>
        /// <value>The status to set the prediction to. Possible case-sensitive values are:      * RESOLVED — The winning outcome is determined and the Channel Points are distributed to the viewers who predicted the correct outcome. * CANCELED — The broadcaster is canceling the prediction and sending refunds to the participants. * LOCKED — The broadcaster is locking the prediction, which means viewers may no longer make predictions.    The broadcaster can update an active prediction to LOCKED, RESOLVED, or CANCELED; and update a locked prediction to RESOLVED or CANCELED.      The broadcaster has up to 24 hours after the prediction window closes to resolve the prediction. If not, Twitch sets the status to CANCELED and returns the points.</value>
        public enum StatusEnum
        {
            /// <summary>
            /// Enum RESOLVED for value: RESOLVED
            /// </summary>
            RESOLVED = 1,

            /// <summary>
            /// Enum CANCELED for value: CANCELED
            /// </summary>
            CANCELED = 2,

            /// <summary>
            /// Enum LOCKED for value: LOCKED
            /// </summary>
            LOCKED = 3
        }

        /// <summary>
        /// Returns a <see cref="StatusEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static StatusEnum StatusEnumFromString(string value)
        {
            if (value.Equals("RESOLVED"))
                return StatusEnum.RESOLVED;

            if (value.Equals("CANCELED"))
                return StatusEnum.CANCELED;

            if (value.Equals("LOCKED"))
                return StatusEnum.LOCKED;

            throw new NotImplementedException($"Could not convert value to type StatusEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="StatusEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static StatusEnum? StatusEnumFromStringOrDefault(string value)
        {
            if (value.Equals("RESOLVED"))
                return StatusEnum.RESOLVED;

            if (value.Equals("CANCELED"))
                return StatusEnum.CANCELED;

            if (value.Equals("LOCKED"))
                return StatusEnum.LOCKED;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="StatusEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string StatusEnumToJsonValue(StatusEnum value)
        {
            if (value == StatusEnum.RESOLVED)
                return "RESOLVED";

            if (value == StatusEnum.CANCELED)
                return "CANCELED";

            if (value == StatusEnum.LOCKED)
                return "LOCKED";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// The status to set the prediction to. Possible case-sensitive values are:      * RESOLVED — The winning outcome is determined and the Channel Points are distributed to the viewers who predicted the correct outcome. * CANCELED — The broadcaster is canceling the prediction and sending refunds to the participants. * LOCKED — The broadcaster is locking the prediction, which means viewers may no longer make predictions.    The broadcaster can update an active prediction to LOCKED, RESOLVED, or CANCELED; and update a locked prediction to RESOLVED or CANCELED.      The broadcaster has up to 24 hours after the prediction window closes to resolve the prediction. If not, Twitch sets the status to CANCELED and returns the points.
        /// </summary>
        /// <value>The status to set the prediction to. Possible case-sensitive values are:      * RESOLVED — The winning outcome is determined and the Channel Points are distributed to the viewers who predicted the correct outcome. * CANCELED — The broadcaster is canceling the prediction and sending refunds to the participants. * LOCKED — The broadcaster is locking the prediction, which means viewers may no longer make predictions.    The broadcaster can update an active prediction to LOCKED, RESOLVED, or CANCELED; and update a locked prediction to RESOLVED or CANCELED.      The broadcaster has up to 24 hours after the prediction window closes to resolve the prediction. If not, Twitch sets the status to CANCELED and returns the points.</value>
        [JsonPropertyName("status")]
        public StatusEnum Status { get; set; }

        /// <summary>
        /// The ID of the broadcaster that’s running the prediction. This ID must match the user ID in the user access token.
        /// </summary>
        /// <value>The ID of the broadcaster that’s running the prediction. This ID must match the user ID in the user access token.</value>
        [JsonPropertyName("broadcaster_id")]
        public string BroadcasterId { get; set; }

        /// <summary>
        /// The ID of the prediction to update.
        /// </summary>
        /// <value>The ID of the prediction to update.</value>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Used to track the state of WinningOutcomeId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> WinningOutcomeIdOption { get; private set; }

        /// <summary>
        /// The ID of the winning outcome. You must set this parameter if you set &#x60;status&#x60; to RESOLVED.
        /// </summary>
        /// <value>The ID of the winning outcome. You must set this parameter if you set &#x60;status&#x60; to RESOLVED.</value>
        [JsonPropertyName("winning_outcome_id")]
        public string? WinningOutcomeId { get { return this.WinningOutcomeIdOption; } set { this.WinningOutcomeIdOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class EndPredictionBody {\n");
            sb.Append("  BroadcasterId: ").Append(BroadcasterId).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Status: ").Append(Status).Append("\n");
            sb.Append("  WinningOutcomeId: ").Append(WinningOutcomeId).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="EndPredictionBody" />
    /// </summary>
    public class EndPredictionBodyJsonConverter : JsonConverter<EndPredictionBody>
    {
        /// <summary>
        /// Deserializes json to <see cref="EndPredictionBody" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override EndPredictionBody Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> broadcasterId = default;
            Option<string?> id = default;
            Option<EndPredictionBody.StatusEnum?> status = default;
            Option<string?> winningOutcomeId = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "broadcaster_id":
                            broadcasterId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "id":
                            id = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "status":
                            string? statusRawValue = utf8JsonReader.GetString();
                            if (statusRawValue != null)
                                status = new Option<EndPredictionBody.StatusEnum?>(EndPredictionBody.StatusEnumFromStringOrDefault(statusRawValue));
                            break;
                        case "winning_outcome_id":
                            winningOutcomeId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!broadcasterId.IsSet)
                throw new ArgumentException("Property is required for class EndPredictionBody.", nameof(broadcasterId));

            if (!id.IsSet)
                throw new ArgumentException("Property is required for class EndPredictionBody.", nameof(id));

            if (!status.IsSet)
                throw new ArgumentException("Property is required for class EndPredictionBody.", nameof(status));

            if (broadcasterId.IsSet && broadcasterId.Value == null)
                throw new ArgumentNullException(nameof(broadcasterId), "Property is not nullable for class EndPredictionBody.");

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class EndPredictionBody.");

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status), "Property is not nullable for class EndPredictionBody.");

            if (winningOutcomeId.IsSet && winningOutcomeId.Value == null)
                throw new ArgumentNullException(nameof(winningOutcomeId), "Property is not nullable for class EndPredictionBody.");

            return new EndPredictionBody(broadcasterId.Value!, id.Value!, status.Value!.Value!, winningOutcomeId);
        }

        /// <summary>
        /// Serializes a <see cref="EndPredictionBody" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="endPredictionBody"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, EndPredictionBody endPredictionBody, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, endPredictionBody, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="EndPredictionBody" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="endPredictionBody"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, EndPredictionBody endPredictionBody, JsonSerializerOptions jsonSerializerOptions)
        {
            if (endPredictionBody.BroadcasterId == null)
                throw new ArgumentNullException(nameof(endPredictionBody.BroadcasterId), "Property is required for class EndPredictionBody.");

            if (endPredictionBody.Id == null)
                throw new ArgumentNullException(nameof(endPredictionBody.Id), "Property is required for class EndPredictionBody.");

            if (endPredictionBody.WinningOutcomeIdOption.IsSet && endPredictionBody.WinningOutcomeId == null)
                throw new ArgumentNullException(nameof(endPredictionBody.WinningOutcomeId), "Property is required for class EndPredictionBody.");

            writer.WriteString("broadcaster_id", endPredictionBody.BroadcasterId);

            writer.WriteString("id", endPredictionBody.Id);

            var statusRawValue = EndPredictionBody.StatusEnumToJsonValue(endPredictionBody.Status);
            writer.WriteString("status", statusRawValue);
            if (endPredictionBody.WinningOutcomeIdOption.IsSet)
                writer.WriteString("winning_outcome_id", endPredictionBody.WinningOutcomeId);
        }
    }
}
