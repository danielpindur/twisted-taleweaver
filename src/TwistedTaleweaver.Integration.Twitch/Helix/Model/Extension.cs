// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Model
{
    /// <summary>
    /// Extension
    /// </summary>
    public partial class Extension : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Extension" /> class.
        /// </summary>
        /// <param name="authorName">The name of the user or organization that owns the extension.</param>
        /// <param name="bitsEnabled">A Boolean value that determines whether the extension has features that use Bits. Is **true** if the extension has features that use Bits.</param>
        /// <param name="canInstall">A Boolean value that determines whether a user can install the extension on their channel. Is **true** if a user can install the extension.      Typically, this is set to **false** if the extension is currently in testing mode and requires users to be allowlisted (the allowlist is configured on Twitch’s [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \\-&gt; **Extension** \\-&gt; **Version** \\-&gt; **Access**).</param>
        /// <param name="configurationLocation">The location of where the extension’s configuration is stored. Possible values are:      * hosted — The Extensions Configuration Service hosts the configuration. * custom — The Extension Backend Service (EBS) hosts the configuration. * none — The extension doesn&#39;t require configuration.</param>
        /// <param name="description">A longer description of the extension. It appears on the details page.</param>
        /// <param name="eulaTosUrl">A URL to the extension’s Terms of Service.</param>
        /// <param name="hasChatSupport">A Boolean value that determines whether the extension can communicate with the installed channel’s chat. Is **true** if the extension can communicate with the channel’s chat room.</param>
        /// <param name="iconUrl">A URL to the default icon that’s displayed in the Extensions directory.</param>
        /// <param name="iconUrls">iconUrls</param>
        /// <param name="id">The extension’s ID.</param>
        /// <param name="name">The extension’s name.</param>
        /// <param name="privacyPolicyUrl">A URL to the extension’s privacy policy.</param>
        /// <param name="requestIdentityLink">A Boolean value that determines whether the extension wants to explicitly ask viewers to link their Twitch identity.</param>
        /// <param name="screenshotUrls">A list of URLs to screenshots that are shown in the Extensions marketplace.</param>
        /// <param name="state">The extension’s state. Possible values are:      * Approved * AssetsUploaded * Deleted * Deprecated * InReview * InTest * PendingAction * Rejected * Released</param>
        /// <param name="subscriptionsSupportLevel">Indicates whether the extension can view the user’s subscription level on the channel that the extension is installed on. Possible values are:      * none — The extension can&#39;t view the user’s subscription level. * optional — The extension can view the user’s subscription level.</param>
        /// <param name="summary">A short description of the extension that streamers see when hovering over the discovery splash screen in the Extensions manager.</param>
        /// <param name="supportEmail">The email address that users use to get support for the extension.</param>
        /// <param name="varVersion">The extension’s version number.</param>
        /// <param name="viewerSummary">A brief description displayed on the channel to explain how the extension works.</param>
        /// <param name="views">views</param>
        /// <param name="allowlistedConfigUrls">Allowlisted configuration URLs for displaying the extension (the allowlist is configured on Twitch’s [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \\-&gt; **Extension** \\-&gt; **Version** \\-&gt; **Capabilities**).</param>
        /// <param name="allowlistedPanelUrls">Allowlisted panel URLs for displaying the extension (the allowlist is configured on Twitch’s [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \\-&gt; **Extension** \\-&gt; **Version** \\-&gt; **Capabilities**).</param>
        [JsonConstructor]
        public Extension(string authorName, bool bitsEnabled, bool canInstall, ConfigurationLocationEnum configurationLocation, string description, string eulaTosUrl, bool hasChatSupport, string iconUrl, ExtensionIconUrls iconUrls, string id, string name, string privacyPolicyUrl, bool requestIdentityLink, List<string> screenshotUrls, StateEnum state, SubscriptionsSupportLevelEnum subscriptionsSupportLevel, string summary, string supportEmail, string varVersion, string viewerSummary, ExtensionViews views, List<string> allowlistedConfigUrls, List<string> allowlistedPanelUrls)
        {
            AuthorName = authorName;
            BitsEnabled = bitsEnabled;
            CanInstall = canInstall;
            ConfigurationLocation = configurationLocation;
            Description = description;
            EulaTosUrl = eulaTosUrl;
            HasChatSupport = hasChatSupport;
            IconUrl = iconUrl;
            IconUrls = iconUrls;
            Id = id;
            Name = name;
            PrivacyPolicyUrl = privacyPolicyUrl;
            RequestIdentityLink = requestIdentityLink;
            ScreenshotUrls = screenshotUrls;
            State = state;
            SubscriptionsSupportLevel = subscriptionsSupportLevel;
            Summary = summary;
            SupportEmail = supportEmail;
            VarVersion = varVersion;
            ViewerSummary = viewerSummary;
            Views = views;
            AllowlistedConfigUrls = allowlistedConfigUrls;
            AllowlistedPanelUrls = allowlistedPanelUrls;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// The location of where the extension’s configuration is stored. Possible values are:      * hosted — The Extensions Configuration Service hosts the configuration. * custom — The Extension Backend Service (EBS) hosts the configuration. * none — The extension doesn&#39;t require configuration.
        /// </summary>
        /// <value>The location of where the extension’s configuration is stored. Possible values are:      * hosted — The Extensions Configuration Service hosts the configuration. * custom — The Extension Backend Service (EBS) hosts the configuration. * none — The extension doesn&#39;t require configuration.</value>
        public enum ConfigurationLocationEnum
        {
            /// <summary>
            /// Enum Hosted for value: hosted
            /// </summary>
            Hosted = 1,

            /// <summary>
            /// Enum Custom for value: custom
            /// </summary>
            Custom = 2,

            /// <summary>
            /// Enum None for value: none
            /// </summary>
            None = 3
        }

        /// <summary>
        /// Returns a <see cref="ConfigurationLocationEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static ConfigurationLocationEnum ConfigurationLocationEnumFromString(string value)
        {
            if (value.Equals("hosted"))
                return ConfigurationLocationEnum.Hosted;

            if (value.Equals("custom"))
                return ConfigurationLocationEnum.Custom;

            if (value.Equals("none"))
                return ConfigurationLocationEnum.None;

            throw new NotImplementedException($"Could not convert value to type ConfigurationLocationEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="ConfigurationLocationEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static ConfigurationLocationEnum? ConfigurationLocationEnumFromStringOrDefault(string value)
        {
            if (value.Equals("hosted"))
                return ConfigurationLocationEnum.Hosted;

            if (value.Equals("custom"))
                return ConfigurationLocationEnum.Custom;

            if (value.Equals("none"))
                return ConfigurationLocationEnum.None;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="ConfigurationLocationEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string ConfigurationLocationEnumToJsonValue(ConfigurationLocationEnum value)
        {
            if (value == ConfigurationLocationEnum.Hosted)
                return "hosted";

            if (value == ConfigurationLocationEnum.Custom)
                return "custom";

            if (value == ConfigurationLocationEnum.None)
                return "none";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// The location of where the extension’s configuration is stored. Possible values are:      * hosted — The Extensions Configuration Service hosts the configuration. * custom — The Extension Backend Service (EBS) hosts the configuration. * none — The extension doesn&#39;t require configuration.
        /// </summary>
        /// <value>The location of where the extension’s configuration is stored. Possible values are:      * hosted — The Extensions Configuration Service hosts the configuration. * custom — The Extension Backend Service (EBS) hosts the configuration. * none — The extension doesn&#39;t require configuration.</value>
        [JsonPropertyName("configuration_location")]
        public ConfigurationLocationEnum ConfigurationLocation { get; set; }

        /// <summary>
        /// The extension’s state. Possible values are:      * Approved * AssetsUploaded * Deleted * Deprecated * InReview * InTest * PendingAction * Rejected * Released
        /// </summary>
        /// <value>The extension’s state. Possible values are:      * Approved * AssetsUploaded * Deleted * Deprecated * InReview * InTest * PendingAction * Rejected * Released</value>
        public enum StateEnum
        {
            /// <summary>
            /// Enum Approved for value: Approved
            /// </summary>
            Approved = 1,

            /// <summary>
            /// Enum AssetsUploaded for value: AssetsUploaded
            /// </summary>
            AssetsUploaded = 2,

            /// <summary>
            /// Enum Deleted for value: Deleted
            /// </summary>
            Deleted = 3,

            /// <summary>
            /// Enum Deprecated for value: Deprecated
            /// </summary>
            Deprecated = 4,

            /// <summary>
            /// Enum InReview for value: InReview
            /// </summary>
            InReview = 5,

            /// <summary>
            /// Enum InTest for value: InTest
            /// </summary>
            InTest = 6,

            /// <summary>
            /// Enum PendingAction for value: PendingAction
            /// </summary>
            PendingAction = 7,

            /// <summary>
            /// Enum Rejected for value: Rejected
            /// </summary>
            Rejected = 8,

            /// <summary>
            /// Enum Released for value: Released
            /// </summary>
            Released = 9
        }

        /// <summary>
        /// Returns a <see cref="StateEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static StateEnum StateEnumFromString(string value)
        {
            if (value.Equals("Approved"))
                return StateEnum.Approved;

            if (value.Equals("AssetsUploaded"))
                return StateEnum.AssetsUploaded;

            if (value.Equals("Deleted"))
                return StateEnum.Deleted;

            if (value.Equals("Deprecated"))
                return StateEnum.Deprecated;

            if (value.Equals("InReview"))
                return StateEnum.InReview;

            if (value.Equals("InTest"))
                return StateEnum.InTest;

            if (value.Equals("PendingAction"))
                return StateEnum.PendingAction;

            if (value.Equals("Rejected"))
                return StateEnum.Rejected;

            if (value.Equals("Released"))
                return StateEnum.Released;

            throw new NotImplementedException($"Could not convert value to type StateEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="StateEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static StateEnum? StateEnumFromStringOrDefault(string value)
        {
            if (value.Equals("Approved"))
                return StateEnum.Approved;

            if (value.Equals("AssetsUploaded"))
                return StateEnum.AssetsUploaded;

            if (value.Equals("Deleted"))
                return StateEnum.Deleted;

            if (value.Equals("Deprecated"))
                return StateEnum.Deprecated;

            if (value.Equals("InReview"))
                return StateEnum.InReview;

            if (value.Equals("InTest"))
                return StateEnum.InTest;

            if (value.Equals("PendingAction"))
                return StateEnum.PendingAction;

            if (value.Equals("Rejected"))
                return StateEnum.Rejected;

            if (value.Equals("Released"))
                return StateEnum.Released;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="StateEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string StateEnumToJsonValue(StateEnum value)
        {
            if (value == StateEnum.Approved)
                return "Approved";

            if (value == StateEnum.AssetsUploaded)
                return "AssetsUploaded";

            if (value == StateEnum.Deleted)
                return "Deleted";

            if (value == StateEnum.Deprecated)
                return "Deprecated";

            if (value == StateEnum.InReview)
                return "InReview";

            if (value == StateEnum.InTest)
                return "InTest";

            if (value == StateEnum.PendingAction)
                return "PendingAction";

            if (value == StateEnum.Rejected)
                return "Rejected";

            if (value == StateEnum.Released)
                return "Released";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// The extension’s state. Possible values are:      * Approved * AssetsUploaded * Deleted * Deprecated * InReview * InTest * PendingAction * Rejected * Released
        /// </summary>
        /// <value>The extension’s state. Possible values are:      * Approved * AssetsUploaded * Deleted * Deprecated * InReview * InTest * PendingAction * Rejected * Released</value>
        [JsonPropertyName("state")]
        public StateEnum State { get; set; }

        /// <summary>
        /// Indicates whether the extension can view the user’s subscription level on the channel that the extension is installed on. Possible values are:      * none — The extension can&#39;t view the user’s subscription level. * optional — The extension can view the user’s subscription level.
        /// </summary>
        /// <value>Indicates whether the extension can view the user’s subscription level on the channel that the extension is installed on. Possible values are:      * none — The extension can&#39;t view the user’s subscription level. * optional — The extension can view the user’s subscription level.</value>
        public enum SubscriptionsSupportLevelEnum
        {
            /// <summary>
            /// Enum None for value: none
            /// </summary>
            None = 1,

            /// <summary>
            /// Enum Optional for value: optional
            /// </summary>
            Optional = 2
        }

        /// <summary>
        /// Returns a <see cref="SubscriptionsSupportLevelEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static SubscriptionsSupportLevelEnum SubscriptionsSupportLevelEnumFromString(string value)
        {
            if (value.Equals("none"))
                return SubscriptionsSupportLevelEnum.None;

            if (value.Equals("optional"))
                return SubscriptionsSupportLevelEnum.Optional;

            throw new NotImplementedException($"Could not convert value to type SubscriptionsSupportLevelEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="SubscriptionsSupportLevelEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static SubscriptionsSupportLevelEnum? SubscriptionsSupportLevelEnumFromStringOrDefault(string value)
        {
            if (value.Equals("none"))
                return SubscriptionsSupportLevelEnum.None;

            if (value.Equals("optional"))
                return SubscriptionsSupportLevelEnum.Optional;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="SubscriptionsSupportLevelEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string SubscriptionsSupportLevelEnumToJsonValue(SubscriptionsSupportLevelEnum value)
        {
            if (value == SubscriptionsSupportLevelEnum.None)
                return "none";

            if (value == SubscriptionsSupportLevelEnum.Optional)
                return "optional";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Indicates whether the extension can view the user’s subscription level on the channel that the extension is installed on. Possible values are:      * none — The extension can&#39;t view the user’s subscription level. * optional — The extension can view the user’s subscription level.
        /// </summary>
        /// <value>Indicates whether the extension can view the user’s subscription level on the channel that the extension is installed on. Possible values are:      * none — The extension can&#39;t view the user’s subscription level. * optional — The extension can view the user’s subscription level.</value>
        [JsonPropertyName("subscriptions_support_level")]
        public SubscriptionsSupportLevelEnum SubscriptionsSupportLevel { get; set; }

        /// <summary>
        /// The name of the user or organization that owns the extension.
        /// </summary>
        /// <value>The name of the user or organization that owns the extension.</value>
        [JsonPropertyName("author_name")]
        public string AuthorName { get; set; }

        /// <summary>
        /// A Boolean value that determines whether the extension has features that use Bits. Is **true** if the extension has features that use Bits.
        /// </summary>
        /// <value>A Boolean value that determines whether the extension has features that use Bits. Is **true** if the extension has features that use Bits.</value>
        [JsonPropertyName("bits_enabled")]
        public bool BitsEnabled { get; set; }

        /// <summary>
        /// A Boolean value that determines whether a user can install the extension on their channel. Is **true** if a user can install the extension.      Typically, this is set to **false** if the extension is currently in testing mode and requires users to be allowlisted (the allowlist is configured on Twitch’s [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \\-&gt; **Extension** \\-&gt; **Version** \\-&gt; **Access**).
        /// </summary>
        /// <value>A Boolean value that determines whether a user can install the extension on their channel. Is **true** if a user can install the extension.      Typically, this is set to **false** if the extension is currently in testing mode and requires users to be allowlisted (the allowlist is configured on Twitch’s [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \\-&gt; **Extension** \\-&gt; **Version** \\-&gt; **Access**).</value>
        [JsonPropertyName("can_install")]
        public bool CanInstall { get; set; }

        /// <summary>
        /// A longer description of the extension. It appears on the details page.
        /// </summary>
        /// <value>A longer description of the extension. It appears on the details page.</value>
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// A URL to the extension’s Terms of Service.
        /// </summary>
        /// <value>A URL to the extension’s Terms of Service.</value>
        [JsonPropertyName("eula_tos_url")]
        public string EulaTosUrl { get; set; }

        /// <summary>
        /// A Boolean value that determines whether the extension can communicate with the installed channel’s chat. Is **true** if the extension can communicate with the channel’s chat room.
        /// </summary>
        /// <value>A Boolean value that determines whether the extension can communicate with the installed channel’s chat. Is **true** if the extension can communicate with the channel’s chat room.</value>
        [JsonPropertyName("has_chat_support")]
        public bool HasChatSupport { get; set; }

        /// <summary>
        /// A URL to the default icon that’s displayed in the Extensions directory.
        /// </summary>
        /// <value>A URL to the default icon that’s displayed in the Extensions directory.</value>
        [JsonPropertyName("icon_url")]
        public string IconUrl { get; set; }

        /// <summary>
        /// Gets or Sets IconUrls
        /// </summary>
        [JsonPropertyName("icon_urls")]
        public ExtensionIconUrls IconUrls { get; set; }

        /// <summary>
        /// The extension’s ID.
        /// </summary>
        /// <value>The extension’s ID.</value>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// The extension’s name.
        /// </summary>
        /// <value>The extension’s name.</value>
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// A URL to the extension’s privacy policy.
        /// </summary>
        /// <value>A URL to the extension’s privacy policy.</value>
        [JsonPropertyName("privacy_policy_url")]
        public string PrivacyPolicyUrl { get; set; }

        /// <summary>
        /// A Boolean value that determines whether the extension wants to explicitly ask viewers to link their Twitch identity.
        /// </summary>
        /// <value>A Boolean value that determines whether the extension wants to explicitly ask viewers to link their Twitch identity.</value>
        [JsonPropertyName("request_identity_link")]
        public bool RequestIdentityLink { get; set; }

        /// <summary>
        /// A list of URLs to screenshots that are shown in the Extensions marketplace.
        /// </summary>
        /// <value>A list of URLs to screenshots that are shown in the Extensions marketplace.</value>
        [JsonPropertyName("screenshot_urls")]
        public List<string> ScreenshotUrls { get; set; }

        /// <summary>
        /// A short description of the extension that streamers see when hovering over the discovery splash screen in the Extensions manager.
        /// </summary>
        /// <value>A short description of the extension that streamers see when hovering over the discovery splash screen in the Extensions manager.</value>
        [JsonPropertyName("summary")]
        public string Summary { get; set; }

        /// <summary>
        /// The email address that users use to get support for the extension.
        /// </summary>
        /// <value>The email address that users use to get support for the extension.</value>
        [JsonPropertyName("support_email")]
        public string SupportEmail { get; set; }

        /// <summary>
        /// The extension’s version number.
        /// </summary>
        /// <value>The extension’s version number.</value>
        [JsonPropertyName("version")]
        public string VarVersion { get; set; }

        /// <summary>
        /// A brief description displayed on the channel to explain how the extension works.
        /// </summary>
        /// <value>A brief description displayed on the channel to explain how the extension works.</value>
        [JsonPropertyName("viewer_summary")]
        public string ViewerSummary { get; set; }

        /// <summary>
        /// Gets or Sets Views
        /// </summary>
        [JsonPropertyName("views")]
        public ExtensionViews Views { get; set; }

        /// <summary>
        /// Allowlisted configuration URLs for displaying the extension (the allowlist is configured on Twitch’s [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \\-&gt; **Extension** \\-&gt; **Version** \\-&gt; **Capabilities**).
        /// </summary>
        /// <value>Allowlisted configuration URLs for displaying the extension (the allowlist is configured on Twitch’s [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \\-&gt; **Extension** \\-&gt; **Version** \\-&gt; **Capabilities**).</value>
        [JsonPropertyName("allowlisted_config_urls")]
        public List<string> AllowlistedConfigUrls { get; set; }

        /// <summary>
        /// Allowlisted panel URLs for displaying the extension (the allowlist is configured on Twitch’s [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \\-&gt; **Extension** \\-&gt; **Version** \\-&gt; **Capabilities**).
        /// </summary>
        /// <value>Allowlisted panel URLs for displaying the extension (the allowlist is configured on Twitch’s [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \\-&gt; **Extension** \\-&gt; **Version** \\-&gt; **Capabilities**).</value>
        [JsonPropertyName("allowlisted_panel_urls")]
        public List<string> AllowlistedPanelUrls { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Extension {\n");
            sb.Append("  AuthorName: ").Append(AuthorName).Append("\n");
            sb.Append("  BitsEnabled: ").Append(BitsEnabled).Append("\n");
            sb.Append("  CanInstall: ").Append(CanInstall).Append("\n");
            sb.Append("  ConfigurationLocation: ").Append(ConfigurationLocation).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  EulaTosUrl: ").Append(EulaTosUrl).Append("\n");
            sb.Append("  HasChatSupport: ").Append(HasChatSupport).Append("\n");
            sb.Append("  IconUrl: ").Append(IconUrl).Append("\n");
            sb.Append("  IconUrls: ").Append(IconUrls).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  PrivacyPolicyUrl: ").Append(PrivacyPolicyUrl).Append("\n");
            sb.Append("  RequestIdentityLink: ").Append(RequestIdentityLink).Append("\n");
            sb.Append("  ScreenshotUrls: ").Append(ScreenshotUrls).Append("\n");
            sb.Append("  State: ").Append(State).Append("\n");
            sb.Append("  SubscriptionsSupportLevel: ").Append(SubscriptionsSupportLevel).Append("\n");
            sb.Append("  Summary: ").Append(Summary).Append("\n");
            sb.Append("  SupportEmail: ").Append(SupportEmail).Append("\n");
            sb.Append("  VarVersion: ").Append(VarVersion).Append("\n");
            sb.Append("  ViewerSummary: ").Append(ViewerSummary).Append("\n");
            sb.Append("  Views: ").Append(Views).Append("\n");
            sb.Append("  AllowlistedConfigUrls: ").Append(AllowlistedConfigUrls).Append("\n");
            sb.Append("  AllowlistedPanelUrls: ").Append(AllowlistedPanelUrls).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="Extension" />
    /// </summary>
    public class ExtensionJsonConverter : JsonConverter<Extension>
    {
        /// <summary>
        /// Deserializes json to <see cref="Extension" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override Extension Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> authorName = default;
            Option<bool?> bitsEnabled = default;
            Option<bool?> canInstall = default;
            Option<Extension.ConfigurationLocationEnum?> configurationLocation = default;
            Option<string?> description = default;
            Option<string?> eulaTosUrl = default;
            Option<bool?> hasChatSupport = default;
            Option<string?> iconUrl = default;
            Option<ExtensionIconUrls?> iconUrls = default;
            Option<string?> id = default;
            Option<string?> name = default;
            Option<string?> privacyPolicyUrl = default;
            Option<bool?> requestIdentityLink = default;
            Option<List<string>?> screenshotUrls = default;
            Option<Extension.StateEnum?> state = default;
            Option<Extension.SubscriptionsSupportLevelEnum?> subscriptionsSupportLevel = default;
            Option<string?> summary = default;
            Option<string?> supportEmail = default;
            Option<string?> varVersion = default;
            Option<string?> viewerSummary = default;
            Option<ExtensionViews?> views = default;
            Option<List<string>?> allowlistedConfigUrls = default;
            Option<List<string>?> allowlistedPanelUrls = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "author_name":
                            authorName = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "bits_enabled":
                            bitsEnabled = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "can_install":
                            canInstall = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "configuration_location":
                            string? configurationLocationRawValue = utf8JsonReader.GetString();
                            if (configurationLocationRawValue != null)
                                configurationLocation = new Option<Extension.ConfigurationLocationEnum?>(Extension.ConfigurationLocationEnumFromStringOrDefault(configurationLocationRawValue));
                            break;
                        case "description":
                            description = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "eula_tos_url":
                            eulaTosUrl = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "has_chat_support":
                            hasChatSupport = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "icon_url":
                            iconUrl = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "icon_urls":
                            iconUrls = new Option<ExtensionIconUrls?>(JsonSerializer.Deserialize<ExtensionIconUrls>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "id":
                            id = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "name":
                            name = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "privacy_policy_url":
                            privacyPolicyUrl = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "request_identity_link":
                            requestIdentityLink = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "screenshot_urls":
                            screenshotUrls = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "state":
                            string? stateRawValue = utf8JsonReader.GetString();
                            if (stateRawValue != null)
                                state = new Option<Extension.StateEnum?>(Extension.StateEnumFromStringOrDefault(stateRawValue));
                            break;
                        case "subscriptions_support_level":
                            string? subscriptionsSupportLevelRawValue = utf8JsonReader.GetString();
                            if (subscriptionsSupportLevelRawValue != null)
                                subscriptionsSupportLevel = new Option<Extension.SubscriptionsSupportLevelEnum?>(Extension.SubscriptionsSupportLevelEnumFromStringOrDefault(subscriptionsSupportLevelRawValue));
                            break;
                        case "summary":
                            summary = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "support_email":
                            supportEmail = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "version":
                            varVersion = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "viewer_summary":
                            viewerSummary = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "views":
                            views = new Option<ExtensionViews?>(JsonSerializer.Deserialize<ExtensionViews>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "allowlisted_config_urls":
                            allowlistedConfigUrls = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "allowlisted_panel_urls":
                            allowlistedPanelUrls = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!authorName.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(authorName));

            if (!bitsEnabled.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(bitsEnabled));

            if (!canInstall.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(canInstall));

            if (!configurationLocation.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(configurationLocation));

            if (!description.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(description));

            if (!eulaTosUrl.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(eulaTosUrl));

            if (!hasChatSupport.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(hasChatSupport));

            if (!iconUrl.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(iconUrl));

            if (!iconUrls.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(iconUrls));

            if (!id.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(id));

            if (!name.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(name));

            if (!privacyPolicyUrl.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(privacyPolicyUrl));

            if (!requestIdentityLink.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(requestIdentityLink));

            if (!screenshotUrls.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(screenshotUrls));

            if (!state.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(state));

            if (!subscriptionsSupportLevel.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(subscriptionsSupportLevel));

            if (!summary.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(summary));

            if (!supportEmail.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(supportEmail));

            if (!varVersion.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(varVersion));

            if (!viewerSummary.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(viewerSummary));

            if (!views.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(views));

            if (!allowlistedConfigUrls.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(allowlistedConfigUrls));

            if (!allowlistedPanelUrls.IsSet)
                throw new ArgumentException("Property is required for class Extension.", nameof(allowlistedPanelUrls));

            if (authorName.IsSet && authorName.Value == null)
                throw new ArgumentNullException(nameof(authorName), "Property is not nullable for class Extension.");

            if (bitsEnabled.IsSet && bitsEnabled.Value == null)
                throw new ArgumentNullException(nameof(bitsEnabled), "Property is not nullable for class Extension.");

            if (canInstall.IsSet && canInstall.Value == null)
                throw new ArgumentNullException(nameof(canInstall), "Property is not nullable for class Extension.");

            if (configurationLocation.IsSet && configurationLocation.Value == null)
                throw new ArgumentNullException(nameof(configurationLocation), "Property is not nullable for class Extension.");

            if (description.IsSet && description.Value == null)
                throw new ArgumentNullException(nameof(description), "Property is not nullable for class Extension.");

            if (eulaTosUrl.IsSet && eulaTosUrl.Value == null)
                throw new ArgumentNullException(nameof(eulaTosUrl), "Property is not nullable for class Extension.");

            if (hasChatSupport.IsSet && hasChatSupport.Value == null)
                throw new ArgumentNullException(nameof(hasChatSupport), "Property is not nullable for class Extension.");

            if (iconUrl.IsSet && iconUrl.Value == null)
                throw new ArgumentNullException(nameof(iconUrl), "Property is not nullable for class Extension.");

            if (iconUrls.IsSet && iconUrls.Value == null)
                throw new ArgumentNullException(nameof(iconUrls), "Property is not nullable for class Extension.");

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class Extension.");

            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name), "Property is not nullable for class Extension.");

            if (privacyPolicyUrl.IsSet && privacyPolicyUrl.Value == null)
                throw new ArgumentNullException(nameof(privacyPolicyUrl), "Property is not nullable for class Extension.");

            if (requestIdentityLink.IsSet && requestIdentityLink.Value == null)
                throw new ArgumentNullException(nameof(requestIdentityLink), "Property is not nullable for class Extension.");

            if (screenshotUrls.IsSet && screenshotUrls.Value == null)
                throw new ArgumentNullException(nameof(screenshotUrls), "Property is not nullable for class Extension.");

            if (state.IsSet && state.Value == null)
                throw new ArgumentNullException(nameof(state), "Property is not nullable for class Extension.");

            if (subscriptionsSupportLevel.IsSet && subscriptionsSupportLevel.Value == null)
                throw new ArgumentNullException(nameof(subscriptionsSupportLevel), "Property is not nullable for class Extension.");

            if (summary.IsSet && summary.Value == null)
                throw new ArgumentNullException(nameof(summary), "Property is not nullable for class Extension.");

            if (supportEmail.IsSet && supportEmail.Value == null)
                throw new ArgumentNullException(nameof(supportEmail), "Property is not nullable for class Extension.");

            if (varVersion.IsSet && varVersion.Value == null)
                throw new ArgumentNullException(nameof(varVersion), "Property is not nullable for class Extension.");

            if (viewerSummary.IsSet && viewerSummary.Value == null)
                throw new ArgumentNullException(nameof(viewerSummary), "Property is not nullable for class Extension.");

            if (views.IsSet && views.Value == null)
                throw new ArgumentNullException(nameof(views), "Property is not nullable for class Extension.");

            if (allowlistedConfigUrls.IsSet && allowlistedConfigUrls.Value == null)
                throw new ArgumentNullException(nameof(allowlistedConfigUrls), "Property is not nullable for class Extension.");

            if (allowlistedPanelUrls.IsSet && allowlistedPanelUrls.Value == null)
                throw new ArgumentNullException(nameof(allowlistedPanelUrls), "Property is not nullable for class Extension.");

            return new Extension(authorName.Value!, bitsEnabled.Value!.Value!, canInstall.Value!.Value!, configurationLocation.Value!.Value!, description.Value!, eulaTosUrl.Value!, hasChatSupport.Value!.Value!, iconUrl.Value!, iconUrls.Value!, id.Value!, name.Value!, privacyPolicyUrl.Value!, requestIdentityLink.Value!.Value!, screenshotUrls.Value!, state.Value!.Value!, subscriptionsSupportLevel.Value!.Value!, summary.Value!, supportEmail.Value!, varVersion.Value!, viewerSummary.Value!, views.Value!, allowlistedConfigUrls.Value!, allowlistedPanelUrls.Value!);
        }

        /// <summary>
        /// Serializes a <see cref="Extension" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="extension"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, Extension extension, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, extension, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="Extension" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="extension"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, Extension extension, JsonSerializerOptions jsonSerializerOptions)
        {
            if (extension.AuthorName == null)
                throw new ArgumentNullException(nameof(extension.AuthorName), "Property is required for class Extension.");

            if (extension.Description == null)
                throw new ArgumentNullException(nameof(extension.Description), "Property is required for class Extension.");

            if (extension.EulaTosUrl == null)
                throw new ArgumentNullException(nameof(extension.EulaTosUrl), "Property is required for class Extension.");

            if (extension.IconUrl == null)
                throw new ArgumentNullException(nameof(extension.IconUrl), "Property is required for class Extension.");

            if (extension.IconUrls == null)
                throw new ArgumentNullException(nameof(extension.IconUrls), "Property is required for class Extension.");

            if (extension.Id == null)
                throw new ArgumentNullException(nameof(extension.Id), "Property is required for class Extension.");

            if (extension.Name == null)
                throw new ArgumentNullException(nameof(extension.Name), "Property is required for class Extension.");

            if (extension.PrivacyPolicyUrl == null)
                throw new ArgumentNullException(nameof(extension.PrivacyPolicyUrl), "Property is required for class Extension.");

            if (extension.ScreenshotUrls == null)
                throw new ArgumentNullException(nameof(extension.ScreenshotUrls), "Property is required for class Extension.");

            if (extension.Summary == null)
                throw new ArgumentNullException(nameof(extension.Summary), "Property is required for class Extension.");

            if (extension.SupportEmail == null)
                throw new ArgumentNullException(nameof(extension.SupportEmail), "Property is required for class Extension.");

            if (extension.VarVersion == null)
                throw new ArgumentNullException(nameof(extension.VarVersion), "Property is required for class Extension.");

            if (extension.ViewerSummary == null)
                throw new ArgumentNullException(nameof(extension.ViewerSummary), "Property is required for class Extension.");

            if (extension.Views == null)
                throw new ArgumentNullException(nameof(extension.Views), "Property is required for class Extension.");

            if (extension.AllowlistedConfigUrls == null)
                throw new ArgumentNullException(nameof(extension.AllowlistedConfigUrls), "Property is required for class Extension.");

            if (extension.AllowlistedPanelUrls == null)
                throw new ArgumentNullException(nameof(extension.AllowlistedPanelUrls), "Property is required for class Extension.");

            writer.WriteString("author_name", extension.AuthorName);

            writer.WriteBoolean("bits_enabled", extension.BitsEnabled);

            writer.WriteBoolean("can_install", extension.CanInstall);

            var configurationLocationRawValue = Extension.ConfigurationLocationEnumToJsonValue(extension.ConfigurationLocation);
            writer.WriteString("configuration_location", configurationLocationRawValue);
            writer.WriteString("description", extension.Description);

            writer.WriteString("eula_tos_url", extension.EulaTosUrl);

            writer.WriteBoolean("has_chat_support", extension.HasChatSupport);

            writer.WriteString("icon_url", extension.IconUrl);

            writer.WritePropertyName("icon_urls");
            JsonSerializer.Serialize(writer, extension.IconUrls, jsonSerializerOptions);
            writer.WriteString("id", extension.Id);

            writer.WriteString("name", extension.Name);

            writer.WriteString("privacy_policy_url", extension.PrivacyPolicyUrl);

            writer.WriteBoolean("request_identity_link", extension.RequestIdentityLink);

            writer.WritePropertyName("screenshot_urls");
            JsonSerializer.Serialize(writer, extension.ScreenshotUrls, jsonSerializerOptions);
            var stateRawValue = Extension.StateEnumToJsonValue(extension.State);
            writer.WriteString("state", stateRawValue);
            var subscriptionsSupportLevelRawValue = Extension.SubscriptionsSupportLevelEnumToJsonValue(extension.SubscriptionsSupportLevel);
            writer.WriteString("subscriptions_support_level", subscriptionsSupportLevelRawValue);
            writer.WriteString("summary", extension.Summary);

            writer.WriteString("support_email", extension.SupportEmail);

            writer.WriteString("version", extension.VarVersion);

            writer.WriteString("viewer_summary", extension.ViewerSummary);

            writer.WritePropertyName("views");
            JsonSerializer.Serialize(writer, extension.Views, jsonSerializerOptions);
            writer.WritePropertyName("allowlisted_config_urls");
            JsonSerializer.Serialize(writer, extension.AllowlistedConfigUrls, jsonSerializerOptions);
            writer.WritePropertyName("allowlisted_panel_urls");
            JsonSerializer.Serialize(writer, extension.AllowlistedPanelUrls, jsonSerializerOptions);
        }
    }
}
