// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;
using TwistedTaleweaver.Integration.Twitch.Helix.Model;
using System.Diagnostics.CodeAnalysis;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IChatApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ChatApiEvents Events { get; }

        /// <summary>
        /// Gets the broadcaster’s list of custom chat badges.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s list of custom chat badges. The list is empty if the broadcaster hasn’t created custom chat badges. For information about custom badges, see [subscriber badges](https://help.twitch.tv/s/article/subscriber-badge-guide) and [Bits badges](https://help.twitch.tv/s/article/custom-bit-badges-guide).  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat badges you want to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelChatBadgesApiResponse"/>&gt;</returns>
        Task<IGetChannelChatBadgesApiResponse> GetChannelChatBadgesAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s list of custom chat badges.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s list of custom chat badges. The list is empty if the broadcaster hasn’t created custom chat badges. For information about custom badges, see [subscriber badges](https://help.twitch.tv/s/article/subscriber-badge-guide) and [Bits badges](https://help.twitch.tv/s/article/custom-bit-badges-guide).  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat badges you want to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelChatBadgesApiResponse"/>?&gt;</returns>
        Task<IGetChannelChatBadgesApiResponse?> GetChannelChatBadgesOrDefaultAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s list of custom emotes.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s list of custom emotes. Broadcasters create these custom emotes for users who subscribe to or follow the channel or cheer Bits in the channel’s chat window. [Learn More](https://dev.twitch.tv/docs/irc/emotes)  For information about the custom emotes, see [subscriber emotes](https://help.twitch.tv/s/article/subscriber-emote-guide), [Bits tier emotes](https://help.twitch.tv/s/article/custom-bit-badges-guide?language&#x3D;bg#slots), and [follower emotes](https://blog.twitch.tv/en/2021/06/04/kicking-off-10-years-with-our-biggest-emote-update-ever/).  **NOTE:** With the exception of custom follower emotes, users may use custom emotes in any Twitch chat.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">An ID that identifies the broadcaster whose emotes you want to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelEmotesApiResponse"/>&gt;</returns>
        Task<IGetChannelEmotesApiResponse> GetChannelEmotesAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s list of custom emotes.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s list of custom emotes. Broadcasters create these custom emotes for users who subscribe to or follow the channel or cheer Bits in the channel’s chat window. [Learn More](https://dev.twitch.tv/docs/irc/emotes)  For information about the custom emotes, see [subscriber emotes](https://help.twitch.tv/s/article/subscriber-emote-guide), [Bits tier emotes](https://help.twitch.tv/s/article/custom-bit-badges-guide?language&#x3D;bg#slots), and [follower emotes](https://blog.twitch.tv/en/2021/06/04/kicking-off-10-years-with-our-biggest-emote-update-ever/).  **NOTE:** With the exception of custom follower emotes, users may use custom emotes in any Twitch chat.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <param name="broadcasterId">An ID that identifies the broadcaster whose emotes you want to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelEmotesApiResponse"/>?&gt;</returns>
        Task<IGetChannelEmotesApiResponse?> GetChannelEmotesOrDefaultAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s chat settings.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s chat settings.  For an overview of chat settings, see [Chat Commands for Broadcasters and Moderators](https://help.twitch.tv/s/article/chat-commands#AllMods) and [Moderator Preferences](https://help.twitch.tv/s/article/setting-up-moderation-for-your-twitch-channel#modpreferences).  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat settings you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or one of the broadcaster’s moderators.      This field is required only if you want to include the &#x60;non_moderator_chat_delay&#x60; and &#x60;non_moderator_chat_delay_duration&#x60; settings in the response.      If you specify this field, this ID must match the user ID in the user access token. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChatSettingsApiResponse"/>&gt;</returns>
        Task<IGetChatSettingsApiResponse> GetChatSettingsAsync(string broadcasterId, Option<string> moderatorId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s chat settings.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s chat settings.  For an overview of chat settings, see [Chat Commands for Broadcasters and Moderators](https://help.twitch.tv/s/article/chat-commands#AllMods) and [Moderator Preferences](https://help.twitch.tv/s/article/setting-up-moderation-for-your-twitch-channel#modpreferences).  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat settings you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or one of the broadcaster’s moderators.      This field is required only if you want to include the &#x60;non_moderator_chat_delay&#x60; and &#x60;non_moderator_chat_delay_duration&#x60; settings in the response.      If you specify this field, this ID must match the user ID in the user access token. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChatSettingsApiResponse"/>?&gt;</returns>
        Task<IGetChatSettingsApiResponse?> GetChatSettingsOrDefaultAsync(string broadcasterId, Option<string> moderatorId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the list of users that are connected to the broadcaster’s chat session.
        /// </summary>
        /// <remarks>
        /// Gets the list of users that are connected to the broadcaster’s chat session.  **NOTE**: There is a delay between when users join and leave a chat and when the list is updated accordingly.  To determine whether a user is a moderator or VIP, use the [Get Moderators](https://dev.twitch.tv/docs/api/reference#get-moderators) and [Get VIPs](https://dev.twitch.tv/docs/api/reference#get-vips) endpoints. You can check the roles of up to 100 users.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:chatters** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of chatters you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or one of the broadcaster’s moderators. This ID must match the user ID in the user access token.</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 1,000\\. The default is 100. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChattersApiResponse"/>&gt;</returns>
        Task<IGetChattersApiResponse> GetChattersAsync(string broadcasterId, string moderatorId, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the list of users that are connected to the broadcaster’s chat session.
        /// </summary>
        /// <remarks>
        /// Gets the list of users that are connected to the broadcaster’s chat session.  **NOTE**: There is a delay between when users join and leave a chat and when the list is updated accordingly.  To determine whether a user is a moderator or VIP, use the [Get Moderators](https://dev.twitch.tv/docs/api/reference#get-moderators) and [Get VIPs](https://dev.twitch.tv/docs/api/reference#get-vips) endpoints. You can check the roles of up to 100 users.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:chatters** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of chatters you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or one of the broadcaster’s moderators. This ID must match the user ID in the user access token.</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 1,000\\. The default is 100. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChattersApiResponse"/>?&gt;</returns>
        Task<IGetChattersApiResponse?> GetChattersOrDefaultAsync(string broadcasterId, string moderatorId, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets emotes for one or more specified emote sets.
        /// </summary>
        /// <remarks>
        /// Gets emotes for one or more specified emote sets.  An emote set groups emotes that have a similar context. For example, Twitch places all the subscriber emotes that a broadcaster uploads for their channel in the same emote set.  [Learn More](https://dev.twitch.tv/docs/irc/emotes)  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emoteSetId">An ID that identifies the emote set to get. Include this parameter for each emote set you want to get. For example, &#x60;emote_set_id&#x3D;1234&amp;emote_set_id&#x3D;5678&#x60;. You may specify a maximum of 25 IDs. The response contains only the IDs that were found and ignores duplicate IDs.      To get emote set IDs, use the [Get Channel Emotes](https://dev.twitch.tv/docs/api/reference#get-channel-emotes) API.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmoteSetsApiResponse"/>&gt;</returns>
        Task<IGetEmoteSetsApiResponse> GetEmoteSetsAsync(List<string> emoteSetId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets emotes for one or more specified emote sets.
        /// </summary>
        /// <remarks>
        /// Gets emotes for one or more specified emote sets.  An emote set groups emotes that have a similar context. For example, Twitch places all the subscriber emotes that a broadcaster uploads for their channel in the same emote set.  [Learn More](https://dev.twitch.tv/docs/irc/emotes)  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <param name="emoteSetId">An ID that identifies the emote set to get. Include this parameter for each emote set you want to get. For example, &#x60;emote_set_id&#x3D;1234&amp;emote_set_id&#x3D;5678&#x60;. You may specify a maximum of 25 IDs. The response contains only the IDs that were found and ignores duplicate IDs.      To get emote set IDs, use the [Get Channel Emotes](https://dev.twitch.tv/docs/api/reference#get-channel-emotes) API.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmoteSetsApiResponse"/>?&gt;</returns>
        Task<IGetEmoteSetsApiResponse?> GetEmoteSetsOrDefaultAsync(List<string> emoteSetId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets Twitch’s list of chat badges.
        /// </summary>
        /// <remarks>
        /// Gets Twitch’s list of chat badges, which users may use in any channel’s chat room. For information about chat badges, see [Twitch Chat Badges Guide](https://help.twitch.tv/s/article/twitch-chat-badges-guide).  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).  __Request Query Parameters:__  None
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGlobalChatBadgesApiResponse"/>&gt;</returns>
        Task<IGetGlobalChatBadgesApiResponse> GetGlobalChatBadgesAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets Twitch’s list of chat badges.
        /// </summary>
        /// <remarks>
        /// Gets Twitch’s list of chat badges, which users may use in any channel’s chat room. For information about chat badges, see [Twitch Chat Badges Guide](https://help.twitch.tv/s/article/twitch-chat-badges-guide).  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).  __Request Query Parameters:__  None
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGlobalChatBadgesApiResponse"/>?&gt;</returns>
        Task<IGetGlobalChatBadgesApiResponse?> GetGlobalChatBadgesOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets all global emotes.
        /// </summary>
        /// <remarks>
        /// Gets the list of [global emotes](https://www.twitch.tv/creatorcamp/en/learn-the-basics/emotes/). Global emotes are Twitch-created emotes that users can use in any Twitch chat.  [Learn More](https://dev.twitch.tv/docs/irc/emotes)  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).  __Request Query Parameters:__  None
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGlobalEmotesApiResponse"/>&gt;</returns>
        Task<IGetGlobalEmotesApiResponse> GetGlobalEmotesAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets all global emotes.
        /// </summary>
        /// <remarks>
        /// Gets the list of [global emotes](https://www.twitch.tv/creatorcamp/en/learn-the-basics/emotes/). Global emotes are Twitch-created emotes that users can use in any Twitch chat.  [Learn More](https://dev.twitch.tv/docs/irc/emotes)  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).  __Request Query Parameters:__  None
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGlobalEmotesApiResponse"/>?&gt;</returns>
        Task<IGetGlobalEmotesApiResponse?> GetGlobalEmotesOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// NEW Retrieves the active shared chat session for a channel.
        /// </summary>
        /// <remarks>
        /// NEW Retrieves the active shared chat session for a channel.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/cli/token-command/#app-access-token) or [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The User ID of the channel broadcaster.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSharedChatSessionApiResponse"/>&gt;</returns>
        Task<IGetSharedChatSessionApiResponse> GetSharedChatSessionAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// NEW Retrieves the active shared chat session for a channel.
        /// </summary>
        /// <remarks>
        /// NEW Retrieves the active shared chat session for a channel.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/cli/token-command/#app-access-token) or [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </remarks>
        /// <param name="broadcasterId">The User ID of the channel broadcaster.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSharedChatSessionApiResponse"/>?&gt;</returns>
        Task<IGetSharedChatSessionApiResponse?> GetSharedChatSessionOrDefaultAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the color used for the user’s name in chat.
        /// </summary>
        /// <remarks>
        /// Gets the color used for the user’s name in chat.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The ID of the user whose username color you want to get. To specify more than one user, include the _user\\_id_ parameter for each user to get. For example, &#x60;&amp;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. The maximum number of IDs that you may specify is 100.      The API ignores duplicate IDs and IDs that weren’t found.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserChatColorApiResponse"/>&gt;</returns>
        Task<IGetUserChatColorApiResponse> GetUserChatColorAsync(List<string> userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the color used for the user’s name in chat.
        /// </summary>
        /// <remarks>
        /// Gets the color used for the user’s name in chat.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <param name="userId">The ID of the user whose username color you want to get. To specify more than one user, include the _user\\_id_ parameter for each user to get. For example, &#x60;&amp;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. The maximum number of IDs that you may specify is 100.      The API ignores duplicate IDs and IDs that weren’t found.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserChatColorApiResponse"/>?&gt;</returns>
        Task<IGetUserChatColorApiResponse?> GetUserChatColorOrDefaultAsync(List<string> userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// NEW Retrieves emotes available to the user across all channels.
        /// </summary>
        /// <remarks>
        /// NEW Retrieves emotes available to the user across all channels.  __Authorization:__  * Requires a user access token that includes the **user:read:emotes** scope. * Query parameter &#x60;user_id&#x60; must match the &#x60;user_id&#x60; in the user access token.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The ID of the user. This ID must match the user ID in the user access token.</param>
        /// <param name="after">The cursor used to get the next page of results. The Pagination object in the response contains the cursor’s value. (optional)</param>
        /// <param name="broadcasterId">The User ID of a broadcaster you wish to get follower emotes of. Using this query parameter will guarantee inclusion of the broadcaster’s follower emotes in the response body.       **Note:** If the user specified in &#x60;user_id&#x60; is subscribed to the broadcaster specified, their follower emotes will appear in the response body regardless if this query parameter is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserEmotesApiResponse"/>&gt;</returns>
        Task<IGetUserEmotesApiResponse> GetUserEmotesAsync(string userId, Option<string> after = default, Option<string> broadcasterId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// NEW Retrieves emotes available to the user across all channels.
        /// </summary>
        /// <remarks>
        /// NEW Retrieves emotes available to the user across all channels.  __Authorization:__  * Requires a user access token that includes the **user:read:emotes** scope. * Query parameter &#x60;user_id&#x60; must match the &#x60;user_id&#x60; in the user access token.
        /// </remarks>
        /// <param name="userId">The ID of the user. This ID must match the user ID in the user access token.</param>
        /// <param name="after">The cursor used to get the next page of results. The Pagination object in the response contains the cursor’s value. (optional)</param>
        /// <param name="broadcasterId">The User ID of a broadcaster you wish to get follower emotes of. Using this query parameter will guarantee inclusion of the broadcaster’s follower emotes in the response body.       **Note:** If the user specified in &#x60;user_id&#x60; is subscribed to the broadcaster specified, their follower emotes will appear in the response body regardless if this query parameter is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserEmotesApiResponse"/>?&gt;</returns>
        Task<IGetUserEmotesApiResponse?> GetUserEmotesOrDefaultAsync(string userId, Option<string> after = default, Option<string> broadcasterId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Sends a Shoutout to the specified broadcaster.
        /// </summary>
        /// <remarks>
        /// Sends a Shoutout to the specified broadcaster. Typically, you send Shoutouts when you or one of your moderators notice another broadcaster in your chat, the other broadcaster is coming up in conversation, or after they raid your broadcast.  Twitch’s Shoutout feature is a great way for you to show support for other broadcasters and help them grow. Viewers who do not follow the other broadcaster will see a pop-up Follow button in your chat that they can click to follow the other broadcaster. [Learn More](https://help.twitch.tv/s/article/shoutouts)  **Rate Limits**: The broadcaster may send a Shoutout once every 2 minutes. They may send the same broadcaster a Shoutout once every 60 minutes.  To receive notifications when a Shoutout is sent or received, subscribe to the [channel.shoutout.create](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutcreate) and [channel.shoutout.receive](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutreceive) subscription types. The **channel.shoutout.create** event includes cooldown periods that indicate when the broadcaster may send another Shoutout without exceeding the endpoint’s rate limit.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shoutouts** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fromBroadcasterId">The ID of the broadcaster that’s sending the Shoutout.</param>
        /// <param name="toBroadcasterId">The ID of the broadcaster that’s receiving the Shoutout.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that is one of the broadcaster’s moderators. This ID must match the user ID in the access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendAShoutoutApiResponse"/>&gt;</returns>
        Task<ISendAShoutoutApiResponse> SendAShoutoutAsync(string fromBroadcasterId, string toBroadcasterId, string moderatorId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Sends a Shoutout to the specified broadcaster.
        /// </summary>
        /// <remarks>
        /// Sends a Shoutout to the specified broadcaster. Typically, you send Shoutouts when you or one of your moderators notice another broadcaster in your chat, the other broadcaster is coming up in conversation, or after they raid your broadcast.  Twitch’s Shoutout feature is a great way for you to show support for other broadcasters and help them grow. Viewers who do not follow the other broadcaster will see a pop-up Follow button in your chat that they can click to follow the other broadcaster. [Learn More](https://help.twitch.tv/s/article/shoutouts)  **Rate Limits**: The broadcaster may send a Shoutout once every 2 minutes. They may send the same broadcaster a Shoutout once every 60 minutes.  To receive notifications when a Shoutout is sent or received, subscribe to the [channel.shoutout.create](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutcreate) and [channel.shoutout.receive](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutreceive) subscription types. The **channel.shoutout.create** event includes cooldown periods that indicate when the broadcaster may send another Shoutout without exceeding the endpoint’s rate limit.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shoutouts** scope.
        /// </remarks>
        /// <param name="fromBroadcasterId">The ID of the broadcaster that’s sending the Shoutout.</param>
        /// <param name="toBroadcasterId">The ID of the broadcaster that’s receiving the Shoutout.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that is one of the broadcaster’s moderators. This ID must match the user ID in the access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendAShoutoutApiResponse"/>?&gt;</returns>
        Task<ISendAShoutoutApiResponse?> SendAShoutoutOrDefaultAsync(string fromBroadcasterId, string toBroadcasterId, string moderatorId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Sends an announcement to the broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// Sends an announcement to the broadcaster’s chat room.  **Rate Limits**: One announcement may be sent every 2 seconds.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:announcements** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room to send the announcement to.</param>
        /// <param name="moderatorId">The ID of a user who has permission to moderate the broadcaster’s chat room, or the broadcaster’s ID if they’re sending the announcement. This ID must match the user ID in the user access token.</param>
        /// <param name="sendChatAnnouncementBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendChatAnnouncementApiResponse"/>&gt;</returns>
        Task<ISendChatAnnouncementApiResponse> SendChatAnnouncementAsync(string broadcasterId, string moderatorId, Option<SendChatAnnouncementBody> sendChatAnnouncementBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Sends an announcement to the broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// Sends an announcement to the broadcaster’s chat room.  **Rate Limits**: One announcement may be sent every 2 seconds.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:announcements** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room to send the announcement to.</param>
        /// <param name="moderatorId">The ID of a user who has permission to moderate the broadcaster’s chat room, or the broadcaster’s ID if they’re sending the announcement. This ID must match the user ID in the user access token.</param>
        /// <param name="sendChatAnnouncementBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendChatAnnouncementApiResponse"/>?&gt;</returns>
        Task<ISendChatAnnouncementApiResponse?> SendChatAnnouncementOrDefaultAsync(string broadcasterId, string moderatorId, Option<SendChatAnnouncementBody> sendChatAnnouncementBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// NEW Sends a message to the broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// NEW Sends a message to the broadcaster’s chat room.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the &#x60;user:write:chat&#x60; scope. If app access token used, then additionally requires &#x60;user:bot&#x60; scope from chatting user, and either &#x60;channel:bot&#x60; scope from broadcaster or moderator status.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendChatMessageBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendChatMessageApiResponse"/>&gt;</returns>
        Task<ISendChatMessageApiResponse> SendChatMessageAsync(Option<SendChatMessageBody> sendChatMessageBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// NEW Sends a message to the broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// NEW Sends a message to the broadcaster’s chat room.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the &#x60;user:write:chat&#x60; scope. If app access token used, then additionally requires &#x60;user:bot&#x60; scope from chatting user, and either &#x60;channel:bot&#x60; scope from broadcaster or moderator status.
        /// </remarks>
        /// <param name="sendChatMessageBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendChatMessageApiResponse"/>?&gt;</returns>
        Task<ISendChatMessageApiResponse?> SendChatMessageOrDefaultAsync(Option<SendChatMessageBody> sendChatMessageBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the broadcaster’s chat settings.
        /// </summary>
        /// <remarks>
        /// Updates the broadcaster’s chat settings.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\\_settings** scope.  __Request Body:__  All fields are optional. Specify only those fields that you want to update.  To set the &#x60;slow_mode_wait_time&#x60; or &#x60;follower_mode_duration&#x60; field to its default value, set the corresponding &#x60;slow_mode&#x60; or &#x60;follower_mode&#x60; field to **true** (and don’t include the &#x60;slow_mode_wait_time&#x60; or &#x60;follower_mode_duration&#x60; field).  To set the &#x60;slow_mode_wait_time&#x60;, &#x60;follower_mode_duration&#x60;, or &#x60;non_moderator_chat_delay_duration&#x60; field’s value, you must set the corresponding &#x60;slow_mode&#x60;, &#x60;follower_mode&#x60;, or &#x60;non_moderator_chat_delay&#x60; field to **true**.  To remove the &#x60;slow_mode_wait_time&#x60;, &#x60;follower_mode_duration&#x60;, or &#x60;non_moderator_chat_delay_duration&#x60; field’s value, set the corresponding &#x60;slow_mode&#x60;, &#x60;follower_mode&#x60;, or &#x60;non_moderator_chat_delay&#x60; field to **false** (and don’t include the &#x60;slow_mode_wait_time&#x60;, &#x60;follower_mode_duration&#x60;, or &#x60;non_moderator_chat_delay_duration&#x60; field).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat settings you want to update.</param>
        /// <param name="moderatorId">The ID of a user that has permission to moderate the broadcaster’s chat room, or the broadcaster’s ID if they’re making the update. This ID must match the user ID in the user access token.</param>
        /// <param name="updateChatSettingsBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateChatSettingsApiResponse"/>&gt;</returns>
        Task<IUpdateChatSettingsApiResponse> UpdateChatSettingsAsync(string broadcasterId, string moderatorId, Option<UpdateChatSettingsBody> updateChatSettingsBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the broadcaster’s chat settings.
        /// </summary>
        /// <remarks>
        /// Updates the broadcaster’s chat settings.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\\_settings** scope.  __Request Body:__  All fields are optional. Specify only those fields that you want to update.  To set the &#x60;slow_mode_wait_time&#x60; or &#x60;follower_mode_duration&#x60; field to its default value, set the corresponding &#x60;slow_mode&#x60; or &#x60;follower_mode&#x60; field to **true** (and don’t include the &#x60;slow_mode_wait_time&#x60; or &#x60;follower_mode_duration&#x60; field).  To set the &#x60;slow_mode_wait_time&#x60;, &#x60;follower_mode_duration&#x60;, or &#x60;non_moderator_chat_delay_duration&#x60; field’s value, you must set the corresponding &#x60;slow_mode&#x60;, &#x60;follower_mode&#x60;, or &#x60;non_moderator_chat_delay&#x60; field to **true**.  To remove the &#x60;slow_mode_wait_time&#x60;, &#x60;follower_mode_duration&#x60;, or &#x60;non_moderator_chat_delay_duration&#x60; field’s value, set the corresponding &#x60;slow_mode&#x60;, &#x60;follower_mode&#x60;, or &#x60;non_moderator_chat_delay&#x60; field to **false** (and don’t include the &#x60;slow_mode_wait_time&#x60;, &#x60;follower_mode_duration&#x60;, or &#x60;non_moderator_chat_delay_duration&#x60; field).
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat settings you want to update.</param>
        /// <param name="moderatorId">The ID of a user that has permission to moderate the broadcaster’s chat room, or the broadcaster’s ID if they’re making the update. This ID must match the user ID in the user access token.</param>
        /// <param name="updateChatSettingsBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateChatSettingsApiResponse"/>?&gt;</returns>
        Task<IUpdateChatSettingsApiResponse?> UpdateChatSettingsOrDefaultAsync(string broadcasterId, string moderatorId, Option<UpdateChatSettingsBody> updateChatSettingsBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the color used for the user’s name in chat.
        /// </summary>
        /// <remarks>
        /// Updates the color used for the user’s name in chat.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:chat\\_color** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The ID of the user whose chat color you want to update. This ID must match the user ID in the access token.</param>
        /// <param name="color">The color to use for the user&#39;s name in chat. All users may specify one of the following named color values.      * blue * blue\\_violet * cadet\\_blue * chocolate * coral * dodger\\_blue * firebrick * golden\\_rod * green * hot\\_pink * orange\\_red * red * sea\\_green * spring\\_green * yellow\\_green    Turbo and Prime users may specify a named color or a Hex color code like #9146FF. If you use a Hex color code, remember to URL encode it.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateUserChatColorApiResponse"/>&gt;</returns>
        Task<IUpdateUserChatColorApiResponse> UpdateUserChatColorAsync(string userId, string color, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the color used for the user’s name in chat.
        /// </summary>
        /// <remarks>
        /// Updates the color used for the user’s name in chat.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:chat\\_color** scope.
        /// </remarks>
        /// <param name="userId">The ID of the user whose chat color you want to update. This ID must match the user ID in the access token.</param>
        /// <param name="color">The color to use for the user&#39;s name in chat. All users may specify one of the following named color values.      * blue * blue\\_violet * cadet\\_blue * chocolate * coral * dodger\\_blue * firebrick * golden\\_rod * green * hot\\_pink * orange\\_red * red * sea\\_green * spring\\_green * yellow\\_green    Turbo and Prime users may specify a named color or a Hex color code like #9146FF. If you use a Hex color code, remember to URL encode it.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateUserChatColorApiResponse"/>?&gt;</returns>
        Task<IUpdateUserChatColorApiResponse?> UpdateUserChatColorOrDefaultAsync(string userId, string color, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGetChannelChatBadgesApiResponse"/>
    /// </summary>
    public interface IGetChannelChatBadgesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChannelChatBadgesResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetChannelEmotesApiResponse"/>
    /// </summary>
    public interface IGetChannelEmotesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChannelEmotesResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetChatSettingsApiResponse"/>
    /// </summary>
    public interface IGetChatSettingsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChatSettingsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetChattersApiResponse"/>
    /// </summary>
    public interface IGetChattersApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChattersResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmoteSetsApiResponse"/>
    /// </summary>
    public interface IGetEmoteSetsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetEmoteSetsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetGlobalChatBadgesApiResponse"/>
    /// </summary>
    public interface IGetGlobalChatBadgesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetGlobalChatBadgesResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetGlobalEmotesApiResponse"/>
    /// </summary>
    public interface IGetGlobalEmotesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetGlobalEmotesResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetSharedChatSessionApiResponse"/>
    /// </summary>
    public interface IGetSharedChatSessionApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetSharedChatSessionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetUserChatColorApiResponse"/>
    /// </summary>
    public interface IGetUserChatColorApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetUserChatColorResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetUserEmotesApiResponse"/>
    /// </summary>
    public interface IGetUserEmotesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetUserEmotesResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="ISendAShoutoutApiResponse"/>
    /// </summary>
    public interface ISendAShoutoutApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="ISendChatAnnouncementApiResponse"/>
    /// </summary>
    public interface ISendChatAnnouncementApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="ISendChatMessageApiResponse"/>
    /// </summary>
    public interface ISendChatMessageApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.SendChatMessageResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateChatSettingsApiResponse"/>
    /// </summary>
    public interface IUpdateChatSettingsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateChatSettingsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateUserChatColorApiResponse"/>
    /// </summary>
    public interface IUpdateUserChatColorApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ChatApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetChannelChatBadges;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetChannelChatBadges;

        internal void ExecuteOnGetChannelChatBadges(ChatApi.GetChannelChatBadgesApiResponse apiResponse)
        {
            OnGetChannelChatBadges?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetChannelChatBadges(Exception exception)
        {
            OnErrorGetChannelChatBadges?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetChannelEmotes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetChannelEmotes;

        internal void ExecuteOnGetChannelEmotes(ChatApi.GetChannelEmotesApiResponse apiResponse)
        {
            OnGetChannelEmotes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetChannelEmotes(Exception exception)
        {
            OnErrorGetChannelEmotes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetChatSettings;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetChatSettings;

        internal void ExecuteOnGetChatSettings(ChatApi.GetChatSettingsApiResponse apiResponse)
        {
            OnGetChatSettings?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetChatSettings(Exception exception)
        {
            OnErrorGetChatSettings?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetChatters;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetChatters;

        internal void ExecuteOnGetChatters(ChatApi.GetChattersApiResponse apiResponse)
        {
            OnGetChatters?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetChatters(Exception exception)
        {
            OnErrorGetChatters?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetEmoteSets;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetEmoteSets;

        internal void ExecuteOnGetEmoteSets(ChatApi.GetEmoteSetsApiResponse apiResponse)
        {
            OnGetEmoteSets?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmoteSets(Exception exception)
        {
            OnErrorGetEmoteSets?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetGlobalChatBadges;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetGlobalChatBadges;

        internal void ExecuteOnGetGlobalChatBadges(ChatApi.GetGlobalChatBadgesApiResponse apiResponse)
        {
            OnGetGlobalChatBadges?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetGlobalChatBadges(Exception exception)
        {
            OnErrorGetGlobalChatBadges?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetGlobalEmotes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetGlobalEmotes;

        internal void ExecuteOnGetGlobalEmotes(ChatApi.GetGlobalEmotesApiResponse apiResponse)
        {
            OnGetGlobalEmotes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetGlobalEmotes(Exception exception)
        {
            OnErrorGetGlobalEmotes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSharedChatSession;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSharedChatSession;

        internal void ExecuteOnGetSharedChatSession(ChatApi.GetSharedChatSessionApiResponse apiResponse)
        {
            OnGetSharedChatSession?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSharedChatSession(Exception exception)
        {
            OnErrorGetSharedChatSession?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetUserChatColor;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetUserChatColor;

        internal void ExecuteOnGetUserChatColor(ChatApi.GetUserChatColorApiResponse apiResponse)
        {
            OnGetUserChatColor?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetUserChatColor(Exception exception)
        {
            OnErrorGetUserChatColor?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetUserEmotes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetUserEmotes;

        internal void ExecuteOnGetUserEmotes(ChatApi.GetUserEmotesApiResponse apiResponse)
        {
            OnGetUserEmotes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetUserEmotes(Exception exception)
        {
            OnErrorGetUserEmotes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSendAShoutout;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSendAShoutout;

        internal void ExecuteOnSendAShoutout(ChatApi.SendAShoutoutApiResponse apiResponse)
        {
            OnSendAShoutout?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendAShoutout(Exception exception)
        {
            OnErrorSendAShoutout?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSendChatAnnouncement;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSendChatAnnouncement;

        internal void ExecuteOnSendChatAnnouncement(ChatApi.SendChatAnnouncementApiResponse apiResponse)
        {
            OnSendChatAnnouncement?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendChatAnnouncement(Exception exception)
        {
            OnErrorSendChatAnnouncement?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSendChatMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSendChatMessage;

        internal void ExecuteOnSendChatMessage(ChatApi.SendChatMessageApiResponse apiResponse)
        {
            OnSendChatMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendChatMessage(Exception exception)
        {
            OnErrorSendChatMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateChatSettings;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateChatSettings;

        internal void ExecuteOnUpdateChatSettings(ChatApi.UpdateChatSettingsApiResponse apiResponse)
        {
            OnUpdateChatSettings?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateChatSettings(Exception exception)
        {
            OnErrorUpdateChatSettings?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateUserChatColor;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateUserChatColor;

        internal void ExecuteOnUpdateUserChatColor(ChatApi.UpdateUserChatColorApiResponse apiResponse)
        {
            OnUpdateUserChatColor?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateUserChatColor(Exception exception)
        {
            OnErrorUpdateUserChatColor?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ChatApi : IChatApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ChatApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ChatApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ChatApi(ILogger<ChatApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ChatApiEvents chatApiEvents,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ChatApi>();
            HttpClient = httpClient;
            Events = chatApiEvents;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatGetChannelChatBadges(ref string broadcasterId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <returns></returns>
        private void ValidateGetChannelChatBadges(string broadcasterId)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        private void AfterGetChannelChatBadgesDefaultImplementation(IGetChannelChatBadgesApiResponse apiResponseLocalVar, string broadcasterId)
        {
            bool suppressDefaultLog = false;
            AfterGetChannelChatBadges(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        partial void AfterGetChannelChatBadges(ref bool suppressDefaultLog, IGetChannelChatBadgesApiResponse apiResponseLocalVar, string broadcasterId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        private void OnErrorGetChannelChatBadgesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetChannelChatBadges(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        partial void OnErrorGetChannelChatBadges(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId);

        /// <summary>
        /// Gets the broadcaster’s list of custom chat badges. Gets the broadcaster’s list of custom chat badges. The list is empty if the broadcaster hasn’t created custom chat badges. For information about custom badges, see [subscriber badges](https://help.twitch.tv/s/article/subscriber-badge-guide) and [Bits badges](https://help.twitch.tv/s/article/custom-bit-badges-guide).  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat badges you want to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelChatBadgesApiResponse"/>&gt;</returns>
        public async Task<IGetChannelChatBadgesApiResponse?> GetChannelChatBadgesOrDefaultAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetChannelChatBadgesAsync(broadcasterId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the broadcaster’s list of custom chat badges. Gets the broadcaster’s list of custom chat badges. The list is empty if the broadcaster hasn’t created custom chat badges. For information about custom badges, see [subscriber badges](https://help.twitch.tv/s/article/subscriber-badge-guide) and [Bits badges](https://help.twitch.tv/s/article/custom-bit-badges-guide).  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat badges you want to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelChatBadgesApiResponse"/>&gt;</returns>
        public async Task<IGetChannelChatBadgesApiResponse> GetChannelChatBadgesAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetChannelChatBadges(broadcasterId);

                FormatGetChannelChatBadges(ref broadcasterId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/badges"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/badges");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetChannelChatBadgesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetChannelChatBadgesApiResponse>();

                        GetChannelChatBadgesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/badges", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetChannelChatBadgesDefaultImplementation(apiResponseLocalVar, broadcasterId);

                        Events.ExecuteOnGetChannelChatBadges(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetChannelChatBadgesDefaultImplementation(e, "/chat/badges", uriBuilderLocalVar.Path, broadcasterId);
                Events.ExecuteOnErrorGetChannelChatBadges(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetChannelChatBadgesApiResponse"/>
        /// </summary>
        public partial class GetChannelChatBadgesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetChannelChatBadgesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetChannelChatBadgesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetChannelChatBadgesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetChannelChatBadgesApiResponse(ILogger<GetChannelChatBadgesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChannelChatBadgesResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChannelChatBadgesResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChannelChatBadgesResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetChannelEmotes(ref string broadcasterId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <returns></returns>
        private void ValidateGetChannelEmotes(string broadcasterId)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        private void AfterGetChannelEmotesDefaultImplementation(IGetChannelEmotesApiResponse apiResponseLocalVar, string broadcasterId)
        {
            bool suppressDefaultLog = false;
            AfterGetChannelEmotes(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        partial void AfterGetChannelEmotes(ref bool suppressDefaultLog, IGetChannelEmotesApiResponse apiResponseLocalVar, string broadcasterId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        private void OnErrorGetChannelEmotesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetChannelEmotes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        partial void OnErrorGetChannelEmotes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId);

        /// <summary>
        /// Gets the broadcaster’s list of custom emotes. Gets the broadcaster’s list of custom emotes. Broadcasters create these custom emotes for users who subscribe to or follow the channel or cheer Bits in the channel’s chat window. [Learn More](https://dev.twitch.tv/docs/irc/emotes)  For information about the custom emotes, see [subscriber emotes](https://help.twitch.tv/s/article/subscriber-emote-guide), [Bits tier emotes](https://help.twitch.tv/s/article/custom-bit-badges-guide?language&#x3D;bg#slots), and [follower emotes](https://blog.twitch.tv/en/2021/06/04/kicking-off-10-years-with-our-biggest-emote-update-ever/).  **NOTE:** With the exception of custom follower emotes, users may use custom emotes in any Twitch chat.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <param name="broadcasterId">An ID that identifies the broadcaster whose emotes you want to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelEmotesApiResponse"/>&gt;</returns>
        public async Task<IGetChannelEmotesApiResponse?> GetChannelEmotesOrDefaultAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetChannelEmotesAsync(broadcasterId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the broadcaster’s list of custom emotes. Gets the broadcaster’s list of custom emotes. Broadcasters create these custom emotes for users who subscribe to or follow the channel or cheer Bits in the channel’s chat window. [Learn More](https://dev.twitch.tv/docs/irc/emotes)  For information about the custom emotes, see [subscriber emotes](https://help.twitch.tv/s/article/subscriber-emote-guide), [Bits tier emotes](https://help.twitch.tv/s/article/custom-bit-badges-guide?language&#x3D;bg#slots), and [follower emotes](https://blog.twitch.tv/en/2021/06/04/kicking-off-10-years-with-our-biggest-emote-update-ever/).  **NOTE:** With the exception of custom follower emotes, users may use custom emotes in any Twitch chat.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">An ID that identifies the broadcaster whose emotes you want to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelEmotesApiResponse"/>&gt;</returns>
        public async Task<IGetChannelEmotesApiResponse> GetChannelEmotesAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetChannelEmotes(broadcasterId);

                FormatGetChannelEmotes(ref broadcasterId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/emotes"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/emotes");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetChannelEmotesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetChannelEmotesApiResponse>();

                        GetChannelEmotesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/emotes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetChannelEmotesDefaultImplementation(apiResponseLocalVar, broadcasterId);

                        Events.ExecuteOnGetChannelEmotes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetChannelEmotesDefaultImplementation(e, "/chat/emotes", uriBuilderLocalVar.Path, broadcasterId);
                Events.ExecuteOnErrorGetChannelEmotes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetChannelEmotesApiResponse"/>
        /// </summary>
        public partial class GetChannelEmotesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetChannelEmotesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetChannelEmotesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetChannelEmotesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetChannelEmotesApiResponse(ILogger<GetChannelEmotesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChannelEmotesResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChannelEmotesResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChannelEmotesResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetChatSettings(ref string broadcasterId, ref Option<string> moderatorId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <returns></returns>
        private void ValidateGetChatSettings(string broadcasterId, Option<string> moderatorId)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId.IsSet && moderatorId.Value == null)
                throw new ArgumentNullException(nameof(moderatorId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        private void AfterGetChatSettingsDefaultImplementation(IGetChatSettingsApiResponse apiResponseLocalVar, string broadcasterId, Option<string> moderatorId)
        {
            bool suppressDefaultLog = false;
            AfterGetChatSettings(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        partial void AfterGetChatSettings(ref bool suppressDefaultLog, IGetChatSettingsApiResponse apiResponseLocalVar, string broadcasterId, Option<string> moderatorId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        private void OnErrorGetChatSettingsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<string> moderatorId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetChatSettings(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        partial void OnErrorGetChatSettings(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<string> moderatorId);

        /// <summary>
        /// Gets the broadcaster’s chat settings. Gets the broadcaster’s chat settings.  For an overview of chat settings, see [Chat Commands for Broadcasters and Moderators](https://help.twitch.tv/s/article/chat-commands#AllMods) and [Moderator Preferences](https://help.twitch.tv/s/article/setting-up-moderation-for-your-twitch-channel#modpreferences).  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat settings you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or one of the broadcaster’s moderators.      This field is required only if you want to include the &#x60;non_moderator_chat_delay&#x60; and &#x60;non_moderator_chat_delay_duration&#x60; settings in the response.      If you specify this field, this ID must match the user ID in the user access token. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChatSettingsApiResponse"/>&gt;</returns>
        public async Task<IGetChatSettingsApiResponse?> GetChatSettingsOrDefaultAsync(string broadcasterId, Option<string> moderatorId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetChatSettingsAsync(broadcasterId, moderatorId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the broadcaster’s chat settings. Gets the broadcaster’s chat settings.  For an overview of chat settings, see [Chat Commands for Broadcasters and Moderators](https://help.twitch.tv/s/article/chat-commands#AllMods) and [Moderator Preferences](https://help.twitch.tv/s/article/setting-up-moderation-for-your-twitch-channel#modpreferences).  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat settings you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or one of the broadcaster’s moderators.      This field is required only if you want to include the &#x60;non_moderator_chat_delay&#x60; and &#x60;non_moderator_chat_delay_duration&#x60; settings in the response.      If you specify this field, this ID must match the user ID in the user access token. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChatSettingsApiResponse"/>&gt;</returns>
        public async Task<IGetChatSettingsApiResponse> GetChatSettingsAsync(string broadcasterId, Option<string> moderatorId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetChatSettings(broadcasterId, moderatorId);

                FormatGetChatSettings(ref broadcasterId, ref moderatorId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/settings"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/settings");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    if (moderatorId.IsSet)
                        parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetChatSettingsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetChatSettingsApiResponse>();

                        GetChatSettingsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/settings", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetChatSettingsDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId);

                        Events.ExecuteOnGetChatSettings(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetChatSettingsDefaultImplementation(e, "/chat/settings", uriBuilderLocalVar.Path, broadcasterId, moderatorId);
                Events.ExecuteOnErrorGetChatSettings(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetChatSettingsApiResponse"/>
        /// </summary>
        public partial class GetChatSettingsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetChatSettingsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetChatSettingsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetChatSettingsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetChatSettingsApiResponse(ILogger<GetChatSettingsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChatSettingsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChatSettingsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChatSettingsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetChatters(ref string broadcasterId, ref string moderatorId, ref Option<int> first, ref Option<string> after);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetChatters(string broadcasterId, string moderatorId, Option<string> after)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void AfterGetChattersDefaultImplementation(IGetChattersApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLog = false;
            AfterGetChatters(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, first, after);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void AfterGetChatters(ref bool suppressDefaultLog, IGetChattersApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<int> first, Option<string> after);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void OnErrorGetChattersDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetChatters(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, first, after);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void OnErrorGetChatters(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<int> first, Option<string> after);

        /// <summary>
        /// Gets the list of users that are connected to the broadcaster’s chat session. Gets the list of users that are connected to the broadcaster’s chat session.  **NOTE**: There is a delay between when users join and leave a chat and when the list is updated accordingly.  To determine whether a user is a moderator or VIP, use the [Get Moderators](https://dev.twitch.tv/docs/api/reference#get-moderators) and [Get VIPs](https://dev.twitch.tv/docs/api/reference#get-vips) endpoints. You can check the roles of up to 100 users.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:chatters** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of chatters you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or one of the broadcaster’s moderators. This ID must match the user ID in the user access token.</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 1,000\\. The default is 100. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChattersApiResponse"/>&gt;</returns>
        public async Task<IGetChattersApiResponse?> GetChattersOrDefaultAsync(string broadcasterId, string moderatorId, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetChattersAsync(broadcasterId, moderatorId, first, after, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the list of users that are connected to the broadcaster’s chat session. Gets the list of users that are connected to the broadcaster’s chat session.  **NOTE**: There is a delay between when users join and leave a chat and when the list is updated accordingly.  To determine whether a user is a moderator or VIP, use the [Get Moderators](https://dev.twitch.tv/docs/api/reference#get-moderators) and [Get VIPs](https://dev.twitch.tv/docs/api/reference#get-vips) endpoints. You can check the roles of up to 100 users.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:chatters** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of chatters you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or one of the broadcaster’s moderators. This ID must match the user ID in the user access token.</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 1,000\\. The default is 100. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChattersApiResponse"/>&gt;</returns>
        public async Task<IGetChattersApiResponse> GetChattersAsync(string broadcasterId, string moderatorId, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetChatters(broadcasterId, moderatorId, after);

                FormatGetChatters(ref broadcasterId, ref moderatorId, ref first, ref after);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/chatters"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/chatters");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetChattersApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetChattersApiResponse>();

                        GetChattersApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/chatters", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetChattersDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, first, after);

                        Events.ExecuteOnGetChatters(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetChattersDefaultImplementation(e, "/chat/chatters", uriBuilderLocalVar.Path, broadcasterId, moderatorId, first, after);
                Events.ExecuteOnErrorGetChatters(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetChattersApiResponse"/>
        /// </summary>
        public partial class GetChattersApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetChattersApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetChattersApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetChattersApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetChattersApiResponse(ILogger<GetChattersApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChattersResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChattersResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChattersResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmoteSets(List<string> emoteSetId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="emoteSetId"></param>
        /// <returns></returns>
        private void ValidateGetEmoteSets(List<string> emoteSetId)
        {
            if (emoteSetId == null)
                throw new ArgumentNullException(nameof(emoteSetId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emoteSetId"></param>
        private void AfterGetEmoteSetsDefaultImplementation(IGetEmoteSetsApiResponse apiResponseLocalVar, List<string> emoteSetId)
        {
            bool suppressDefaultLog = false;
            AfterGetEmoteSets(ref suppressDefaultLog, apiResponseLocalVar, emoteSetId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="emoteSetId"></param>
        partial void AfterGetEmoteSets(ref bool suppressDefaultLog, IGetEmoteSetsApiResponse apiResponseLocalVar, List<string> emoteSetId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emoteSetId"></param>
        private void OnErrorGetEmoteSetsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> emoteSetId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmoteSets(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, emoteSetId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="emoteSetId"></param>
        partial void OnErrorGetEmoteSets(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> emoteSetId);

        /// <summary>
        /// Gets emotes for one or more specified emote sets. Gets emotes for one or more specified emote sets.  An emote set groups emotes that have a similar context. For example, Twitch places all the subscriber emotes that a broadcaster uploads for their channel in the same emote set.  [Learn More](https://dev.twitch.tv/docs/irc/emotes)  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <param name="emoteSetId">An ID that identifies the emote set to get. Include this parameter for each emote set you want to get. For example, &#x60;emote_set_id&#x3D;1234&amp;emote_set_id&#x3D;5678&#x60;. You may specify a maximum of 25 IDs. The response contains only the IDs that were found and ignores duplicate IDs.      To get emote set IDs, use the [Get Channel Emotes](https://dev.twitch.tv/docs/api/reference#get-channel-emotes) API.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmoteSetsApiResponse"/>&gt;</returns>
        public async Task<IGetEmoteSetsApiResponse?> GetEmoteSetsOrDefaultAsync(List<string> emoteSetId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmoteSetsAsync(emoteSetId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets emotes for one or more specified emote sets. Gets emotes for one or more specified emote sets.  An emote set groups emotes that have a similar context. For example, Twitch places all the subscriber emotes that a broadcaster uploads for their channel in the same emote set.  [Learn More](https://dev.twitch.tv/docs/irc/emotes)  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="emoteSetId">An ID that identifies the emote set to get. Include this parameter for each emote set you want to get. For example, &#x60;emote_set_id&#x3D;1234&amp;emote_set_id&#x3D;5678&#x60;. You may specify a maximum of 25 IDs. The response contains only the IDs that were found and ignores duplicate IDs.      To get emote set IDs, use the [Get Channel Emotes](https://dev.twitch.tv/docs/api/reference#get-channel-emotes) API.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmoteSetsApiResponse"/>&gt;</returns>
        public async Task<IGetEmoteSetsApiResponse> GetEmoteSetsAsync(List<string> emoteSetId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmoteSets(emoteSetId);

                FormatGetEmoteSets(emoteSetId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/emotes/set"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/emotes/set");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["emote_set_id"] = ClientUtils.ParameterToString(emoteSetId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetEmoteSetsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmoteSetsApiResponse>();

                        GetEmoteSetsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/emotes/set", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEmoteSetsDefaultImplementation(apiResponseLocalVar, emoteSetId);

                        Events.ExecuteOnGetEmoteSets(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmoteSetsDefaultImplementation(e, "/chat/emotes/set", uriBuilderLocalVar.Path, emoteSetId);
                Events.ExecuteOnErrorGetEmoteSets(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmoteSetsApiResponse"/>
        /// </summary>
        public partial class GetEmoteSetsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetEmoteSetsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmoteSetsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmoteSetsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmoteSetsApiResponse(ILogger<GetEmoteSetsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetEmoteSetsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetEmoteSetsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetEmoteSetsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetGlobalChatBadgesDefaultImplementation(IGetGlobalChatBadgesApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetGlobalChatBadges(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetGlobalChatBadges(ref bool suppressDefaultLog, IGetGlobalChatBadgesApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetGlobalChatBadgesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetGlobalChatBadges(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetGlobalChatBadges(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Gets Twitch’s list of chat badges. Gets Twitch’s list of chat badges, which users may use in any channel’s chat room. For information about chat badges, see [Twitch Chat Badges Guide](https://help.twitch.tv/s/article/twitch-chat-badges-guide).  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).  __Request Query Parameters:__  None
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGlobalChatBadgesApiResponse"/>&gt;</returns>
        public async Task<IGetGlobalChatBadgesApiResponse?> GetGlobalChatBadgesOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetGlobalChatBadgesAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets Twitch’s list of chat badges. Gets Twitch’s list of chat badges, which users may use in any channel’s chat room. For information about chat badges, see [Twitch Chat Badges Guide](https://help.twitch.tv/s/article/twitch-chat-badges-guide).  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).  __Request Query Parameters:__  None
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGlobalChatBadgesApiResponse"/>&gt;</returns>
        public async Task<IGetGlobalChatBadgesApiResponse> GetGlobalChatBadgesAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/badges/global"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/badges/global");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetGlobalChatBadgesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetGlobalChatBadgesApiResponse>();

                        GetGlobalChatBadgesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/badges/global", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetGlobalChatBadgesDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetGlobalChatBadges(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetGlobalChatBadgesDefaultImplementation(e, "/chat/badges/global", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetGlobalChatBadges(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetGlobalChatBadgesApiResponse"/>
        /// </summary>
        public partial class GetGlobalChatBadgesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetGlobalChatBadgesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetGlobalChatBadgesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetGlobalChatBadgesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetGlobalChatBadgesApiResponse(ILogger<GetGlobalChatBadgesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetGlobalChatBadgesResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetGlobalChatBadgesResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetGlobalChatBadgesResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetGlobalEmotesDefaultImplementation(IGetGlobalEmotesApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetGlobalEmotes(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetGlobalEmotes(ref bool suppressDefaultLog, IGetGlobalEmotesApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetGlobalEmotesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetGlobalEmotes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetGlobalEmotes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Gets all global emotes. Gets the list of [global emotes](https://www.twitch.tv/creatorcamp/en/learn-the-basics/emotes/). Global emotes are Twitch-created emotes that users can use in any Twitch chat.  [Learn More](https://dev.twitch.tv/docs/irc/emotes)  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).  __Request Query Parameters:__  None
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGlobalEmotesApiResponse"/>&gt;</returns>
        public async Task<IGetGlobalEmotesApiResponse?> GetGlobalEmotesOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetGlobalEmotesAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets all global emotes. Gets the list of [global emotes](https://www.twitch.tv/creatorcamp/en/learn-the-basics/emotes/). Global emotes are Twitch-created emotes that users can use in any Twitch chat.  [Learn More](https://dev.twitch.tv/docs/irc/emotes)  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).  __Request Query Parameters:__  None
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGlobalEmotesApiResponse"/>&gt;</returns>
        public async Task<IGetGlobalEmotesApiResponse> GetGlobalEmotesAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/emotes/global"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/emotes/global");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetGlobalEmotesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetGlobalEmotesApiResponse>();

                        GetGlobalEmotesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/emotes/global", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetGlobalEmotesDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetGlobalEmotes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetGlobalEmotesDefaultImplementation(e, "/chat/emotes/global", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetGlobalEmotes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetGlobalEmotesApiResponse"/>
        /// </summary>
        public partial class GetGlobalEmotesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetGlobalEmotesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetGlobalEmotesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetGlobalEmotesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetGlobalEmotesApiResponse(ILogger<GetGlobalEmotesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetGlobalEmotesResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetGlobalEmotesResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetGlobalEmotesResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSharedChatSession(ref string broadcasterId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <returns></returns>
        private void ValidateGetSharedChatSession(string broadcasterId)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        private void AfterGetSharedChatSessionDefaultImplementation(IGetSharedChatSessionApiResponse apiResponseLocalVar, string broadcasterId)
        {
            bool suppressDefaultLog = false;
            AfterGetSharedChatSession(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        partial void AfterGetSharedChatSession(ref bool suppressDefaultLog, IGetSharedChatSessionApiResponse apiResponseLocalVar, string broadcasterId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        private void OnErrorGetSharedChatSessionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSharedChatSession(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        partial void OnErrorGetSharedChatSession(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId);

        /// <summary>
        /// NEW Retrieves the active shared chat session for a channel. NEW Retrieves the active shared chat session for a channel.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/cli/token-command/#app-access-token) or [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </summary>
        /// <param name="broadcasterId">The User ID of the channel broadcaster.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSharedChatSessionApiResponse"/>&gt;</returns>
        public async Task<IGetSharedChatSessionApiResponse?> GetSharedChatSessionOrDefaultAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSharedChatSessionAsync(broadcasterId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// NEW Retrieves the active shared chat session for a channel. NEW Retrieves the active shared chat session for a channel.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/cli/token-command/#app-access-token) or [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The User ID of the channel broadcaster.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSharedChatSessionApiResponse"/>&gt;</returns>
        public async Task<IGetSharedChatSessionApiResponse> GetSharedChatSessionAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSharedChatSession(broadcasterId);

                FormatGetSharedChatSession(ref broadcasterId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/shared_chat/session"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/shared_chat/session");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetSharedChatSessionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSharedChatSessionApiResponse>();

                        GetSharedChatSessionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/shared_chat/session", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetSharedChatSessionDefaultImplementation(apiResponseLocalVar, broadcasterId);

                        Events.ExecuteOnGetSharedChatSession(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSharedChatSessionDefaultImplementation(e, "/shared_chat/session", uriBuilderLocalVar.Path, broadcasterId);
                Events.ExecuteOnErrorGetSharedChatSession(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSharedChatSessionApiResponse"/>
        /// </summary>
        public partial class GetSharedChatSessionApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetSharedChatSessionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSharedChatSessionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSharedChatSessionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSharedChatSessionApiResponse(ILogger<GetSharedChatSessionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetSharedChatSessionResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetSharedChatSessionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetSharedChatSessionResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetUserChatColor(List<string> userId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="userId"></param>
        /// <returns></returns>
        private void ValidateGetUserChatColor(List<string> userId)
        {
            if (userId == null)
                throw new ArgumentNullException(nameof(userId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        private void AfterGetUserChatColorDefaultImplementation(IGetUserChatColorApiResponse apiResponseLocalVar, List<string> userId)
        {
            bool suppressDefaultLog = false;
            AfterGetUserChatColor(ref suppressDefaultLog, apiResponseLocalVar, userId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        partial void AfterGetUserChatColor(ref bool suppressDefaultLog, IGetUserChatColorApiResponse apiResponseLocalVar, List<string> userId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userId"></param>
        private void OnErrorGetUserChatColorDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> userId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetUserChatColor(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, userId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userId"></param>
        partial void OnErrorGetUserChatColor(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> userId);

        /// <summary>
        /// Gets the color used for the user’s name in chat. Gets the color used for the user’s name in chat.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <param name="userId">The ID of the user whose username color you want to get. To specify more than one user, include the _user\\_id_ parameter for each user to get. For example, &#x60;&amp;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. The maximum number of IDs that you may specify is 100.      The API ignores duplicate IDs and IDs that weren’t found.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserChatColorApiResponse"/>&gt;</returns>
        public async Task<IGetUserChatColorApiResponse?> GetUserChatColorOrDefaultAsync(List<string> userId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetUserChatColorAsync(userId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the color used for the user’s name in chat. Gets the color used for the user’s name in chat.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The ID of the user whose username color you want to get. To specify more than one user, include the _user\\_id_ parameter for each user to get. For example, &#x60;&amp;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. The maximum number of IDs that you may specify is 100.      The API ignores duplicate IDs and IDs that weren’t found.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserChatColorApiResponse"/>&gt;</returns>
        public async Task<IGetUserChatColorApiResponse> GetUserChatColorAsync(List<string> userId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetUserChatColor(userId);

                FormatGetUserChatColor(userId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/color"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/color");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetUserChatColorApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetUserChatColorApiResponse>();

                        GetUserChatColorApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/color", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetUserChatColorDefaultImplementation(apiResponseLocalVar, userId);

                        Events.ExecuteOnGetUserChatColor(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetUserChatColorDefaultImplementation(e, "/chat/color", uriBuilderLocalVar.Path, userId);
                Events.ExecuteOnErrorGetUserChatColor(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetUserChatColorApiResponse"/>
        /// </summary>
        public partial class GetUserChatColorApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetUserChatColorApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetUserChatColorApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetUserChatColorApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetUserChatColorApiResponse(ILogger<GetUserChatColorApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetUserChatColorResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetUserChatColorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetUserChatColorResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetUserEmotes(ref string userId, ref Option<string> after, ref Option<string> broadcasterId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="broadcasterId"></param>
        /// <returns></returns>
        private void ValidateGetUserEmotes(string userId, Option<string> after, Option<string> broadcasterId)
        {
            if (userId == null)
                throw new ArgumentNullException(nameof(userId));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));

            if (broadcasterId.IsSet && broadcasterId.Value == null)
                throw new ArgumentNullException(nameof(broadcasterId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="broadcasterId"></param>
        private void AfterGetUserEmotesDefaultImplementation(IGetUserEmotesApiResponse apiResponseLocalVar, string userId, Option<string> after, Option<string> broadcasterId)
        {
            bool suppressDefaultLog = false;
            AfterGetUserEmotes(ref suppressDefaultLog, apiResponseLocalVar, userId, after, broadcasterId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="broadcasterId"></param>
        partial void AfterGetUserEmotes(ref bool suppressDefaultLog, IGetUserEmotesApiResponse apiResponseLocalVar, string userId, Option<string> after, Option<string> broadcasterId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="broadcasterId"></param>
        private void OnErrorGetUserEmotesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userId, Option<string> after, Option<string> broadcasterId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetUserEmotes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, userId, after, broadcasterId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="broadcasterId"></param>
        partial void OnErrorGetUserEmotes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userId, Option<string> after, Option<string> broadcasterId);

        /// <summary>
        /// NEW Retrieves emotes available to the user across all channels. NEW Retrieves emotes available to the user across all channels.  __Authorization:__  * Requires a user access token that includes the **user:read:emotes** scope. * Query parameter &#x60;user_id&#x60; must match the &#x60;user_id&#x60; in the user access token.
        /// </summary>
        /// <param name="userId">The ID of the user. This ID must match the user ID in the user access token.</param>
        /// <param name="after">The cursor used to get the next page of results. The Pagination object in the response contains the cursor’s value. (optional)</param>
        /// <param name="broadcasterId">The User ID of a broadcaster you wish to get follower emotes of. Using this query parameter will guarantee inclusion of the broadcaster’s follower emotes in the response body.       **Note:** If the user specified in &#x60;user_id&#x60; is subscribed to the broadcaster specified, their follower emotes will appear in the response body regardless if this query parameter is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserEmotesApiResponse"/>&gt;</returns>
        public async Task<IGetUserEmotesApiResponse?> GetUserEmotesOrDefaultAsync(string userId, Option<string> after = default, Option<string> broadcasterId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetUserEmotesAsync(userId, after, broadcasterId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// NEW Retrieves emotes available to the user across all channels. NEW Retrieves emotes available to the user across all channels.  __Authorization:__  * Requires a user access token that includes the **user:read:emotes** scope. * Query parameter &#x60;user_id&#x60; must match the &#x60;user_id&#x60; in the user access token.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The ID of the user. This ID must match the user ID in the user access token.</param>
        /// <param name="after">The cursor used to get the next page of results. The Pagination object in the response contains the cursor’s value. (optional)</param>
        /// <param name="broadcasterId">The User ID of a broadcaster you wish to get follower emotes of. Using this query parameter will guarantee inclusion of the broadcaster’s follower emotes in the response body.       **Note:** If the user specified in &#x60;user_id&#x60; is subscribed to the broadcaster specified, their follower emotes will appear in the response body regardless if this query parameter is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserEmotesApiResponse"/>&gt;</returns>
        public async Task<IGetUserEmotesApiResponse> GetUserEmotesAsync(string userId, Option<string> after = default, Option<string> broadcasterId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetUserEmotes(userId, after, broadcasterId);

                FormatGetUserEmotes(ref userId, ref after, ref broadcasterId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/emotes/user"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/emotes/user");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    if (broadcasterId.IsSet)
                        parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetUserEmotesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetUserEmotesApiResponse>();

                        GetUserEmotesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/emotes/user", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetUserEmotesDefaultImplementation(apiResponseLocalVar, userId, after, broadcasterId);

                        Events.ExecuteOnGetUserEmotes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetUserEmotesDefaultImplementation(e, "/chat/emotes/user", uriBuilderLocalVar.Path, userId, after, broadcasterId);
                Events.ExecuteOnErrorGetUserEmotes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetUserEmotesApiResponse"/>
        /// </summary>
        public partial class GetUserEmotesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetUserEmotesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetUserEmotesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetUserEmotesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetUserEmotesApiResponse(ILogger<GetUserEmotesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetUserEmotesResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetUserEmotesResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetUserEmotesResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendAShoutout(ref string fromBroadcasterId, ref string toBroadcasterId, ref string moderatorId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fromBroadcasterId"></param>
        /// <param name="toBroadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <returns></returns>
        private void ValidateSendAShoutout(string fromBroadcasterId, string toBroadcasterId, string moderatorId)
        {
            if (fromBroadcasterId == null)
                throw new ArgumentNullException(nameof(fromBroadcasterId));

            if (toBroadcasterId == null)
                throw new ArgumentNullException(nameof(toBroadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fromBroadcasterId"></param>
        /// <param name="toBroadcasterId"></param>
        /// <param name="moderatorId"></param>
        private void AfterSendAShoutoutDefaultImplementation(ISendAShoutoutApiResponse apiResponseLocalVar, string fromBroadcasterId, string toBroadcasterId, string moderatorId)
        {
            bool suppressDefaultLog = false;
            AfterSendAShoutout(ref suppressDefaultLog, apiResponseLocalVar, fromBroadcasterId, toBroadcasterId, moderatorId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fromBroadcasterId"></param>
        /// <param name="toBroadcasterId"></param>
        /// <param name="moderatorId"></param>
        partial void AfterSendAShoutout(ref bool suppressDefaultLog, ISendAShoutoutApiResponse apiResponseLocalVar, string fromBroadcasterId, string toBroadcasterId, string moderatorId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fromBroadcasterId"></param>
        /// <param name="toBroadcasterId"></param>
        /// <param name="moderatorId"></param>
        private void OnErrorSendAShoutoutDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string fromBroadcasterId, string toBroadcasterId, string moderatorId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendAShoutout(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fromBroadcasterId, toBroadcasterId, moderatorId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fromBroadcasterId"></param>
        /// <param name="toBroadcasterId"></param>
        /// <param name="moderatorId"></param>
        partial void OnErrorSendAShoutout(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string fromBroadcasterId, string toBroadcasterId, string moderatorId);

        /// <summary>
        /// Sends a Shoutout to the specified broadcaster. Sends a Shoutout to the specified broadcaster. Typically, you send Shoutouts when you or one of your moderators notice another broadcaster in your chat, the other broadcaster is coming up in conversation, or after they raid your broadcast.  Twitch’s Shoutout feature is a great way for you to show support for other broadcasters and help them grow. Viewers who do not follow the other broadcaster will see a pop-up Follow button in your chat that they can click to follow the other broadcaster. [Learn More](https://help.twitch.tv/s/article/shoutouts)  **Rate Limits**: The broadcaster may send a Shoutout once every 2 minutes. They may send the same broadcaster a Shoutout once every 60 minutes.  To receive notifications when a Shoutout is sent or received, subscribe to the [channel.shoutout.create](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutcreate) and [channel.shoutout.receive](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutreceive) subscription types. The **channel.shoutout.create** event includes cooldown periods that indicate when the broadcaster may send another Shoutout without exceeding the endpoint’s rate limit.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shoutouts** scope.
        /// </summary>
        /// <param name="fromBroadcasterId">The ID of the broadcaster that’s sending the Shoutout.</param>
        /// <param name="toBroadcasterId">The ID of the broadcaster that’s receiving the Shoutout.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that is one of the broadcaster’s moderators. This ID must match the user ID in the access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendAShoutoutApiResponse"/>&gt;</returns>
        public async Task<ISendAShoutoutApiResponse?> SendAShoutoutOrDefaultAsync(string fromBroadcasterId, string toBroadcasterId, string moderatorId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendAShoutoutAsync(fromBroadcasterId, toBroadcasterId, moderatorId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Sends a Shoutout to the specified broadcaster. Sends a Shoutout to the specified broadcaster. Typically, you send Shoutouts when you or one of your moderators notice another broadcaster in your chat, the other broadcaster is coming up in conversation, or after they raid your broadcast.  Twitch’s Shoutout feature is a great way for you to show support for other broadcasters and help them grow. Viewers who do not follow the other broadcaster will see a pop-up Follow button in your chat that they can click to follow the other broadcaster. [Learn More](https://help.twitch.tv/s/article/shoutouts)  **Rate Limits**: The broadcaster may send a Shoutout once every 2 minutes. They may send the same broadcaster a Shoutout once every 60 minutes.  To receive notifications when a Shoutout is sent or received, subscribe to the [channel.shoutout.create](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutcreate) and [channel.shoutout.receive](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutreceive) subscription types. The **channel.shoutout.create** event includes cooldown periods that indicate when the broadcaster may send another Shoutout without exceeding the endpoint’s rate limit.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shoutouts** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fromBroadcasterId">The ID of the broadcaster that’s sending the Shoutout.</param>
        /// <param name="toBroadcasterId">The ID of the broadcaster that’s receiving the Shoutout.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that is one of the broadcaster’s moderators. This ID must match the user ID in the access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendAShoutoutApiResponse"/>&gt;</returns>
        public async Task<ISendAShoutoutApiResponse> SendAShoutoutAsync(string fromBroadcasterId, string toBroadcasterId, string moderatorId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendAShoutout(fromBroadcasterId, toBroadcasterId, moderatorId);

                FormatSendAShoutout(ref fromBroadcasterId, ref toBroadcasterId, ref moderatorId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/shoutouts"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/shoutouts");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["from_broadcaster_id"] = ClientUtils.ParameterToString(fromBroadcasterId);
                    parseQueryStringLocalVar["to_broadcaster_id"] = ClientUtils.ParameterToString(toBroadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SendAShoutoutApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendAShoutoutApiResponse>();

                        SendAShoutoutApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/shoutouts", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendAShoutoutDefaultImplementation(apiResponseLocalVar, fromBroadcasterId, toBroadcasterId, moderatorId);

                        Events.ExecuteOnSendAShoutout(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendAShoutoutDefaultImplementation(e, "/chat/shoutouts", uriBuilderLocalVar.Path, fromBroadcasterId, toBroadcasterId, moderatorId);
                Events.ExecuteOnErrorSendAShoutout(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendAShoutoutApiResponse"/>
        /// </summary>
        public partial class SendAShoutoutApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ISendAShoutoutApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendAShoutoutApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendAShoutoutApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendAShoutoutApiResponse(ILogger<SendAShoutoutApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendChatAnnouncement(ref string broadcasterId, ref string moderatorId, Option<SendChatAnnouncementBody> sendChatAnnouncementBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="sendChatAnnouncementBody"></param>
        /// <returns></returns>
        private void ValidateSendChatAnnouncement(string broadcasterId, string moderatorId, Option<SendChatAnnouncementBody> sendChatAnnouncementBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (sendChatAnnouncementBody.IsSet && sendChatAnnouncementBody.Value == null)
                throw new ArgumentNullException(nameof(sendChatAnnouncementBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="sendChatAnnouncementBody"></param>
        private void AfterSendChatAnnouncementDefaultImplementation(ISendChatAnnouncementApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<SendChatAnnouncementBody> sendChatAnnouncementBody)
        {
            bool suppressDefaultLog = false;
            AfterSendChatAnnouncement(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, sendChatAnnouncementBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="sendChatAnnouncementBody"></param>
        partial void AfterSendChatAnnouncement(ref bool suppressDefaultLog, ISendChatAnnouncementApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<SendChatAnnouncementBody> sendChatAnnouncementBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="sendChatAnnouncementBody"></param>
        private void OnErrorSendChatAnnouncementDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<SendChatAnnouncementBody> sendChatAnnouncementBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendChatAnnouncement(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, sendChatAnnouncementBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="sendChatAnnouncementBody"></param>
        partial void OnErrorSendChatAnnouncement(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<SendChatAnnouncementBody> sendChatAnnouncementBody);

        /// <summary>
        /// Sends an announcement to the broadcaster’s chat room. Sends an announcement to the broadcaster’s chat room.  **Rate Limits**: One announcement may be sent every 2 seconds.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:announcements** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room to send the announcement to.</param>
        /// <param name="moderatorId">The ID of a user who has permission to moderate the broadcaster’s chat room, or the broadcaster’s ID if they’re sending the announcement. This ID must match the user ID in the user access token.</param>
        /// <param name="sendChatAnnouncementBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendChatAnnouncementApiResponse"/>&gt;</returns>
        public async Task<ISendChatAnnouncementApiResponse?> SendChatAnnouncementOrDefaultAsync(string broadcasterId, string moderatorId, Option<SendChatAnnouncementBody> sendChatAnnouncementBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendChatAnnouncementAsync(broadcasterId, moderatorId, sendChatAnnouncementBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Sends an announcement to the broadcaster’s chat room. Sends an announcement to the broadcaster’s chat room.  **Rate Limits**: One announcement may be sent every 2 seconds.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:announcements** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room to send the announcement to.</param>
        /// <param name="moderatorId">The ID of a user who has permission to moderate the broadcaster’s chat room, or the broadcaster’s ID if they’re sending the announcement. This ID must match the user ID in the user access token.</param>
        /// <param name="sendChatAnnouncementBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendChatAnnouncementApiResponse"/>&gt;</returns>
        public async Task<ISendChatAnnouncementApiResponse> SendChatAnnouncementAsync(string broadcasterId, string moderatorId, Option<SendChatAnnouncementBody> sendChatAnnouncementBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendChatAnnouncement(broadcasterId, moderatorId, sendChatAnnouncementBody);

                FormatSendChatAnnouncement(ref broadcasterId, ref moderatorId, sendChatAnnouncementBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/announcements"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/announcements");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (sendChatAnnouncementBody.IsSet)
                        httpRequestMessageLocalVar.Content = (sendChatAnnouncementBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendChatAnnouncementBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SendChatAnnouncementApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendChatAnnouncementApiResponse>();

                        SendChatAnnouncementApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/announcements", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendChatAnnouncementDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, sendChatAnnouncementBody);

                        Events.ExecuteOnSendChatAnnouncement(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendChatAnnouncementDefaultImplementation(e, "/chat/announcements", uriBuilderLocalVar.Path, broadcasterId, moderatorId, sendChatAnnouncementBody);
                Events.ExecuteOnErrorSendChatAnnouncement(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendChatAnnouncementApiResponse"/>
        /// </summary>
        public partial class SendChatAnnouncementApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ISendChatAnnouncementApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendChatAnnouncementApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendChatAnnouncementApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendChatAnnouncementApiResponse(ILogger<SendChatAnnouncementApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendChatMessage(Option<SendChatMessageBody> sendChatMessageBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sendChatMessageBody"></param>
        /// <returns></returns>
        private void ValidateSendChatMessage(Option<SendChatMessageBody> sendChatMessageBody)
        {
            if (sendChatMessageBody.IsSet && sendChatMessageBody.Value == null)
                throw new ArgumentNullException(nameof(sendChatMessageBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sendChatMessageBody"></param>
        private void AfterSendChatMessageDefaultImplementation(ISendChatMessageApiResponse apiResponseLocalVar, Option<SendChatMessageBody> sendChatMessageBody)
        {
            bool suppressDefaultLog = false;
            AfterSendChatMessage(ref suppressDefaultLog, apiResponseLocalVar, sendChatMessageBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sendChatMessageBody"></param>
        partial void AfterSendChatMessage(ref bool suppressDefaultLog, ISendChatMessageApiResponse apiResponseLocalVar, Option<SendChatMessageBody> sendChatMessageBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sendChatMessageBody"></param>
        private void OnErrorSendChatMessageDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<SendChatMessageBody> sendChatMessageBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendChatMessage(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, sendChatMessageBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sendChatMessageBody"></param>
        partial void OnErrorSendChatMessage(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<SendChatMessageBody> sendChatMessageBody);

        /// <summary>
        /// NEW Sends a message to the broadcaster’s chat room. NEW Sends a message to the broadcaster’s chat room.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the &#x60;user:write:chat&#x60; scope. If app access token used, then additionally requires &#x60;user:bot&#x60; scope from chatting user, and either &#x60;channel:bot&#x60; scope from broadcaster or moderator status.
        /// </summary>
        /// <param name="sendChatMessageBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendChatMessageApiResponse"/>&gt;</returns>
        public async Task<ISendChatMessageApiResponse?> SendChatMessageOrDefaultAsync(Option<SendChatMessageBody> sendChatMessageBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendChatMessageAsync(sendChatMessageBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// NEW Sends a message to the broadcaster’s chat room. NEW Sends a message to the broadcaster’s chat room.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the &#x60;user:write:chat&#x60; scope. If app access token used, then additionally requires &#x60;user:bot&#x60; scope from chatting user, and either &#x60;channel:bot&#x60; scope from broadcaster or moderator status.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendChatMessageBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendChatMessageApiResponse"/>&gt;</returns>
        public async Task<ISendChatMessageApiResponse> SendChatMessageAsync(Option<SendChatMessageBody> sendChatMessageBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendChatMessage(sendChatMessageBody);

                FormatSendChatMessage(sendChatMessageBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/messages"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/messages");

                    if (sendChatMessageBody.IsSet)
                        httpRequestMessageLocalVar.Content = (sendChatMessageBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendChatMessageBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SendChatMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendChatMessageApiResponse>();

                        SendChatMessageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/messages", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendChatMessageDefaultImplementation(apiResponseLocalVar, sendChatMessageBody);

                        Events.ExecuteOnSendChatMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendChatMessageDefaultImplementation(e, "/chat/messages", uriBuilderLocalVar.Path, sendChatMessageBody);
                Events.ExecuteOnErrorSendChatMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendChatMessageApiResponse"/>
        /// </summary>
        public partial class SendChatMessageApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ISendChatMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendChatMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendChatMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendChatMessageApiResponse(ILogger<SendChatMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.SendChatMessageResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.SendChatMessageResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.SendChatMessageResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateChatSettings(ref string broadcasterId, ref string moderatorId, Option<UpdateChatSettingsBody> updateChatSettingsBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateChatSettingsBody"></param>
        /// <returns></returns>
        private void ValidateUpdateChatSettings(string broadcasterId, string moderatorId, Option<UpdateChatSettingsBody> updateChatSettingsBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (updateChatSettingsBody.IsSet && updateChatSettingsBody.Value == null)
                throw new ArgumentNullException(nameof(updateChatSettingsBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateChatSettingsBody"></param>
        private void AfterUpdateChatSettingsDefaultImplementation(IUpdateChatSettingsApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<UpdateChatSettingsBody> updateChatSettingsBody)
        {
            bool suppressDefaultLog = false;
            AfterUpdateChatSettings(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, updateChatSettingsBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateChatSettingsBody"></param>
        partial void AfterUpdateChatSettings(ref bool suppressDefaultLog, IUpdateChatSettingsApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<UpdateChatSettingsBody> updateChatSettingsBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateChatSettingsBody"></param>
        private void OnErrorUpdateChatSettingsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<UpdateChatSettingsBody> updateChatSettingsBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateChatSettings(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, updateChatSettingsBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateChatSettingsBody"></param>
        partial void OnErrorUpdateChatSettings(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<UpdateChatSettingsBody> updateChatSettingsBody);

        /// <summary>
        /// Updates the broadcaster’s chat settings. Updates the broadcaster’s chat settings.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\\_settings** scope.  __Request Body:__  All fields are optional. Specify only those fields that you want to update.  To set the &#x60;slow_mode_wait_time&#x60; or &#x60;follower_mode_duration&#x60; field to its default value, set the corresponding &#x60;slow_mode&#x60; or &#x60;follower_mode&#x60; field to **true** (and don’t include the &#x60;slow_mode_wait_time&#x60; or &#x60;follower_mode_duration&#x60; field).  To set the &#x60;slow_mode_wait_time&#x60;, &#x60;follower_mode_duration&#x60;, or &#x60;non_moderator_chat_delay_duration&#x60; field’s value, you must set the corresponding &#x60;slow_mode&#x60;, &#x60;follower_mode&#x60;, or &#x60;non_moderator_chat_delay&#x60; field to **true**.  To remove the &#x60;slow_mode_wait_time&#x60;, &#x60;follower_mode_duration&#x60;, or &#x60;non_moderator_chat_delay_duration&#x60; field’s value, set the corresponding &#x60;slow_mode&#x60;, &#x60;follower_mode&#x60;, or &#x60;non_moderator_chat_delay&#x60; field to **false** (and don’t include the &#x60;slow_mode_wait_time&#x60;, &#x60;follower_mode_duration&#x60;, or &#x60;non_moderator_chat_delay_duration&#x60; field).
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat settings you want to update.</param>
        /// <param name="moderatorId">The ID of a user that has permission to moderate the broadcaster’s chat room, or the broadcaster’s ID if they’re making the update. This ID must match the user ID in the user access token.</param>
        /// <param name="updateChatSettingsBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateChatSettingsApiResponse"/>&gt;</returns>
        public async Task<IUpdateChatSettingsApiResponse?> UpdateChatSettingsOrDefaultAsync(string broadcasterId, string moderatorId, Option<UpdateChatSettingsBody> updateChatSettingsBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateChatSettingsAsync(broadcasterId, moderatorId, updateChatSettingsBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Updates the broadcaster’s chat settings. Updates the broadcaster’s chat settings.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\\_settings** scope.  __Request Body:__  All fields are optional. Specify only those fields that you want to update.  To set the &#x60;slow_mode_wait_time&#x60; or &#x60;follower_mode_duration&#x60; field to its default value, set the corresponding &#x60;slow_mode&#x60; or &#x60;follower_mode&#x60; field to **true** (and don’t include the &#x60;slow_mode_wait_time&#x60; or &#x60;follower_mode_duration&#x60; field).  To set the &#x60;slow_mode_wait_time&#x60;, &#x60;follower_mode_duration&#x60;, or &#x60;non_moderator_chat_delay_duration&#x60; field’s value, you must set the corresponding &#x60;slow_mode&#x60;, &#x60;follower_mode&#x60;, or &#x60;non_moderator_chat_delay&#x60; field to **true**.  To remove the &#x60;slow_mode_wait_time&#x60;, &#x60;follower_mode_duration&#x60;, or &#x60;non_moderator_chat_delay_duration&#x60; field’s value, set the corresponding &#x60;slow_mode&#x60;, &#x60;follower_mode&#x60;, or &#x60;non_moderator_chat_delay&#x60; field to **false** (and don’t include the &#x60;slow_mode_wait_time&#x60;, &#x60;follower_mode_duration&#x60;, or &#x60;non_moderator_chat_delay_duration&#x60; field).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat settings you want to update.</param>
        /// <param name="moderatorId">The ID of a user that has permission to moderate the broadcaster’s chat room, or the broadcaster’s ID if they’re making the update. This ID must match the user ID in the user access token.</param>
        /// <param name="updateChatSettingsBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateChatSettingsApiResponse"/>&gt;</returns>
        public async Task<IUpdateChatSettingsApiResponse> UpdateChatSettingsAsync(string broadcasterId, string moderatorId, Option<UpdateChatSettingsBody> updateChatSettingsBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateChatSettings(broadcasterId, moderatorId, updateChatSettingsBody);

                FormatUpdateChatSettings(ref broadcasterId, ref moderatorId, updateChatSettingsBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/settings"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/settings");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (updateChatSettingsBody.IsSet)
                        httpRequestMessageLocalVar.Content = (updateChatSettingsBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(updateChatSettingsBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateChatSettingsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateChatSettingsApiResponse>();

                        UpdateChatSettingsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/settings", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateChatSettingsDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, updateChatSettingsBody);

                        Events.ExecuteOnUpdateChatSettings(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateChatSettingsDefaultImplementation(e, "/chat/settings", uriBuilderLocalVar.Path, broadcasterId, moderatorId, updateChatSettingsBody);
                Events.ExecuteOnErrorUpdateChatSettings(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateChatSettingsApiResponse"/>
        /// </summary>
        public partial class UpdateChatSettingsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IUpdateChatSettingsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateChatSettingsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateChatSettingsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateChatSettingsApiResponse(ILogger<UpdateChatSettingsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateChatSettingsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateChatSettingsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateChatSettingsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateUserChatColor(ref string userId, ref string color);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="userId"></param>
        /// <param name="color"></param>
        /// <returns></returns>
        private void ValidateUpdateUserChatColor(string userId, string color)
        {
            if (userId == null)
                throw new ArgumentNullException(nameof(userId));

            if (color == null)
                throw new ArgumentNullException(nameof(color));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="color"></param>
        private void AfterUpdateUserChatColorDefaultImplementation(IUpdateUserChatColorApiResponse apiResponseLocalVar, string userId, string color)
        {
            bool suppressDefaultLog = false;
            AfterUpdateUserChatColor(ref suppressDefaultLog, apiResponseLocalVar, userId, color);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="color"></param>
        partial void AfterUpdateUserChatColor(ref bool suppressDefaultLog, IUpdateUserChatColorApiResponse apiResponseLocalVar, string userId, string color);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="color"></param>
        private void OnErrorUpdateUserChatColorDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userId, string color)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateUserChatColor(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, userId, color);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="color"></param>
        partial void OnErrorUpdateUserChatColor(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userId, string color);

        /// <summary>
        /// Updates the color used for the user’s name in chat. Updates the color used for the user’s name in chat.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:chat\\_color** scope.
        /// </summary>
        /// <param name="userId">The ID of the user whose chat color you want to update. This ID must match the user ID in the access token.</param>
        /// <param name="color">The color to use for the user&#39;s name in chat. All users may specify one of the following named color values.      * blue * blue\\_violet * cadet\\_blue * chocolate * coral * dodger\\_blue * firebrick * golden\\_rod * green * hot\\_pink * orange\\_red * red * sea\\_green * spring\\_green * yellow\\_green    Turbo and Prime users may specify a named color or a Hex color code like #9146FF. If you use a Hex color code, remember to URL encode it.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateUserChatColorApiResponse"/>&gt;</returns>
        public async Task<IUpdateUserChatColorApiResponse?> UpdateUserChatColorOrDefaultAsync(string userId, string color, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateUserChatColorAsync(userId, color, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Updates the color used for the user’s name in chat. Updates the color used for the user’s name in chat.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:chat\\_color** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The ID of the user whose chat color you want to update. This ID must match the user ID in the access token.</param>
        /// <param name="color">The color to use for the user&#39;s name in chat. All users may specify one of the following named color values.      * blue * blue\\_violet * cadet\\_blue * chocolate * coral * dodger\\_blue * firebrick * golden\\_rod * green * hot\\_pink * orange\\_red * red * sea\\_green * spring\\_green * yellow\\_green    Turbo and Prime users may specify a named color or a Hex color code like #9146FF. If you use a Hex color code, remember to URL encode it.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateUserChatColorApiResponse"/>&gt;</returns>
        public async Task<IUpdateUserChatColorApiResponse> UpdateUserChatColorAsync(string userId, string color, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateUserChatColor(userId, color);

                FormatUpdateUserChatColor(ref userId, ref color);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/chat/color"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/chat/color");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId);
                    parseQueryStringLocalVar["color"] = ClientUtils.ParameterToString(color);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateUserChatColorApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateUserChatColorApiResponse>();

                        UpdateUserChatColorApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/chat/color", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateUserChatColorDefaultImplementation(apiResponseLocalVar, userId, color);

                        Events.ExecuteOnUpdateUserChatColor(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateUserChatColorDefaultImplementation(e, "/chat/color", uriBuilderLocalVar.Path, userId, color);
                Events.ExecuteOnErrorUpdateUserChatColor(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateUserChatColorApiResponse"/>
        /// </summary>
        public partial class UpdateUserChatColorApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IUpdateUserChatColorApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateUserChatColorApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateUserChatColorApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateUserChatColorApiResponse(ILogger<UpdateUserChatColorApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
