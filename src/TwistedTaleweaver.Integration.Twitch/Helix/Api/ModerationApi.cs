// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;
using TwistedTaleweaver.Integration.Twitch.Helix.Model;
using System.Diagnostics.CodeAnalysis;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IModerationApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ModerationApiEvents Events { get; }

        /// <summary>
        /// Adds a word or phrase to the broadcaster’s list of blocked terms.
        /// </summary>
        /// <remarks>
        /// Adds a word or phrase to the broadcaster’s list of blocked terms. These are the terms that the broadcaster doesn’t want used in their chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\\_terms** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the list of blocked terms.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="addBlockedTermBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddBlockedTermApiResponse"/>&gt;</returns>
        Task<IAddBlockedTermApiResponse> AddBlockedTermAsync(string broadcasterId, string moderatorId, Option<AddBlockedTermBody> addBlockedTermBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Adds a word or phrase to the broadcaster’s list of blocked terms.
        /// </summary>
        /// <remarks>
        /// Adds a word or phrase to the broadcaster’s list of blocked terms. These are the terms that the broadcaster doesn’t want used in their chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\\_terms** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the list of blocked terms.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="addBlockedTermBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddBlockedTermApiResponse"/>?&gt;</returns>
        Task<IAddBlockedTermApiResponse?> AddBlockedTermOrDefaultAsync(string broadcasterId, string moderatorId, Option<AddBlockedTermBody> addBlockedTermBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Adds a moderator to the broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// Adds a moderator to the broadcaster’s chat room.  **Rate Limits**: The broadcaster may add a maximum of 10 moderators within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room. This ID must match the user ID in the access token.</param>
        /// <param name="userId">The ID of the user to add as a moderator in the broadcaster’s chat room.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddChannelModeratorApiResponse"/>&gt;</returns>
        Task<IAddChannelModeratorApiResponse> AddChannelModeratorAsync(string broadcasterId, string userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Adds a moderator to the broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// Adds a moderator to the broadcaster’s chat room.  **Rate Limits**: The broadcaster may add a maximum of 10 moderators within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room. This ID must match the user ID in the access token.</param>
        /// <param name="userId">The ID of the user to add as a moderator in the broadcaster’s chat room.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddChannelModeratorApiResponse"/>?&gt;</returns>
        Task<IAddChannelModeratorApiResponse?> AddChannelModeratorOrDefaultAsync(string broadcasterId, string userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Adds the specified user as a VIP in the broadcaster’s channel.
        /// </summary>
        /// <remarks>
        /// Adds the specified user as a VIP in the broadcaster’s channel.  **Rate Limits**: The broadcaster may add a maximum of 10 VIPs within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The ID of the user to give VIP status to.</param>
        /// <param name="broadcasterId">The ID of the broadcaster that’s adding the user as a VIP. This ID must match the user ID in the access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddChannelVipApiResponse"/>&gt;</returns>
        Task<IAddChannelVipApiResponse> AddChannelVipAsync(string userId, string broadcasterId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Adds the specified user as a VIP in the broadcaster’s channel.
        /// </summary>
        /// <remarks>
        /// Adds the specified user as a VIP in the broadcaster’s channel.  **Rate Limits**: The broadcaster may add a maximum of 10 VIPs within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
        /// </remarks>
        /// <param name="userId">The ID of the user to give VIP status to.</param>
        /// <param name="broadcasterId">The ID of the broadcaster that’s adding the user as a VIP. This ID must match the user ID in the access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddChannelVipApiResponse"/>?&gt;</returns>
        Task<IAddChannelVipApiResponse?> AddChannelVipOrDefaultAsync(string userId, string broadcasterId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Bans a user from participating in a broadcaster’s chat room or puts them in a timeout.
        /// </summary>
        /// <remarks>
        /// Bans a user from participating in the specified broadcaster’s chat room or puts them in a timeout.  For information about banning or putting users in a timeout, see [Ban a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheBanFeature) and [Timeout a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheTimeoutFeature).  If the user is currently in a timeout, you can call this endpoint to change the duration of the timeout or ban them altogether. If the user is currently banned, you cannot call this method to put them in a timeout instead.  To remove a ban or end a timeout, see [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user).  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\\_users** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat room the user is being banned from.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="banUserBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBanUserApiResponse"/>&gt;</returns>
        Task<IBanUserApiResponse> BanUserAsync(string broadcasterId, string moderatorId, Option<BanUserBody> banUserBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Bans a user from participating in a broadcaster’s chat room or puts them in a timeout.
        /// </summary>
        /// <remarks>
        /// Bans a user from participating in the specified broadcaster’s chat room or puts them in a timeout.  For information about banning or putting users in a timeout, see [Ban a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheBanFeature) and [Timeout a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheTimeoutFeature).  If the user is currently in a timeout, you can call this endpoint to change the duration of the timeout or ban them altogether. If the user is currently banned, you cannot call this method to put them in a timeout instead.  To remove a ban or end a timeout, see [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user).  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\\_users** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat room the user is being banned from.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="banUserBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBanUserApiResponse"/>?&gt;</returns>
        Task<IBanUserApiResponse?> BanUserOrDefaultAsync(string broadcasterId, string moderatorId, Option<BanUserBody> banUserBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Checks whether AutoMod would flag the specified message for review.
        /// </summary>
        /// <remarks>
        /// Checks whether AutoMod would flag the specified message for review.  AutoMod is a moderation tool that holds inappropriate or harassing chat messages for moderators to review. Moderators approve or deny the messages that AutoMod flags; only approved messages are released to chat. AutoMod detects misspellings and evasive language automatically. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).  **Rate Limits**: Rates are limited per channel based on the account type rather than per access token.  | Account type | Limit per minute | Limit per hour | | - | - | - | | Normal | 5 | 50 | | Affiliate | 10 | 100 | | Partner | 30 | 300 |   The above limits are in addition to the standard [Twitch API rate limits](https://dev.twitch.tv/docs/api/guide#twitch-rate-limits). The rate limit headers in the response represent the Twitch rate limits and not the above limits.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose AutoMod settings and list of blocked terms are used to check the message. This ID must match the user ID in the access token.</param>
        /// <param name="checkAutoModStatusBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckAutomodStatusApiResponse"/>&gt;</returns>
        Task<ICheckAutomodStatusApiResponse> CheckAutomodStatusAsync(string broadcasterId, Option<CheckAutoModStatusBody> checkAutoModStatusBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Checks whether AutoMod would flag the specified message for review.
        /// </summary>
        /// <remarks>
        /// Checks whether AutoMod would flag the specified message for review.  AutoMod is a moderation tool that holds inappropriate or harassing chat messages for moderators to review. Moderators approve or deny the messages that AutoMod flags; only approved messages are released to chat. AutoMod detects misspellings and evasive language automatically. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).  **Rate Limits**: Rates are limited per channel based on the account type rather than per access token.  | Account type | Limit per minute | Limit per hour | | - | - | - | | Normal | 5 | 50 | | Affiliate | 10 | 100 | | Partner | 30 | 300 |   The above limits are in addition to the standard [Twitch API rate limits](https://dev.twitch.tv/docs/api/guide#twitch-rate-limits). The rate limit headers in the response represent the Twitch rate limits and not the above limits.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose AutoMod settings and list of blocked terms are used to check the message. This ID must match the user ID in the access token.</param>
        /// <param name="checkAutoModStatusBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckAutomodStatusApiResponse"/>?&gt;</returns>
        Task<ICheckAutomodStatusApiResponse?> CheckAutomodStatusOrDefaultAsync(string broadcasterId, Option<CheckAutoModStatusBody> checkAutoModStatusBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Removes a single chat message or all chat messages from the broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// Removes a single chat message or all chat messages from the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\\_messages** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room to remove messages from.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="messageId">The ID of the message to remove. The &#x60;id&#x60; tag in the [PRIVMSG](https://dev.twitch.tv/docs/irc/tags#privmsg-tags) tag contains the message’s ID. Restrictions:      * The message must have been created within the last 6 hours. * The message must not belong to the broadcaster. * The message must not belong to another moderator.    If not specified, the request removes all messages in the broadcaster’s chat room. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteChatMessagesApiResponse"/>&gt;</returns>
        Task<IDeleteChatMessagesApiResponse> DeleteChatMessagesAsync(string broadcasterId, string moderatorId, Option<string> messageId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Removes a single chat message or all chat messages from the broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// Removes a single chat message or all chat messages from the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\\_messages** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room to remove messages from.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="messageId">The ID of the message to remove. The &#x60;id&#x60; tag in the [PRIVMSG](https://dev.twitch.tv/docs/irc/tags#privmsg-tags) tag contains the message’s ID. Restrictions:      * The message must have been created within the last 6 hours. * The message must not belong to the broadcaster. * The message must not belong to another moderator.    If not specified, the request removes all messages in the broadcaster’s chat room. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteChatMessagesApiResponse"/>?&gt;</returns>
        Task<IDeleteChatMessagesApiResponse?> DeleteChatMessagesOrDefaultAsync(string broadcasterId, string moderatorId, Option<string> messageId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s AutoMod settings.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:automod\\_settings** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose AutoMod settings you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAutomodSettingsApiResponse"/>&gt;</returns>
        Task<IGetAutomodSettingsApiResponse> GetAutomodSettingsAsync(string broadcasterId, string moderatorId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s AutoMod settings.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:automod\\_settings** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose AutoMod settings you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAutomodSettingsApiResponse"/>?&gt;</returns>
        Task<IGetAutomodSettingsApiResponse?> GetAutomodSettingsOrDefaultAsync(string broadcasterId, string moderatorId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets all users that the broadcaster banned or put in a timeout.
        /// </summary>
        /// <remarks>
        /// Gets all users that the broadcaster banned or put in a timeout.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** or **moderator:manage:banned\\_users** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of banned users you want to get. This ID must match the user ID in the access token.</param>
        /// <param name="userId">A list of user IDs used to filter the results. To specify more than one ID, include this parameter for each user you want to get. For example, &#x60;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. You may specify a maximum of 100 IDs.      The returned list includes only those users that were banned or put in a timeout. The list is returned in the same order that you specified the IDs. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="before">The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBannedUsersApiResponse"/>&gt;</returns>
        Task<IGetBannedUsersApiResponse> GetBannedUsersAsync(string broadcasterId, Option<List<string>> userId = default, Option<int> first = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets all users that the broadcaster banned or put in a timeout.
        /// </summary>
        /// <remarks>
        /// Gets all users that the broadcaster banned or put in a timeout.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** or **moderator:manage:banned\\_users** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of banned users you want to get. This ID must match the user ID in the access token.</param>
        /// <param name="userId">A list of user IDs used to filter the results. To specify more than one ID, include this parameter for each user you want to get. For example, &#x60;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. You may specify a maximum of 100 IDs.      The returned list includes only those users that were banned or put in a timeout. The list is returned in the same order that you specified the IDs. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="before">The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBannedUsersApiResponse"/>?&gt;</returns>
        Task<IGetBannedUsersApiResponse?> GetBannedUsersOrDefaultAsync(string broadcasterId, Option<List<string>> userId = default, Option<int> first = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s list of non-private, blocked words or phrases.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s list of non-private, blocked words or phrases. These are the terms that the broadcaster or moderator added manually or that were denied by AutoMod.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:blocked\\_terms** or **moderator:manage:blocked\\_terms** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose blocked terms you’re getting.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBlockedTermsApiResponse"/>&gt;</returns>
        Task<IGetBlockedTermsApiResponse> GetBlockedTermsAsync(string broadcasterId, string moderatorId, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s list of non-private, blocked words or phrases.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s list of non-private, blocked words or phrases. These are the terms that the broadcaster or moderator added manually or that were denied by AutoMod.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:blocked\\_terms** or **moderator:manage:blocked\\_terms** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose blocked terms you’re getting.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBlockedTermsApiResponse"/>?&gt;</returns>
        Task<IGetBlockedTermsApiResponse?> GetBlockedTermsOrDefaultAsync(string broadcasterId, string moderatorId, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of channels that the specified user has moderator privileges in.
        /// </summary>
        /// <remarks>
        /// Gets a list of channels that the specified user has moderator privileges in.  __Authorization:__  * Query parameter &#x60;user_id&#x60; must match the user ID in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) * Requires OAuth Scope: &#x60;user:read:moderated_channels&#x60;
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">A user’s ID. Returns the list of channels that this user has moderator privileges in. This ID must match the user ID in the user OAuth token</param>
        /// <param name="after">The cursor used to get the next page of results. The Pagination object in the response contains the cursor’s value. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response.      Minimum page size is 1 item per page and the maximum is 100\\. The default is 20. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetModeratedChannelsApiResponse"/>&gt;</returns>
        Task<IGetModeratedChannelsApiResponse> GetModeratedChannelsAsync(string userId, Option<string> after = default, Option<int> first = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of channels that the specified user has moderator privileges in.
        /// </summary>
        /// <remarks>
        /// Gets a list of channels that the specified user has moderator privileges in.  __Authorization:__  * Query parameter &#x60;user_id&#x60; must match the user ID in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) * Requires OAuth Scope: &#x60;user:read:moderated_channels&#x60;
        /// </remarks>
        /// <param name="userId">A user’s ID. Returns the list of channels that this user has moderator privileges in. This ID must match the user ID in the user OAuth token</param>
        /// <param name="after">The cursor used to get the next page of results. The Pagination object in the response contains the cursor’s value. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response.      Minimum page size is 1 item per page and the maximum is 100\\. The default is 20. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetModeratedChannelsApiResponse"/>?&gt;</returns>
        Task<IGetModeratedChannelsApiResponse?> GetModeratedChannelsOrDefaultAsync(string userId, Option<string> after = default, Option<int> first = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets all users allowed to moderate the broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// Gets all users allowed to moderate the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope. If your app also adds and removes moderators, you can use the **channel:manage:moderators** scope instead.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of moderators you want to get. This ID must match the user ID in the access token.</param>
        /// <param name="userId">A list of user IDs used to filter the results. To specify more than one ID, include this parameter for each moderator you want to get. For example, &#x60;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. You may specify a maximum of 100 IDs.      The returned list includes only the users from the list who are moderators in the broadcaster’s channel. The list is returned in the same order as you specified the IDs. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetModeratorsApiResponse"/>&gt;</returns>
        Task<IGetModeratorsApiResponse> GetModeratorsAsync(string broadcasterId, Option<List<string>> userId = default, Option<string> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets all users allowed to moderate the broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// Gets all users allowed to moderate the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope. If your app also adds and removes moderators, you can use the **channel:manage:moderators** scope instead.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of moderators you want to get. This ID must match the user ID in the access token.</param>
        /// <param name="userId">A list of user IDs used to filter the results. To specify more than one ID, include this parameter for each moderator you want to get. For example, &#x60;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. You may specify a maximum of 100 IDs.      The returned list includes only the users from the list who are moderators in the broadcaster’s channel. The list is returned in the same order as you specified the IDs. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetModeratorsApiResponse"/>?&gt;</returns>
        Task<IGetModeratorsApiResponse?> GetModeratorsOrDefaultAsync(string broadcasterId, Option<List<string>> userId = default, Option<string> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s Shield Mode activation status.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s Shield Mode activation status.  To receive notification when the broadcaster activates and deactivates Shield Mode, subscribe to the [channel.shield\\_mode.begin](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodebegin) and [channel.shield\\_mode.end](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodeend) subscription types.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:shield\\_mode** or **moderator:manage:shield\\_mode** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose Shield Mode activation status you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that is one of the broadcaster’s moderators. This ID must match the user ID in the access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetShieldModeStatusApiResponse"/>&gt;</returns>
        Task<IGetShieldModeStatusApiResponse> GetShieldModeStatusAsync(string broadcasterId, string moderatorId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s Shield Mode activation status.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s Shield Mode activation status.  To receive notification when the broadcaster activates and deactivates Shield Mode, subscribe to the [channel.shield\\_mode.begin](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodebegin) and [channel.shield\\_mode.end](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodeend) subscription types.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:shield\\_mode** or **moderator:manage:shield\\_mode** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose Shield Mode activation status you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that is one of the broadcaster’s moderators. This ID must match the user ID in the access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetShieldModeStatusApiResponse"/>?&gt;</returns>
        Task<IGetShieldModeStatusApiResponse?> GetShieldModeStatusOrDefaultAsync(string broadcasterId, string moderatorId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// NEW Gets a list of unban requests for a broadcaster’s channel.
        /// </summary>
        /// <remarks>
        /// NEW Gets a list of unban requests for a broadcaster’s channel.  __Authorization:__  * Requires a user access token that includes the **moderator:read:unban\\_requests** or **moderator:manage:unban\\_requests** scope. * Query parameter &#x60;moderator_id&#x60; must match the &#x60;user_id&#x60; in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose channel is receiving unban requests.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s unban requests. This ID must match the user ID in the user access token.</param>
        /// <param name="status">Filter by a status.      * pending * approved * denied * acknowledged * canceled</param>
        /// <param name="userId">The ID used to filter what unban requests are returned. (optional)</param>
        /// <param name="after">Cursor used to get next page of results. Pagination object in response contains cursor value. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in response (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUnbanRequestsApiResponse"/>&gt;</returns>
        Task<IGetUnbanRequestsApiResponse> GetUnbanRequestsAsync(string broadcasterId, string moderatorId, string status, Option<string> userId = default, Option<string> after = default, Option<int> first = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// NEW Gets a list of unban requests for a broadcaster’s channel.
        /// </summary>
        /// <remarks>
        /// NEW Gets a list of unban requests for a broadcaster’s channel.  __Authorization:__  * Requires a user access token that includes the **moderator:read:unban\\_requests** or **moderator:manage:unban\\_requests** scope. * Query parameter &#x60;moderator_id&#x60; must match the &#x60;user_id&#x60; in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose channel is receiving unban requests.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s unban requests. This ID must match the user ID in the user access token.</param>
        /// <param name="status">Filter by a status.      * pending * approved * denied * acknowledged * canceled</param>
        /// <param name="userId">The ID used to filter what unban requests are returned. (optional)</param>
        /// <param name="after">Cursor used to get next page of results. Pagination object in response contains cursor value. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in response (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUnbanRequestsApiResponse"/>?&gt;</returns>
        Task<IGetUnbanRequestsApiResponse?> GetUnbanRequestsOrDefaultAsync(string broadcasterId, string moderatorId, string status, Option<string> userId = default, Option<string> after = default, Option<int> first = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of the broadcaster’s VIPs.
        /// </summary>
        /// <remarks>
        /// Gets a list of the broadcaster’s VIPs.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:vips** scope. If your app also adds and removes VIP status, you can use the **channel:manage:vips** scope instead.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of VIPs you want to get. This ID must match the user ID in the access token.</param>
        /// <param name="userId">Filters the list for specific VIPs. To specify more than one user, include the _user\\_id_ parameter for each user to get. For example, &#x60;&amp;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. The maximum number of IDs that you may specify is 100\\. Ignores the ID of those users in the list that aren’t VIPs. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\\. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVipsApiResponse"/>&gt;</returns>
        Task<IGetVipsApiResponse> GetVipsAsync(string broadcasterId, Option<List<string>> userId = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of the broadcaster’s VIPs.
        /// </summary>
        /// <remarks>
        /// Gets a list of the broadcaster’s VIPs.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:vips** scope. If your app also adds and removes VIP status, you can use the **channel:manage:vips** scope instead.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of VIPs you want to get. This ID must match the user ID in the access token.</param>
        /// <param name="userId">Filters the list for specific VIPs. To specify more than one user, include the _user\\_id_ parameter for each user to get. For example, &#x60;&amp;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. The maximum number of IDs that you may specify is 100\\. Ignores the ID of those users in the list that aren’t VIPs. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\\. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVipsApiResponse"/>?&gt;</returns>
        Task<IGetVipsApiResponse?> GetVipsOrDefaultAsync(string broadcasterId, Option<List<string>> userId = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Allow or deny the message that AutoMod flagged for review.
        /// </summary>
        /// <remarks>
        /// Allow or deny the message that AutoMod flagged for review. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).  To get messages that AutoMod is holding for review, subscribe to the **automod-queue.&lt;moderator\\_id&gt;.&lt;channel\\_id&gt;** [topic](https://dev.twitch.tv/docs/pubsub#topics) using [PubSub](https://dev.twitch.tv/docs/pubsub). PubSub sends a notification to your app when AutoMod holds a message for review.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="manageHeldAutoModMessagesBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageHeldAutomodMessagesApiResponse"/>&gt;</returns>
        Task<IManageHeldAutomodMessagesApiResponse> ManageHeldAutomodMessagesAsync(Option<ManageHeldAutoModMessagesBody> manageHeldAutoModMessagesBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Allow or deny the message that AutoMod flagged for review.
        /// </summary>
        /// <remarks>
        /// Allow or deny the message that AutoMod flagged for review. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).  To get messages that AutoMod is holding for review, subscribe to the **automod-queue.&lt;moderator\\_id&gt;.&lt;channel\\_id&gt;** [topic](https://dev.twitch.tv/docs/pubsub#topics) using [PubSub](https://dev.twitch.tv/docs/pubsub). PubSub sends a notification to your app when AutoMod holds a message for review.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod** scope.
        /// </remarks>
        /// <param name="manageHeldAutoModMessagesBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageHeldAutomodMessagesApiResponse"/>?&gt;</returns>
        Task<IManageHeldAutomodMessagesApiResponse?> ManageHeldAutomodMessagesOrDefaultAsync(Option<ManageHeldAutoModMessagesBody> manageHeldAutoModMessagesBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Removes the word or phrase from the broadcaster’s list of blocked terms.
        /// </summary>
        /// <remarks>
        /// Removes the word or phrase from the broadcaster’s list of blocked terms.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\\_terms** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the list of blocked terms.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="id">The ID of the blocked term to remove from the broadcaster’s list of blocked terms.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveBlockedTermApiResponse"/>&gt;</returns>
        Task<IRemoveBlockedTermApiResponse> RemoveBlockedTermAsync(string broadcasterId, string moderatorId, string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Removes the word or phrase from the broadcaster’s list of blocked terms.
        /// </summary>
        /// <remarks>
        /// Removes the word or phrase from the broadcaster’s list of blocked terms.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\\_terms** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the list of blocked terms.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="id">The ID of the blocked term to remove from the broadcaster’s list of blocked terms.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveBlockedTermApiResponse"/>?&gt;</returns>
        Task<IRemoveBlockedTermApiResponse?> RemoveBlockedTermOrDefaultAsync(string broadcasterId, string moderatorId, string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Removes a moderator from the broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// Removes a moderator from the broadcaster’s chat room.  **Rate Limits**: The broadcaster may remove a maximum of 10 moderators within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room. This ID must match the user ID in the access token.</param>
        /// <param name="userId">The ID of the user to remove as a moderator from the broadcaster’s chat room.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveChannelModeratorApiResponse"/>&gt;</returns>
        Task<IRemoveChannelModeratorApiResponse> RemoveChannelModeratorAsync(string broadcasterId, string userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Removes a moderator from the broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// Removes a moderator from the broadcaster’s chat room.  **Rate Limits**: The broadcaster may remove a maximum of 10 moderators within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room. This ID must match the user ID in the access token.</param>
        /// <param name="userId">The ID of the user to remove as a moderator from the broadcaster’s chat room.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveChannelModeratorApiResponse"/>?&gt;</returns>
        Task<IRemoveChannelModeratorApiResponse?> RemoveChannelModeratorOrDefaultAsync(string broadcasterId, string userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Removes the specified user as a VIP in the broadcaster’s channel.
        /// </summary>
        /// <remarks>
        /// Removes the specified user as a VIP in the broadcaster’s channel.  If the broadcaster is removing the user’s VIP status, the ID in the _broadcaster\\_id_ query parameter must match the user ID in the access token; otherwise, if the user is removing their VIP status themselves, the ID in the _user\\_id_ query parameter must match the user ID in the access token.  **Rate Limits**: The broadcaster may remove a maximum of 10 VIPs within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The ID of the user to remove VIP status from.</param>
        /// <param name="broadcasterId">The ID of the broadcaster who owns the channel where the user has VIP status.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveChannelVipApiResponse"/>&gt;</returns>
        Task<IRemoveChannelVipApiResponse> RemoveChannelVipAsync(string userId, string broadcasterId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Removes the specified user as a VIP in the broadcaster’s channel.
        /// </summary>
        /// <remarks>
        /// Removes the specified user as a VIP in the broadcaster’s channel.  If the broadcaster is removing the user’s VIP status, the ID in the _broadcaster\\_id_ query parameter must match the user ID in the access token; otherwise, if the user is removing their VIP status themselves, the ID in the _user\\_id_ query parameter must match the user ID in the access token.  **Rate Limits**: The broadcaster may remove a maximum of 10 VIPs within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
        /// </remarks>
        /// <param name="userId">The ID of the user to remove VIP status from.</param>
        /// <param name="broadcasterId">The ID of the broadcaster who owns the channel where the user has VIP status.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveChannelVipApiResponse"/>?&gt;</returns>
        Task<IRemoveChannelVipApiResponse?> RemoveChannelVipOrDefaultAsync(string userId, string broadcasterId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// NEW Resolves an unban request by approving or denying it.
        /// </summary>
        /// <remarks>
        /// NEW Resolves an unban request by approving or denying it.  __Authorization:__  * Requires a user access token that includes the **moderator:manage:unban\\_requests** scope. * Query parameter &#x60;moderator_id&#x60; must match the &#x60;user_id&#x60; in the[user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose channel is approving or denying the unban request.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s unban requests. This ID must match the user ID in the user access token.</param>
        /// <param name="unbanRequestId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s unban requests. This ID must match the user ID in the user access token.</param>
        /// <param name="status">Resolution status.       * approved * denied</param>
        /// <param name="resolutionText">Message supplied by the unban request resolver. The message is limited to a maximum of 500 characters. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResolveUnbanRequestsApiResponse"/>&gt;</returns>
        Task<IResolveUnbanRequestsApiResponse> ResolveUnbanRequestsAsync(string broadcasterId, string moderatorId, string unbanRequestId, string status, Option<string> resolutionText = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// NEW Resolves an unban request by approving or denying it.
        /// </summary>
        /// <remarks>
        /// NEW Resolves an unban request by approving or denying it.  __Authorization:__  * Requires a user access token that includes the **moderator:manage:unban\\_requests** scope. * Query parameter &#x60;moderator_id&#x60; must match the &#x60;user_id&#x60; in the[user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose channel is approving or denying the unban request.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s unban requests. This ID must match the user ID in the user access token.</param>
        /// <param name="unbanRequestId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s unban requests. This ID must match the user ID in the user access token.</param>
        /// <param name="status">Resolution status.       * approved * denied</param>
        /// <param name="resolutionText">Message supplied by the unban request resolver. The message is limited to a maximum of 500 characters. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResolveUnbanRequestsApiResponse"/>?&gt;</returns>
        Task<IResolveUnbanRequestsApiResponse?> ResolveUnbanRequestsOrDefaultAsync(string broadcasterId, string moderatorId, string unbanRequestId, string status, Option<string> resolutionText = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Removes the ban or timeout that was placed on the specified user.
        /// </summary>
        /// <remarks>
        /// Removes the ban or timeout that was placed on the specified user.  To ban a user, see [Ban user](https://dev.twitch.tv/docs/api/reference#ban-user).  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\\_users** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat room the user is banned from chatting in.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="userId">The ID of the user to remove the ban or timeout from.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUnbanUserApiResponse"/>&gt;</returns>
        Task<IUnbanUserApiResponse> UnbanUserAsync(string broadcasterId, string moderatorId, string userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Removes the ban or timeout that was placed on the specified user.
        /// </summary>
        /// <remarks>
        /// Removes the ban or timeout that was placed on the specified user.  To ban a user, see [Ban user](https://dev.twitch.tv/docs/api/reference#ban-user).  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\\_users** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat room the user is banned from chatting in.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="userId">The ID of the user to remove the ban or timeout from.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUnbanUserApiResponse"/>?&gt;</returns>
        Task<IUnbanUserApiResponse?> UnbanUserOrDefaultAsync(string broadcasterId, string moderatorId, string userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the broadcaster’s AutoMod settings.
        /// </summary>
        /// <remarks>
        /// Updates the broadcaster’s AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod\\_settings** scope.  __Request Body:__  Because PUT is an overwrite operation, you must include all the fields that you want set after the operation completes. Typically, you’ll send a GET request, update the fields you want to change, and pass that object in the PUT request.  You may set either &#x60;overall_level&#x60; or the individual settings like &#x60;aggression&#x60;, but not both.  Setting &#x60;overall_level&#x60; applies default values to the individual settings. However, setting &#x60;overall_level&#x60; to 4 does not necessarily mean that it applies 4 to all the individual settings. Instead, it applies a set of recommended defaults to the rest of the settings. For example, if you set &#x60;overall_level&#x60; to 2, Twitch provides some filtering on discrimination and sexual content, but more filtering on hostility (see the first example response).  If &#x60;overall_level&#x60; is currently set and you update &#x60;swearing&#x60; to 3, &#x60;overall_level&#x60; will be set to **null** and all settings other than &#x60;swearing&#x60; will be set to 0\\. The same is true if individual settings are set and you update &#x60;overall_level&#x60; to 3 — all the individual settings are updated to reflect the default level.  Note that if you set all the individual settings to values that match what &#x60;overall_level&#x60; would have set them to, Twitch changes AutoMod to use the default AutoMod level instead of using the individual settings.  Valid values for all levels are from 0 (no filtering) through 4 (most aggressive filtering). These levels affect how aggressively AutoMod holds back messages for moderators to review before they appear in chat or are denied (not shown).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose AutoMod settings you want to update.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="updateAutoModSettingsBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateAutomodSettingsApiResponse"/>&gt;</returns>
        Task<IUpdateAutomodSettingsApiResponse> UpdateAutomodSettingsAsync(string broadcasterId, string moderatorId, Option<UpdateAutoModSettingsBody> updateAutoModSettingsBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the broadcaster’s AutoMod settings.
        /// </summary>
        /// <remarks>
        /// Updates the broadcaster’s AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod\\_settings** scope.  __Request Body:__  Because PUT is an overwrite operation, you must include all the fields that you want set after the operation completes. Typically, you’ll send a GET request, update the fields you want to change, and pass that object in the PUT request.  You may set either &#x60;overall_level&#x60; or the individual settings like &#x60;aggression&#x60;, but not both.  Setting &#x60;overall_level&#x60; applies default values to the individual settings. However, setting &#x60;overall_level&#x60; to 4 does not necessarily mean that it applies 4 to all the individual settings. Instead, it applies a set of recommended defaults to the rest of the settings. For example, if you set &#x60;overall_level&#x60; to 2, Twitch provides some filtering on discrimination and sexual content, but more filtering on hostility (see the first example response).  If &#x60;overall_level&#x60; is currently set and you update &#x60;swearing&#x60; to 3, &#x60;overall_level&#x60; will be set to **null** and all settings other than &#x60;swearing&#x60; will be set to 0\\. The same is true if individual settings are set and you update &#x60;overall_level&#x60; to 3 — all the individual settings are updated to reflect the default level.  Note that if you set all the individual settings to values that match what &#x60;overall_level&#x60; would have set them to, Twitch changes AutoMod to use the default AutoMod level instead of using the individual settings.  Valid values for all levels are from 0 (no filtering) through 4 (most aggressive filtering). These levels affect how aggressively AutoMod holds back messages for moderators to review before they appear in chat or are denied (not shown).
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose AutoMod settings you want to update.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="updateAutoModSettingsBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateAutomodSettingsApiResponse"/>?&gt;</returns>
        Task<IUpdateAutomodSettingsApiResponse?> UpdateAutomodSettingsOrDefaultAsync(string broadcasterId, string moderatorId, Option<UpdateAutoModSettingsBody> updateAutoModSettingsBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Activates or deactivates the broadcaster’s Shield Mode.
        /// </summary>
        /// <remarks>
        /// Activates or deactivates the broadcaster’s Shield Mode.  Twitch’s Shield Mode feature is like a panic button that broadcasters can push to protect themselves from chat abuse coming from one or more accounts. When activated, Shield Mode applies the overrides that the broadcaster configured in the Twitch UX. If the broadcaster hasn’t configured Shield Mode, it applies default overrides.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shield\\_mode** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose Shield Mode you want to activate or deactivate.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that is one of the broadcaster’s moderators. This ID must match the user ID in the access token.</param>
        /// <param name="updateShieldModeStatusBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateShieldModeStatusApiResponse"/>&gt;</returns>
        Task<IUpdateShieldModeStatusApiResponse> UpdateShieldModeStatusAsync(string broadcasterId, string moderatorId, Option<UpdateShieldModeStatusBody> updateShieldModeStatusBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Activates or deactivates the broadcaster’s Shield Mode.
        /// </summary>
        /// <remarks>
        /// Activates or deactivates the broadcaster’s Shield Mode.  Twitch’s Shield Mode feature is like a panic button that broadcasters can push to protect themselves from chat abuse coming from one or more accounts. When activated, Shield Mode applies the overrides that the broadcaster configured in the Twitch UX. If the broadcaster hasn’t configured Shield Mode, it applies default overrides.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shield\\_mode** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose Shield Mode you want to activate or deactivate.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that is one of the broadcaster’s moderators. This ID must match the user ID in the access token.</param>
        /// <param name="updateShieldModeStatusBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateShieldModeStatusApiResponse"/>?&gt;</returns>
        Task<IUpdateShieldModeStatusApiResponse?> UpdateShieldModeStatusOrDefaultAsync(string broadcasterId, string moderatorId, Option<UpdateShieldModeStatusBody> updateShieldModeStatusBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// NEW Warns a user in the specified broadcaster’s chat room, preventing them from chat interaction until the warning is acknowledged.
        /// </summary>
        /// <remarks>
        /// NEW Warns a user in the specified broadcaster’s chat room, preventing them from chat interaction until the warning is acknowledged. New warnings can be issued to a user when they already have a warning in the channel (new warning will replace old warning).  __Authorization:__  Requires a user access token that includes the **moderator:manage:warnings** scope. Query parameter &#x60;moderator_id&#x60; must match the &#x60;user_id&#x60; in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the channel in which the warning will take effect.</param>
        /// <param name="moderatorId">The ID of the twitch user who requested the warning.</param>
        /// <param name="warnChatUserBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWarnChatUserApiResponse"/>&gt;</returns>
        Task<IWarnChatUserApiResponse> WarnChatUserAsync(string broadcasterId, string moderatorId, Option<WarnChatUserBody> warnChatUserBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// NEW Warns a user in the specified broadcaster’s chat room, preventing them from chat interaction until the warning is acknowledged.
        /// </summary>
        /// <remarks>
        /// NEW Warns a user in the specified broadcaster’s chat room, preventing them from chat interaction until the warning is acknowledged. New warnings can be issued to a user when they already have a warning in the channel (new warning will replace old warning).  __Authorization:__  Requires a user access token that includes the **moderator:manage:warnings** scope. Query parameter &#x60;moderator_id&#x60; must match the &#x60;user_id&#x60; in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </remarks>
        /// <param name="broadcasterId">The ID of the channel in which the warning will take effect.</param>
        /// <param name="moderatorId">The ID of the twitch user who requested the warning.</param>
        /// <param name="warnChatUserBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWarnChatUserApiResponse"/>?&gt;</returns>
        Task<IWarnChatUserApiResponse?> WarnChatUserOrDefaultAsync(string broadcasterId, string moderatorId, Option<WarnChatUserBody> warnChatUserBody = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAddBlockedTermApiResponse"/>
    /// </summary>
    public interface IAddBlockedTermApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.AddBlockedTermResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IAddChannelModeratorApiResponse"/>
    /// </summary>
    public interface IAddChannelModeratorApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IAddChannelVipApiResponse"/>
    /// </summary>
    public interface IAddChannelVipApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 425 TooEarly
        /// </summary>
        /// <returns></returns>
        bool IsTooEarly { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IBanUserApiResponse"/>
    /// </summary>
    public interface IBanUserApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.BanUserResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="ICheckAutomodStatusApiResponse"/>
    /// </summary>
    public interface ICheckAutomodStatusApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.CheckAutoModStatusResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteChatMessagesApiResponse"/>
    /// </summary>
    public interface IDeleteChatMessagesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetAutomodSettingsApiResponse"/>
    /// </summary>
    public interface IGetAutomodSettingsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetAutoModSettingsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IGetBannedUsersApiResponse"/>
    /// </summary>
    public interface IGetBannedUsersApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetBannedUsersResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetBlockedTermsApiResponse"/>
    /// </summary>
    public interface IGetBlockedTermsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetBlockedTermsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IGetModeratedChannelsApiResponse"/>
    /// </summary>
    public interface IGetModeratedChannelsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetModeratedChannelsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetModeratorsApiResponse"/>
    /// </summary>
    public interface IGetModeratorsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetModeratorsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetShieldModeStatusApiResponse"/>
    /// </summary>
    public interface IGetShieldModeStatusApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetShieldModeStatusResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IGetUnbanRequestsApiResponse"/>
    /// </summary>
    public interface IGetUnbanRequestsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetUnbanRequestsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetVipsApiResponse"/>
    /// </summary>
    public interface IGetVipsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetVIPsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IManageHeldAutomodMessagesApiResponse"/>
    /// </summary>
    public interface IManageHeldAutomodMessagesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveBlockedTermApiResponse"/>
    /// </summary>
    public interface IRemoveBlockedTermApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveChannelModeratorApiResponse"/>
    /// </summary>
    public interface IRemoveChannelModeratorApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveChannelVipApiResponse"/>
    /// </summary>
    public interface IRemoveChannelVipApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IResolveUnbanRequestsApiResponse"/>
    /// </summary>
    public interface IResolveUnbanRequestsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.ResolveUnbanRequestsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IUnbanUserApiResponse"/>
    /// </summary>
    public interface IUnbanUserApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateAutomodSettingsApiResponse"/>
    /// </summary>
    public interface IUpdateAutomodSettingsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateAutoModSettingsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateShieldModeStatusApiResponse"/>
    /// </summary>
    public interface IUpdateShieldModeStatusApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateShieldModeStatusResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IWarnChatUserApiResponse"/>
    /// </summary>
    public interface IWarnChatUserApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.WarnChatUserResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ModerationApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddBlockedTerm;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddBlockedTerm;

        internal void ExecuteOnAddBlockedTerm(ModerationApi.AddBlockedTermApiResponse apiResponse)
        {
            OnAddBlockedTerm?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddBlockedTerm(Exception exception)
        {
            OnErrorAddBlockedTerm?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddChannelModerator;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddChannelModerator;

        internal void ExecuteOnAddChannelModerator(ModerationApi.AddChannelModeratorApiResponse apiResponse)
        {
            OnAddChannelModerator?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddChannelModerator(Exception exception)
        {
            OnErrorAddChannelModerator?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddChannelVip;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddChannelVip;

        internal void ExecuteOnAddChannelVip(ModerationApi.AddChannelVipApiResponse apiResponse)
        {
            OnAddChannelVip?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddChannelVip(Exception exception)
        {
            OnErrorAddChannelVip?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnBanUser;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorBanUser;

        internal void ExecuteOnBanUser(ModerationApi.BanUserApiResponse apiResponse)
        {
            OnBanUser?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBanUser(Exception exception)
        {
            OnErrorBanUser?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCheckAutomodStatus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCheckAutomodStatus;

        internal void ExecuteOnCheckAutomodStatus(ModerationApi.CheckAutomodStatusApiResponse apiResponse)
        {
            OnCheckAutomodStatus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCheckAutomodStatus(Exception exception)
        {
            OnErrorCheckAutomodStatus?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteChatMessages;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteChatMessages;

        internal void ExecuteOnDeleteChatMessages(ModerationApi.DeleteChatMessagesApiResponse apiResponse)
        {
            OnDeleteChatMessages?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteChatMessages(Exception exception)
        {
            OnErrorDeleteChatMessages?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetAutomodSettings;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetAutomodSettings;

        internal void ExecuteOnGetAutomodSettings(ModerationApi.GetAutomodSettingsApiResponse apiResponse)
        {
            OnGetAutomodSettings?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAutomodSettings(Exception exception)
        {
            OnErrorGetAutomodSettings?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetBannedUsers;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetBannedUsers;

        internal void ExecuteOnGetBannedUsers(ModerationApi.GetBannedUsersApiResponse apiResponse)
        {
            OnGetBannedUsers?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetBannedUsers(Exception exception)
        {
            OnErrorGetBannedUsers?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetBlockedTerms;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetBlockedTerms;

        internal void ExecuteOnGetBlockedTerms(ModerationApi.GetBlockedTermsApiResponse apiResponse)
        {
            OnGetBlockedTerms?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetBlockedTerms(Exception exception)
        {
            OnErrorGetBlockedTerms?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetModeratedChannels;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetModeratedChannels;

        internal void ExecuteOnGetModeratedChannels(ModerationApi.GetModeratedChannelsApiResponse apiResponse)
        {
            OnGetModeratedChannels?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetModeratedChannels(Exception exception)
        {
            OnErrorGetModeratedChannels?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetModerators;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetModerators;

        internal void ExecuteOnGetModerators(ModerationApi.GetModeratorsApiResponse apiResponse)
        {
            OnGetModerators?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetModerators(Exception exception)
        {
            OnErrorGetModerators?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetShieldModeStatus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetShieldModeStatus;

        internal void ExecuteOnGetShieldModeStatus(ModerationApi.GetShieldModeStatusApiResponse apiResponse)
        {
            OnGetShieldModeStatus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetShieldModeStatus(Exception exception)
        {
            OnErrorGetShieldModeStatus?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetUnbanRequests;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetUnbanRequests;

        internal void ExecuteOnGetUnbanRequests(ModerationApi.GetUnbanRequestsApiResponse apiResponse)
        {
            OnGetUnbanRequests?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetUnbanRequests(Exception exception)
        {
            OnErrorGetUnbanRequests?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetVips;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetVips;

        internal void ExecuteOnGetVips(ModerationApi.GetVipsApiResponse apiResponse)
        {
            OnGetVips?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetVips(Exception exception)
        {
            OnErrorGetVips?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnManageHeldAutomodMessages;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorManageHeldAutomodMessages;

        internal void ExecuteOnManageHeldAutomodMessages(ModerationApi.ManageHeldAutomodMessagesApiResponse apiResponse)
        {
            OnManageHeldAutomodMessages?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorManageHeldAutomodMessages(Exception exception)
        {
            OnErrorManageHeldAutomodMessages?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveBlockedTerm;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveBlockedTerm;

        internal void ExecuteOnRemoveBlockedTerm(ModerationApi.RemoveBlockedTermApiResponse apiResponse)
        {
            OnRemoveBlockedTerm?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveBlockedTerm(Exception exception)
        {
            OnErrorRemoveBlockedTerm?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveChannelModerator;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveChannelModerator;

        internal void ExecuteOnRemoveChannelModerator(ModerationApi.RemoveChannelModeratorApiResponse apiResponse)
        {
            OnRemoveChannelModerator?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveChannelModerator(Exception exception)
        {
            OnErrorRemoveChannelModerator?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveChannelVip;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveChannelVip;

        internal void ExecuteOnRemoveChannelVip(ModerationApi.RemoveChannelVipApiResponse apiResponse)
        {
            OnRemoveChannelVip?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveChannelVip(Exception exception)
        {
            OnErrorRemoveChannelVip?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnResolveUnbanRequests;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorResolveUnbanRequests;

        internal void ExecuteOnResolveUnbanRequests(ModerationApi.ResolveUnbanRequestsApiResponse apiResponse)
        {
            OnResolveUnbanRequests?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorResolveUnbanRequests(Exception exception)
        {
            OnErrorResolveUnbanRequests?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUnbanUser;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUnbanUser;

        internal void ExecuteOnUnbanUser(ModerationApi.UnbanUserApiResponse apiResponse)
        {
            OnUnbanUser?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUnbanUser(Exception exception)
        {
            OnErrorUnbanUser?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateAutomodSettings;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateAutomodSettings;

        internal void ExecuteOnUpdateAutomodSettings(ModerationApi.UpdateAutomodSettingsApiResponse apiResponse)
        {
            OnUpdateAutomodSettings?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateAutomodSettings(Exception exception)
        {
            OnErrorUpdateAutomodSettings?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateShieldModeStatus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateShieldModeStatus;

        internal void ExecuteOnUpdateShieldModeStatus(ModerationApi.UpdateShieldModeStatusApiResponse apiResponse)
        {
            OnUpdateShieldModeStatus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateShieldModeStatus(Exception exception)
        {
            OnErrorUpdateShieldModeStatus?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnWarnChatUser;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorWarnChatUser;

        internal void ExecuteOnWarnChatUser(ModerationApi.WarnChatUserApiResponse apiResponse)
        {
            OnWarnChatUser?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorWarnChatUser(Exception exception)
        {
            OnErrorWarnChatUser?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ModerationApi : IModerationApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ModerationApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ModerationApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ModerationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ModerationApi(ILogger<ModerationApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ModerationApiEvents moderationApiEvents,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ModerationApi>();
            HttpClient = httpClient;
            Events = moderationApiEvents;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatAddBlockedTerm(ref string broadcasterId, ref string moderatorId, Option<AddBlockedTermBody> addBlockedTermBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="addBlockedTermBody"></param>
        /// <returns></returns>
        private void ValidateAddBlockedTerm(string broadcasterId, string moderatorId, Option<AddBlockedTermBody> addBlockedTermBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (addBlockedTermBody.IsSet && addBlockedTermBody.Value == null)
                throw new ArgumentNullException(nameof(addBlockedTermBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="addBlockedTermBody"></param>
        private void AfterAddBlockedTermDefaultImplementation(IAddBlockedTermApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<AddBlockedTermBody> addBlockedTermBody)
        {
            bool suppressDefaultLog = false;
            AfterAddBlockedTerm(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, addBlockedTermBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="addBlockedTermBody"></param>
        partial void AfterAddBlockedTerm(ref bool suppressDefaultLog, IAddBlockedTermApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<AddBlockedTermBody> addBlockedTermBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="addBlockedTermBody"></param>
        private void OnErrorAddBlockedTermDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<AddBlockedTermBody> addBlockedTermBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddBlockedTerm(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, addBlockedTermBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="addBlockedTermBody"></param>
        partial void OnErrorAddBlockedTerm(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<AddBlockedTermBody> addBlockedTermBody);

        /// <summary>
        /// Adds a word or phrase to the broadcaster’s list of blocked terms. Adds a word or phrase to the broadcaster’s list of blocked terms. These are the terms that the broadcaster doesn’t want used in their chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\\_terms** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the list of blocked terms.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="addBlockedTermBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddBlockedTermApiResponse"/>&gt;</returns>
        public async Task<IAddBlockedTermApiResponse?> AddBlockedTermOrDefaultAsync(string broadcasterId, string moderatorId, Option<AddBlockedTermBody> addBlockedTermBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddBlockedTermAsync(broadcasterId, moderatorId, addBlockedTermBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Adds a word or phrase to the broadcaster’s list of blocked terms. Adds a word or phrase to the broadcaster’s list of blocked terms. These are the terms that the broadcaster doesn’t want used in their chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\\_terms** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the list of blocked terms.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="addBlockedTermBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddBlockedTermApiResponse"/>&gt;</returns>
        public async Task<IAddBlockedTermApiResponse> AddBlockedTermAsync(string broadcasterId, string moderatorId, Option<AddBlockedTermBody> addBlockedTermBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddBlockedTerm(broadcasterId, moderatorId, addBlockedTermBody);

                FormatAddBlockedTerm(ref broadcasterId, ref moderatorId, addBlockedTermBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/blocked_terms"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/blocked_terms");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (addBlockedTermBody.IsSet)
                        httpRequestMessageLocalVar.Content = (addBlockedTermBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(addBlockedTermBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<AddBlockedTermApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddBlockedTermApiResponse>();

                        AddBlockedTermApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/blocked_terms", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAddBlockedTermDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, addBlockedTermBody);

                        Events.ExecuteOnAddBlockedTerm(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddBlockedTermDefaultImplementation(e, "/moderation/blocked_terms", uriBuilderLocalVar.Path, broadcasterId, moderatorId, addBlockedTermBody);
                Events.ExecuteOnErrorAddBlockedTerm(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddBlockedTermApiResponse"/>
        /// </summary>
        public partial class AddBlockedTermApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IAddBlockedTermApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddBlockedTermApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddBlockedTermApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddBlockedTermApiResponse(ILogger<AddBlockedTermApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.AddBlockedTermResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.AddBlockedTermResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.AddBlockedTermResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAddChannelModerator(ref string broadcasterId, ref string userId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <returns></returns>
        private void ValidateAddChannelModerator(string broadcasterId, string userId)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (userId == null)
                throw new ArgumentNullException(nameof(userId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        private void AfterAddChannelModeratorDefaultImplementation(IAddChannelModeratorApiResponse apiResponseLocalVar, string broadcasterId, string userId)
        {
            bool suppressDefaultLog = false;
            AfterAddChannelModerator(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, userId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        partial void AfterAddChannelModerator(ref bool suppressDefaultLog, IAddChannelModeratorApiResponse apiResponseLocalVar, string broadcasterId, string userId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        private void OnErrorAddChannelModeratorDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string userId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddChannelModerator(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, userId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        partial void OnErrorAddChannelModerator(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string userId);

        /// <summary>
        /// Adds a moderator to the broadcaster’s chat room. Adds a moderator to the broadcaster’s chat room.  **Rate Limits**: The broadcaster may add a maximum of 10 moderators within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room. This ID must match the user ID in the access token.</param>
        /// <param name="userId">The ID of the user to add as a moderator in the broadcaster’s chat room.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddChannelModeratorApiResponse"/>&gt;</returns>
        public async Task<IAddChannelModeratorApiResponse?> AddChannelModeratorOrDefaultAsync(string broadcasterId, string userId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddChannelModeratorAsync(broadcasterId, userId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Adds a moderator to the broadcaster’s chat room. Adds a moderator to the broadcaster’s chat room.  **Rate Limits**: The broadcaster may add a maximum of 10 moderators within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room. This ID must match the user ID in the access token.</param>
        /// <param name="userId">The ID of the user to add as a moderator in the broadcaster’s chat room.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddChannelModeratorApiResponse"/>&gt;</returns>
        public async Task<IAddChannelModeratorApiResponse> AddChannelModeratorAsync(string broadcasterId, string userId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddChannelModerator(broadcasterId, userId);

                FormatAddChannelModerator(ref broadcasterId, ref userId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/moderators"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/moderators");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<AddChannelModeratorApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddChannelModeratorApiResponse>();

                        AddChannelModeratorApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/moderators", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAddChannelModeratorDefaultImplementation(apiResponseLocalVar, broadcasterId, userId);

                        Events.ExecuteOnAddChannelModerator(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddChannelModeratorDefaultImplementation(e, "/moderation/moderators", uriBuilderLocalVar.Path, broadcasterId, userId);
                Events.ExecuteOnErrorAddChannelModerator(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddChannelModeratorApiResponse"/>
        /// </summary>
        public partial class AddChannelModeratorApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IAddChannelModeratorApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddChannelModeratorApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddChannelModeratorApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddChannelModeratorApiResponse(ILogger<AddChannelModeratorApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAddChannelVip(ref string userId, ref string broadcasterId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="userId"></param>
        /// <param name="broadcasterId"></param>
        /// <returns></returns>
        private void ValidateAddChannelVip(string userId, string broadcasterId)
        {
            if (userId == null)
                throw new ArgumentNullException(nameof(userId));

            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="broadcasterId"></param>
        private void AfterAddChannelVipDefaultImplementation(IAddChannelVipApiResponse apiResponseLocalVar, string userId, string broadcasterId)
        {
            bool suppressDefaultLog = false;
            AfterAddChannelVip(ref suppressDefaultLog, apiResponseLocalVar, userId, broadcasterId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="broadcasterId"></param>
        partial void AfterAddChannelVip(ref bool suppressDefaultLog, IAddChannelVipApiResponse apiResponseLocalVar, string userId, string broadcasterId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="broadcasterId"></param>
        private void OnErrorAddChannelVipDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userId, string broadcasterId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddChannelVip(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, userId, broadcasterId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="broadcasterId"></param>
        partial void OnErrorAddChannelVip(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userId, string broadcasterId);

        /// <summary>
        /// Adds the specified user as a VIP in the broadcaster’s channel. Adds the specified user as a VIP in the broadcaster’s channel.  **Rate Limits**: The broadcaster may add a maximum of 10 VIPs within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
        /// </summary>
        /// <param name="userId">The ID of the user to give VIP status to.</param>
        /// <param name="broadcasterId">The ID of the broadcaster that’s adding the user as a VIP. This ID must match the user ID in the access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddChannelVipApiResponse"/>&gt;</returns>
        public async Task<IAddChannelVipApiResponse?> AddChannelVipOrDefaultAsync(string userId, string broadcasterId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddChannelVipAsync(userId, broadcasterId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Adds the specified user as a VIP in the broadcaster’s channel. Adds the specified user as a VIP in the broadcaster’s channel.  **Rate Limits**: The broadcaster may add a maximum of 10 VIPs within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The ID of the user to give VIP status to.</param>
        /// <param name="broadcasterId">The ID of the broadcaster that’s adding the user as a VIP. This ID must match the user ID in the access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddChannelVipApiResponse"/>&gt;</returns>
        public async Task<IAddChannelVipApiResponse> AddChannelVipAsync(string userId, string broadcasterId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddChannelVip(userId, broadcasterId);

                FormatAddChannelVip(ref userId, ref broadcasterId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/channels/vips"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/channels/vips");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId);
                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<AddChannelVipApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddChannelVipApiResponse>();

                        AddChannelVipApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channels/vips", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAddChannelVipDefaultImplementation(apiResponseLocalVar, userId, broadcasterId);

                        Events.ExecuteOnAddChannelVip(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddChannelVipDefaultImplementation(e, "/channels/vips", uriBuilderLocalVar.Path, userId, broadcasterId);
                Events.ExecuteOnErrorAddChannelVip(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddChannelVipApiResponse"/>
        /// </summary>
        public partial class AddChannelVipApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IAddChannelVipApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddChannelVipApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddChannelVipApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddChannelVipApiResponse(ILogger<AddChannelVipApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 425 TooEarly
            /// </summary>
            /// <returns></returns>
            public bool IsTooEarly => 425 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatBanUser(ref string broadcasterId, ref string moderatorId, Option<BanUserBody> banUserBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="banUserBody"></param>
        /// <returns></returns>
        private void ValidateBanUser(string broadcasterId, string moderatorId, Option<BanUserBody> banUserBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (banUserBody.IsSet && banUserBody.Value == null)
                throw new ArgumentNullException(nameof(banUserBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="banUserBody"></param>
        private void AfterBanUserDefaultImplementation(IBanUserApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<BanUserBody> banUserBody)
        {
            bool suppressDefaultLog = false;
            AfterBanUser(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, banUserBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="banUserBody"></param>
        partial void AfterBanUser(ref bool suppressDefaultLog, IBanUserApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<BanUserBody> banUserBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="banUserBody"></param>
        private void OnErrorBanUserDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<BanUserBody> banUserBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorBanUser(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, banUserBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="banUserBody"></param>
        partial void OnErrorBanUser(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<BanUserBody> banUserBody);

        /// <summary>
        /// Bans a user from participating in a broadcaster’s chat room or puts them in a timeout. Bans a user from participating in the specified broadcaster’s chat room or puts them in a timeout.  For information about banning or putting users in a timeout, see [Ban a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheBanFeature) and [Timeout a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheTimeoutFeature).  If the user is currently in a timeout, you can call this endpoint to change the duration of the timeout or ban them altogether. If the user is currently banned, you cannot call this method to put them in a timeout instead.  To remove a ban or end a timeout, see [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user).  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\\_users** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat room the user is being banned from.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="banUserBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBanUserApiResponse"/>&gt;</returns>
        public async Task<IBanUserApiResponse?> BanUserOrDefaultAsync(string broadcasterId, string moderatorId, Option<BanUserBody> banUserBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BanUserAsync(broadcasterId, moderatorId, banUserBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Bans a user from participating in a broadcaster’s chat room or puts them in a timeout. Bans a user from participating in the specified broadcaster’s chat room or puts them in a timeout.  For information about banning or putting users in a timeout, see [Ban a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheBanFeature) and [Timeout a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheTimeoutFeature).  If the user is currently in a timeout, you can call this endpoint to change the duration of the timeout or ban them altogether. If the user is currently banned, you cannot call this method to put them in a timeout instead.  To remove a ban or end a timeout, see [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user).  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\\_users** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat room the user is being banned from.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="banUserBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBanUserApiResponse"/>&gt;</returns>
        public async Task<IBanUserApiResponse> BanUserAsync(string broadcasterId, string moderatorId, Option<BanUserBody> banUserBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateBanUser(broadcasterId, moderatorId, banUserBody);

                FormatBanUser(ref broadcasterId, ref moderatorId, banUserBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/bans"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/bans");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (banUserBody.IsSet)
                        httpRequestMessageLocalVar.Content = (banUserBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(banUserBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<BanUserApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BanUserApiResponse>();

                        BanUserApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/bans", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterBanUserDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, banUserBody);

                        Events.ExecuteOnBanUser(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBanUserDefaultImplementation(e, "/moderation/bans", uriBuilderLocalVar.Path, broadcasterId, moderatorId, banUserBody);
                Events.ExecuteOnErrorBanUser(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BanUserApiResponse"/>
        /// </summary>
        public partial class BanUserApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IBanUserApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BanUserApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BanUserApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BanUserApiResponse(ILogger<BanUserApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.BanUserResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.BanUserResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.BanUserResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCheckAutomodStatus(ref string broadcasterId, Option<CheckAutoModStatusBody> checkAutoModStatusBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="checkAutoModStatusBody"></param>
        /// <returns></returns>
        private void ValidateCheckAutomodStatus(string broadcasterId, Option<CheckAutoModStatusBody> checkAutoModStatusBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (checkAutoModStatusBody.IsSet && checkAutoModStatusBody.Value == null)
                throw new ArgumentNullException(nameof(checkAutoModStatusBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="checkAutoModStatusBody"></param>
        private void AfterCheckAutomodStatusDefaultImplementation(ICheckAutomodStatusApiResponse apiResponseLocalVar, string broadcasterId, Option<CheckAutoModStatusBody> checkAutoModStatusBody)
        {
            bool suppressDefaultLog = false;
            AfterCheckAutomodStatus(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, checkAutoModStatusBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="checkAutoModStatusBody"></param>
        partial void AfterCheckAutomodStatus(ref bool suppressDefaultLog, ICheckAutomodStatusApiResponse apiResponseLocalVar, string broadcasterId, Option<CheckAutoModStatusBody> checkAutoModStatusBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="checkAutoModStatusBody"></param>
        private void OnErrorCheckAutomodStatusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<CheckAutoModStatusBody> checkAutoModStatusBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCheckAutomodStatus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, checkAutoModStatusBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="checkAutoModStatusBody"></param>
        partial void OnErrorCheckAutomodStatus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<CheckAutoModStatusBody> checkAutoModStatusBody);

        /// <summary>
        /// Checks whether AutoMod would flag the specified message for review. Checks whether AutoMod would flag the specified message for review.  AutoMod is a moderation tool that holds inappropriate or harassing chat messages for moderators to review. Moderators approve or deny the messages that AutoMod flags; only approved messages are released to chat. AutoMod detects misspellings and evasive language automatically. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).  **Rate Limits**: Rates are limited per channel based on the account type rather than per access token.  | Account type | Limit per minute | Limit per hour | | - | - | - | | Normal | 5 | 50 | | Affiliate | 10 | 100 | | Partner | 30 | 300 |   The above limits are in addition to the standard [Twitch API rate limits](https://dev.twitch.tv/docs/api/guide#twitch-rate-limits). The rate limit headers in the response represent the Twitch rate limits and not the above limits.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose AutoMod settings and list of blocked terms are used to check the message. This ID must match the user ID in the access token.</param>
        /// <param name="checkAutoModStatusBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckAutomodStatusApiResponse"/>&gt;</returns>
        public async Task<ICheckAutomodStatusApiResponse?> CheckAutomodStatusOrDefaultAsync(string broadcasterId, Option<CheckAutoModStatusBody> checkAutoModStatusBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CheckAutomodStatusAsync(broadcasterId, checkAutoModStatusBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Checks whether AutoMod would flag the specified message for review. Checks whether AutoMod would flag the specified message for review.  AutoMod is a moderation tool that holds inappropriate or harassing chat messages for moderators to review. Moderators approve or deny the messages that AutoMod flags; only approved messages are released to chat. AutoMod detects misspellings and evasive language automatically. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).  **Rate Limits**: Rates are limited per channel based on the account type rather than per access token.  | Account type | Limit per minute | Limit per hour | | - | - | - | | Normal | 5 | 50 | | Affiliate | 10 | 100 | | Partner | 30 | 300 |   The above limits are in addition to the standard [Twitch API rate limits](https://dev.twitch.tv/docs/api/guide#twitch-rate-limits). The rate limit headers in the response represent the Twitch rate limits and not the above limits.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose AutoMod settings and list of blocked terms are used to check the message. This ID must match the user ID in the access token.</param>
        /// <param name="checkAutoModStatusBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICheckAutomodStatusApiResponse"/>&gt;</returns>
        public async Task<ICheckAutomodStatusApiResponse> CheckAutomodStatusAsync(string broadcasterId, Option<CheckAutoModStatusBody> checkAutoModStatusBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCheckAutomodStatus(broadcasterId, checkAutoModStatusBody);

                FormatCheckAutomodStatus(ref broadcasterId, checkAutoModStatusBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/enforcements/status"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/enforcements/status");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (checkAutoModStatusBody.IsSet)
                        httpRequestMessageLocalVar.Content = (checkAutoModStatusBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(checkAutoModStatusBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CheckAutomodStatusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CheckAutomodStatusApiResponse>();

                        CheckAutomodStatusApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/enforcements/status", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCheckAutomodStatusDefaultImplementation(apiResponseLocalVar, broadcasterId, checkAutoModStatusBody);

                        Events.ExecuteOnCheckAutomodStatus(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCheckAutomodStatusDefaultImplementation(e, "/moderation/enforcements/status", uriBuilderLocalVar.Path, broadcasterId, checkAutoModStatusBody);
                Events.ExecuteOnErrorCheckAutomodStatus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CheckAutomodStatusApiResponse"/>
        /// </summary>
        public partial class CheckAutomodStatusApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ICheckAutomodStatusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CheckAutomodStatusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CheckAutomodStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CheckAutomodStatusApiResponse(ILogger<CheckAutomodStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.CheckAutoModStatusResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.CheckAutoModStatusResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.CheckAutoModStatusResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteChatMessages(ref string broadcasterId, ref string moderatorId, ref Option<string> messageId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="messageId"></param>
        /// <returns></returns>
        private void ValidateDeleteChatMessages(string broadcasterId, string moderatorId, Option<string> messageId)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (messageId.IsSet && messageId.Value == null)
                throw new ArgumentNullException(nameof(messageId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="messageId"></param>
        private void AfterDeleteChatMessagesDefaultImplementation(IDeleteChatMessagesApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<string> messageId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteChatMessages(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, messageId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="messageId"></param>
        partial void AfterDeleteChatMessages(ref bool suppressDefaultLog, IDeleteChatMessagesApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<string> messageId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="messageId"></param>
        private void OnErrorDeleteChatMessagesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<string> messageId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteChatMessages(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, messageId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="messageId"></param>
        partial void OnErrorDeleteChatMessages(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<string> messageId);

        /// <summary>
        /// Removes a single chat message or all chat messages from the broadcaster’s chat room. Removes a single chat message or all chat messages from the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\\_messages** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room to remove messages from.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="messageId">The ID of the message to remove. The &#x60;id&#x60; tag in the [PRIVMSG](https://dev.twitch.tv/docs/irc/tags#privmsg-tags) tag contains the message’s ID. Restrictions:      * The message must have been created within the last 6 hours. * The message must not belong to the broadcaster. * The message must not belong to another moderator.    If not specified, the request removes all messages in the broadcaster’s chat room. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteChatMessagesApiResponse"/>&gt;</returns>
        public async Task<IDeleteChatMessagesApiResponse?> DeleteChatMessagesOrDefaultAsync(string broadcasterId, string moderatorId, Option<string> messageId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteChatMessagesAsync(broadcasterId, moderatorId, messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Removes a single chat message or all chat messages from the broadcaster’s chat room. Removes a single chat message or all chat messages from the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\\_messages** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room to remove messages from.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="messageId">The ID of the message to remove. The &#x60;id&#x60; tag in the [PRIVMSG](https://dev.twitch.tv/docs/irc/tags#privmsg-tags) tag contains the message’s ID. Restrictions:      * The message must have been created within the last 6 hours. * The message must not belong to the broadcaster. * The message must not belong to another moderator.    If not specified, the request removes all messages in the broadcaster’s chat room. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteChatMessagesApiResponse"/>&gt;</returns>
        public async Task<IDeleteChatMessagesApiResponse> DeleteChatMessagesAsync(string broadcasterId, string moderatorId, Option<string> messageId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteChatMessages(broadcasterId, moderatorId, messageId);

                FormatDeleteChatMessages(ref broadcasterId, ref moderatorId, ref messageId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/chat"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/chat");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);

                    if (messageId.IsSet)
                        parseQueryStringLocalVar["message_id"] = ClientUtils.ParameterToString(messageId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteChatMessagesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteChatMessagesApiResponse>();

                        DeleteChatMessagesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/chat", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteChatMessagesDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, messageId);

                        Events.ExecuteOnDeleteChatMessages(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteChatMessagesDefaultImplementation(e, "/moderation/chat", uriBuilderLocalVar.Path, broadcasterId, moderatorId, messageId);
                Events.ExecuteOnErrorDeleteChatMessages(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteChatMessagesApiResponse"/>
        /// </summary>
        public partial class DeleteChatMessagesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IDeleteChatMessagesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteChatMessagesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteChatMessagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteChatMessagesApiResponse(ILogger<DeleteChatMessagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAutomodSettings(ref string broadcasterId, ref string moderatorId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <returns></returns>
        private void ValidateGetAutomodSettings(string broadcasterId, string moderatorId)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        private void AfterGetAutomodSettingsDefaultImplementation(IGetAutomodSettingsApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId)
        {
            bool suppressDefaultLog = false;
            AfterGetAutomodSettings(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        partial void AfterGetAutomodSettings(ref bool suppressDefaultLog, IGetAutomodSettingsApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        private void OnErrorGetAutomodSettingsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAutomodSettings(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        partial void OnErrorGetAutomodSettings(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId);

        /// <summary>
        /// Gets the broadcaster’s AutoMod settings. Gets the broadcaster’s AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:automod\\_settings** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose AutoMod settings you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAutomodSettingsApiResponse"/>&gt;</returns>
        public async Task<IGetAutomodSettingsApiResponse?> GetAutomodSettingsOrDefaultAsync(string broadcasterId, string moderatorId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAutomodSettingsAsync(broadcasterId, moderatorId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the broadcaster’s AutoMod settings. Gets the broadcaster’s AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:automod\\_settings** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose AutoMod settings you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAutomodSettingsApiResponse"/>&gt;</returns>
        public async Task<IGetAutomodSettingsApiResponse> GetAutomodSettingsAsync(string broadcasterId, string moderatorId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAutomodSettings(broadcasterId, moderatorId);

                FormatGetAutomodSettings(ref broadcasterId, ref moderatorId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/automod/settings"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/automod/settings");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetAutomodSettingsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAutomodSettingsApiResponse>();

                        GetAutomodSettingsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/automod/settings", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetAutomodSettingsDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId);

                        Events.ExecuteOnGetAutomodSettings(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAutomodSettingsDefaultImplementation(e, "/moderation/automod/settings", uriBuilderLocalVar.Path, broadcasterId, moderatorId);
                Events.ExecuteOnErrorGetAutomodSettings(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAutomodSettingsApiResponse"/>
        /// </summary>
        public partial class GetAutomodSettingsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetAutomodSettingsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAutomodSettingsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAutomodSettingsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAutomodSettingsApiResponse(ILogger<GetAutomodSettingsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetAutoModSettingsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetAutoModSettingsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetAutoModSettingsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetBannedUsers(ref string broadcasterId, Option<List<string>> userId, ref Option<int> first, ref Option<string> after, ref Option<string> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <returns></returns>
        private void ValidateGetBannedUsers(string broadcasterId, Option<List<string>> userId, Option<string> after, Option<string> before)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (userId.IsSet && userId.Value == null)
                throw new ArgumentNullException(nameof(userId));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));

            if (before.IsSet && before.Value == null)
                throw new ArgumentNullException(nameof(before));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        private void AfterGetBannedUsersDefaultImplementation(IGetBannedUsersApiResponse apiResponseLocalVar, string broadcasterId, Option<List<string>> userId, Option<int> first, Option<string> after, Option<string> before)
        {
            bool suppressDefaultLog = false;
            AfterGetBannedUsers(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, userId, first, after, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        partial void AfterGetBannedUsers(ref bool suppressDefaultLog, IGetBannedUsersApiResponse apiResponseLocalVar, string broadcasterId, Option<List<string>> userId, Option<int> first, Option<string> after, Option<string> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        private void OnErrorGetBannedUsersDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<List<string>> userId, Option<int> first, Option<string> after, Option<string> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetBannedUsers(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, userId, first, after, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        partial void OnErrorGetBannedUsers(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<List<string>> userId, Option<int> first, Option<string> after, Option<string> before);

        /// <summary>
        /// Gets all users that the broadcaster banned or put in a timeout. Gets all users that the broadcaster banned or put in a timeout.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** or **moderator:manage:banned\\_users** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of banned users you want to get. This ID must match the user ID in the access token.</param>
        /// <param name="userId">A list of user IDs used to filter the results. To specify more than one ID, include this parameter for each user you want to get. For example, &#x60;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. You may specify a maximum of 100 IDs.      The returned list includes only those users that were banned or put in a timeout. The list is returned in the same order that you specified the IDs. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="before">The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBannedUsersApiResponse"/>&gt;</returns>
        public async Task<IGetBannedUsersApiResponse?> GetBannedUsersOrDefaultAsync(string broadcasterId, Option<List<string>> userId = default, Option<int> first = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetBannedUsersAsync(broadcasterId, userId, first, after, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets all users that the broadcaster banned or put in a timeout. Gets all users that the broadcaster banned or put in a timeout.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** or **moderator:manage:banned\\_users** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of banned users you want to get. This ID must match the user ID in the access token.</param>
        /// <param name="userId">A list of user IDs used to filter the results. To specify more than one ID, include this parameter for each user you want to get. For example, &#x60;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. You may specify a maximum of 100 IDs.      The returned list includes only those users that were banned or put in a timeout. The list is returned in the same order that you specified the IDs. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="before">The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBannedUsersApiResponse"/>&gt;</returns>
        public async Task<IGetBannedUsersApiResponse> GetBannedUsersAsync(string broadcasterId, Option<List<string>> userId = default, Option<int> first = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetBannedUsers(broadcasterId, userId, after, before);

                FormatGetBannedUsers(ref broadcasterId, userId, ref first, ref after, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/banned"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/banned");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    if (userId.IsSet)
                        parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId.Value);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetBannedUsersApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetBannedUsersApiResponse>();

                        GetBannedUsersApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/banned", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetBannedUsersDefaultImplementation(apiResponseLocalVar, broadcasterId, userId, first, after, before);

                        Events.ExecuteOnGetBannedUsers(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetBannedUsersDefaultImplementation(e, "/moderation/banned", uriBuilderLocalVar.Path, broadcasterId, userId, first, after, before);
                Events.ExecuteOnErrorGetBannedUsers(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetBannedUsersApiResponse"/>
        /// </summary>
        public partial class GetBannedUsersApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetBannedUsersApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetBannedUsersApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetBannedUsersApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetBannedUsersApiResponse(ILogger<GetBannedUsersApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetBannedUsersResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetBannedUsersResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetBannedUsersResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetBlockedTerms(ref string broadcasterId, ref string moderatorId, ref Option<int> first, ref Option<string> after);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetBlockedTerms(string broadcasterId, string moderatorId, Option<string> after)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void AfterGetBlockedTermsDefaultImplementation(IGetBlockedTermsApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLog = false;
            AfterGetBlockedTerms(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, first, after);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void AfterGetBlockedTerms(ref bool suppressDefaultLog, IGetBlockedTermsApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<int> first, Option<string> after);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void OnErrorGetBlockedTermsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetBlockedTerms(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, first, after);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void OnErrorGetBlockedTerms(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<int> first, Option<string> after);

        /// <summary>
        /// Gets the broadcaster’s list of non-private, blocked words or phrases. Gets the broadcaster’s list of non-private, blocked words or phrases. These are the terms that the broadcaster or moderator added manually or that were denied by AutoMod.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:blocked\\_terms** or **moderator:manage:blocked\\_terms** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose blocked terms you’re getting.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBlockedTermsApiResponse"/>&gt;</returns>
        public async Task<IGetBlockedTermsApiResponse?> GetBlockedTermsOrDefaultAsync(string broadcasterId, string moderatorId, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetBlockedTermsAsync(broadcasterId, moderatorId, first, after, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the broadcaster’s list of non-private, blocked words or phrases. Gets the broadcaster’s list of non-private, blocked words or phrases. These are the terms that the broadcaster or moderator added manually or that were denied by AutoMod.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:blocked\\_terms** or **moderator:manage:blocked\\_terms** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose blocked terms you’re getting.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBlockedTermsApiResponse"/>&gt;</returns>
        public async Task<IGetBlockedTermsApiResponse> GetBlockedTermsAsync(string broadcasterId, string moderatorId, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetBlockedTerms(broadcasterId, moderatorId, after);

                FormatGetBlockedTerms(ref broadcasterId, ref moderatorId, ref first, ref after);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/blocked_terms"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/blocked_terms");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetBlockedTermsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetBlockedTermsApiResponse>();

                        GetBlockedTermsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/blocked_terms", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetBlockedTermsDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, first, after);

                        Events.ExecuteOnGetBlockedTerms(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetBlockedTermsDefaultImplementation(e, "/moderation/blocked_terms", uriBuilderLocalVar.Path, broadcasterId, moderatorId, first, after);
                Events.ExecuteOnErrorGetBlockedTerms(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetBlockedTermsApiResponse"/>
        /// </summary>
        public partial class GetBlockedTermsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetBlockedTermsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetBlockedTermsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetBlockedTermsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetBlockedTermsApiResponse(ILogger<GetBlockedTermsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetBlockedTermsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetBlockedTermsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetBlockedTermsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetModeratedChannels(ref string userId, ref Option<string> after, ref Option<int> first);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetModeratedChannels(string userId, Option<string> after)
        {
            if (userId == null)
                throw new ArgumentNullException(nameof(userId));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="first"></param>
        private void AfterGetModeratedChannelsDefaultImplementation(IGetModeratedChannelsApiResponse apiResponseLocalVar, string userId, Option<string> after, Option<int> first)
        {
            bool suppressDefaultLog = false;
            AfterGetModeratedChannels(ref suppressDefaultLog, apiResponseLocalVar, userId, after, first);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="first"></param>
        partial void AfterGetModeratedChannels(ref bool suppressDefaultLog, IGetModeratedChannelsApiResponse apiResponseLocalVar, string userId, Option<string> after, Option<int> first);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="first"></param>
        private void OnErrorGetModeratedChannelsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userId, Option<string> after, Option<int> first)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetModeratedChannels(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, userId, after, first);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="first"></param>
        partial void OnErrorGetModeratedChannels(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userId, Option<string> after, Option<int> first);

        /// <summary>
        /// Gets a list of channels that the specified user has moderator privileges in. Gets a list of channels that the specified user has moderator privileges in.  __Authorization:__  * Query parameter &#x60;user_id&#x60; must match the user ID in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) * Requires OAuth Scope: &#x60;user:read:moderated_channels&#x60;
        /// </summary>
        /// <param name="userId">A user’s ID. Returns the list of channels that this user has moderator privileges in. This ID must match the user ID in the user OAuth token</param>
        /// <param name="after">The cursor used to get the next page of results. The Pagination object in the response contains the cursor’s value. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response.      Minimum page size is 1 item per page and the maximum is 100\\. The default is 20. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetModeratedChannelsApiResponse"/>&gt;</returns>
        public async Task<IGetModeratedChannelsApiResponse?> GetModeratedChannelsOrDefaultAsync(string userId, Option<string> after = default, Option<int> first = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetModeratedChannelsAsync(userId, after, first, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets a list of channels that the specified user has moderator privileges in. Gets a list of channels that the specified user has moderator privileges in.  __Authorization:__  * Query parameter &#x60;user_id&#x60; must match the user ID in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) * Requires OAuth Scope: &#x60;user:read:moderated_channels&#x60;
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">A user’s ID. Returns the list of channels that this user has moderator privileges in. This ID must match the user ID in the user OAuth token</param>
        /// <param name="after">The cursor used to get the next page of results. The Pagination object in the response contains the cursor’s value. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response.      Minimum page size is 1 item per page and the maximum is 100\\. The default is 20. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetModeratedChannelsApiResponse"/>&gt;</returns>
        public async Task<IGetModeratedChannelsApiResponse> GetModeratedChannelsAsync(string userId, Option<string> after = default, Option<int> first = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetModeratedChannels(userId, after);

                FormatGetModeratedChannels(ref userId, ref after, ref first);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/channels"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/channels");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetModeratedChannelsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetModeratedChannelsApiResponse>();

                        GetModeratedChannelsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/channels", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetModeratedChannelsDefaultImplementation(apiResponseLocalVar, userId, after, first);

                        Events.ExecuteOnGetModeratedChannels(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetModeratedChannelsDefaultImplementation(e, "/moderation/channels", uriBuilderLocalVar.Path, userId, after, first);
                Events.ExecuteOnErrorGetModeratedChannels(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetModeratedChannelsApiResponse"/>
        /// </summary>
        public partial class GetModeratedChannelsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetModeratedChannelsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetModeratedChannelsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetModeratedChannelsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetModeratedChannelsApiResponse(ILogger<GetModeratedChannelsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetModeratedChannelsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetModeratedChannelsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetModeratedChannelsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetModerators(ref string broadcasterId, Option<List<string>> userId, ref Option<string> first, ref Option<string> after);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetModerators(string broadcasterId, Option<List<string>> userId, Option<string> first, Option<string> after)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (userId.IsSet && userId.Value == null)
                throw new ArgumentNullException(nameof(userId));

            if (first.IsSet && first.Value == null)
                throw new ArgumentNullException(nameof(first));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void AfterGetModeratorsDefaultImplementation(IGetModeratorsApiResponse apiResponseLocalVar, string broadcasterId, Option<List<string>> userId, Option<string> first, Option<string> after)
        {
            bool suppressDefaultLog = false;
            AfterGetModerators(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, userId, first, after);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void AfterGetModerators(ref bool suppressDefaultLog, IGetModeratorsApiResponse apiResponseLocalVar, string broadcasterId, Option<List<string>> userId, Option<string> first, Option<string> after);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void OnErrorGetModeratorsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<List<string>> userId, Option<string> first, Option<string> after)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetModerators(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, userId, first, after);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void OnErrorGetModerators(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<List<string>> userId, Option<string> first, Option<string> after);

        /// <summary>
        /// Gets all users allowed to moderate the broadcaster’s chat room. Gets all users allowed to moderate the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope. If your app also adds and removes moderators, you can use the **channel:manage:moderators** scope instead.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of moderators you want to get. This ID must match the user ID in the access token.</param>
        /// <param name="userId">A list of user IDs used to filter the results. To specify more than one ID, include this parameter for each moderator you want to get. For example, &#x60;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. You may specify a maximum of 100 IDs.      The returned list includes only the users from the list who are moderators in the broadcaster’s channel. The list is returned in the same order as you specified the IDs. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetModeratorsApiResponse"/>&gt;</returns>
        public async Task<IGetModeratorsApiResponse?> GetModeratorsOrDefaultAsync(string broadcasterId, Option<List<string>> userId = default, Option<string> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetModeratorsAsync(broadcasterId, userId, first, after, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets all users allowed to moderate the broadcaster’s chat room. Gets all users allowed to moderate the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope. If your app also adds and removes moderators, you can use the **channel:manage:moderators** scope instead.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of moderators you want to get. This ID must match the user ID in the access token.</param>
        /// <param name="userId">A list of user IDs used to filter the results. To specify more than one ID, include this parameter for each moderator you want to get. For example, &#x60;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. You may specify a maximum of 100 IDs.      The returned list includes only the users from the list who are moderators in the broadcaster’s channel. The list is returned in the same order as you specified the IDs. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetModeratorsApiResponse"/>&gt;</returns>
        public async Task<IGetModeratorsApiResponse> GetModeratorsAsync(string broadcasterId, Option<List<string>> userId = default, Option<string> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetModerators(broadcasterId, userId, first, after);

                FormatGetModerators(ref broadcasterId, userId, ref first, ref after);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/moderators"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/moderators");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    if (userId.IsSet)
                        parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId.Value);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetModeratorsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetModeratorsApiResponse>();

                        GetModeratorsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/moderators", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetModeratorsDefaultImplementation(apiResponseLocalVar, broadcasterId, userId, first, after);

                        Events.ExecuteOnGetModerators(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetModeratorsDefaultImplementation(e, "/moderation/moderators", uriBuilderLocalVar.Path, broadcasterId, userId, first, after);
                Events.ExecuteOnErrorGetModerators(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetModeratorsApiResponse"/>
        /// </summary>
        public partial class GetModeratorsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetModeratorsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetModeratorsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetModeratorsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetModeratorsApiResponse(ILogger<GetModeratorsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetModeratorsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetModeratorsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetModeratorsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetShieldModeStatus(ref string broadcasterId, ref string moderatorId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <returns></returns>
        private void ValidateGetShieldModeStatus(string broadcasterId, string moderatorId)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        private void AfterGetShieldModeStatusDefaultImplementation(IGetShieldModeStatusApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId)
        {
            bool suppressDefaultLog = false;
            AfterGetShieldModeStatus(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        partial void AfterGetShieldModeStatus(ref bool suppressDefaultLog, IGetShieldModeStatusApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        private void OnErrorGetShieldModeStatusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetShieldModeStatus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        partial void OnErrorGetShieldModeStatus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId);

        /// <summary>
        /// Gets the broadcaster’s Shield Mode activation status. Gets the broadcaster’s Shield Mode activation status.  To receive notification when the broadcaster activates and deactivates Shield Mode, subscribe to the [channel.shield\\_mode.begin](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodebegin) and [channel.shield\\_mode.end](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodeend) subscription types.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:shield\\_mode** or **moderator:manage:shield\\_mode** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose Shield Mode activation status you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that is one of the broadcaster’s moderators. This ID must match the user ID in the access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetShieldModeStatusApiResponse"/>&gt;</returns>
        public async Task<IGetShieldModeStatusApiResponse?> GetShieldModeStatusOrDefaultAsync(string broadcasterId, string moderatorId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetShieldModeStatusAsync(broadcasterId, moderatorId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the broadcaster’s Shield Mode activation status. Gets the broadcaster’s Shield Mode activation status.  To receive notification when the broadcaster activates and deactivates Shield Mode, subscribe to the [channel.shield\\_mode.begin](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodebegin) and [channel.shield\\_mode.end](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodeend) subscription types.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:shield\\_mode** or **moderator:manage:shield\\_mode** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose Shield Mode activation status you want to get.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that is one of the broadcaster’s moderators. This ID must match the user ID in the access token.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetShieldModeStatusApiResponse"/>&gt;</returns>
        public async Task<IGetShieldModeStatusApiResponse> GetShieldModeStatusAsync(string broadcasterId, string moderatorId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetShieldModeStatus(broadcasterId, moderatorId);

                FormatGetShieldModeStatus(ref broadcasterId, ref moderatorId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/shield_mode"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/shield_mode");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetShieldModeStatusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetShieldModeStatusApiResponse>();

                        GetShieldModeStatusApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/shield_mode", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetShieldModeStatusDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId);

                        Events.ExecuteOnGetShieldModeStatus(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetShieldModeStatusDefaultImplementation(e, "/moderation/shield_mode", uriBuilderLocalVar.Path, broadcasterId, moderatorId);
                Events.ExecuteOnErrorGetShieldModeStatus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetShieldModeStatusApiResponse"/>
        /// </summary>
        public partial class GetShieldModeStatusApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetShieldModeStatusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetShieldModeStatusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetShieldModeStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetShieldModeStatusApiResponse(ILogger<GetShieldModeStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetShieldModeStatusResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetShieldModeStatusResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetShieldModeStatusResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetUnbanRequests(ref string broadcasterId, ref string moderatorId, ref string status, ref Option<string> userId, ref Option<string> after, ref Option<int> first);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="status"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetUnbanRequests(string broadcasterId, string moderatorId, string status, Option<string> userId, Option<string> after)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (status == null)
                throw new ArgumentNullException(nameof(status));

            if (userId.IsSet && userId.Value == null)
                throw new ArgumentNullException(nameof(userId));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="status"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="first"></param>
        private void AfterGetUnbanRequestsDefaultImplementation(IGetUnbanRequestsApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, string status, Option<string> userId, Option<string> after, Option<int> first)
        {
            bool suppressDefaultLog = false;
            AfterGetUnbanRequests(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, status, userId, after, first);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="status"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="first"></param>
        partial void AfterGetUnbanRequests(ref bool suppressDefaultLog, IGetUnbanRequestsApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, string status, Option<string> userId, Option<string> after, Option<int> first);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="status"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="first"></param>
        private void OnErrorGetUnbanRequestsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, string status, Option<string> userId, Option<string> after, Option<int> first)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetUnbanRequests(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, status, userId, after, first);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="status"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <param name="first"></param>
        partial void OnErrorGetUnbanRequests(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, string status, Option<string> userId, Option<string> after, Option<int> first);

        /// <summary>
        /// NEW Gets a list of unban requests for a broadcaster’s channel. NEW Gets a list of unban requests for a broadcaster’s channel.  __Authorization:__  * Requires a user access token that includes the **moderator:read:unban\\_requests** or **moderator:manage:unban\\_requests** scope. * Query parameter &#x60;moderator_id&#x60; must match the &#x60;user_id&#x60; in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose channel is receiving unban requests.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s unban requests. This ID must match the user ID in the user access token.</param>
        /// <param name="status">Filter by a status.      * pending * approved * denied * acknowledged * canceled</param>
        /// <param name="userId">The ID used to filter what unban requests are returned. (optional)</param>
        /// <param name="after">Cursor used to get next page of results. Pagination object in response contains cursor value. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in response (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUnbanRequestsApiResponse"/>&gt;</returns>
        public async Task<IGetUnbanRequestsApiResponse?> GetUnbanRequestsOrDefaultAsync(string broadcasterId, string moderatorId, string status, Option<string> userId = default, Option<string> after = default, Option<int> first = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetUnbanRequestsAsync(broadcasterId, moderatorId, status, userId, after, first, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// NEW Gets a list of unban requests for a broadcaster’s channel. NEW Gets a list of unban requests for a broadcaster’s channel.  __Authorization:__  * Requires a user access token that includes the **moderator:read:unban\\_requests** or **moderator:manage:unban\\_requests** scope. * Query parameter &#x60;moderator_id&#x60; must match the &#x60;user_id&#x60; in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose channel is receiving unban requests.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s unban requests. This ID must match the user ID in the user access token.</param>
        /// <param name="status">Filter by a status.      * pending * approved * denied * acknowledged * canceled</param>
        /// <param name="userId">The ID used to filter what unban requests are returned. (optional)</param>
        /// <param name="after">Cursor used to get next page of results. Pagination object in response contains cursor value. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in response (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUnbanRequestsApiResponse"/>&gt;</returns>
        public async Task<IGetUnbanRequestsApiResponse> GetUnbanRequestsAsync(string broadcasterId, string moderatorId, string status, Option<string> userId = default, Option<string> after = default, Option<int> first = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetUnbanRequests(broadcasterId, moderatorId, status, userId, after);

                FormatGetUnbanRequests(ref broadcasterId, ref moderatorId, ref status, ref userId, ref after, ref first);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/unban_requests"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/unban_requests");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);
                    parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status);

                    if (userId.IsSet)
                        parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetUnbanRequestsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetUnbanRequestsApiResponse>();

                        GetUnbanRequestsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/unban_requests", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetUnbanRequestsDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, status, userId, after, first);

                        Events.ExecuteOnGetUnbanRequests(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetUnbanRequestsDefaultImplementation(e, "/moderation/unban_requests", uriBuilderLocalVar.Path, broadcasterId, moderatorId, status, userId, after, first);
                Events.ExecuteOnErrorGetUnbanRequests(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetUnbanRequestsApiResponse"/>
        /// </summary>
        public partial class GetUnbanRequestsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetUnbanRequestsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetUnbanRequestsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetUnbanRequestsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetUnbanRequestsApiResponse(ILogger<GetUnbanRequestsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetUnbanRequestsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetUnbanRequestsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetUnbanRequestsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetVips(ref string broadcasterId, Option<List<string>> userId, ref Option<int> first, ref Option<string> after);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetVips(string broadcasterId, Option<List<string>> userId, Option<string> after)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (userId.IsSet && userId.Value == null)
                throw new ArgumentNullException(nameof(userId));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void AfterGetVipsDefaultImplementation(IGetVipsApiResponse apiResponseLocalVar, string broadcasterId, Option<List<string>> userId, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLog = false;
            AfterGetVips(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, userId, first, after);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void AfterGetVips(ref bool suppressDefaultLog, IGetVipsApiResponse apiResponseLocalVar, string broadcasterId, Option<List<string>> userId, Option<int> first, Option<string> after);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void OnErrorGetVipsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<List<string>> userId, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetVips(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, userId, first, after);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void OnErrorGetVips(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<List<string>> userId, Option<int> first, Option<string> after);

        /// <summary>
        /// Gets a list of the broadcaster’s VIPs. Gets a list of the broadcaster’s VIPs.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:vips** scope. If your app also adds and removes VIP status, you can use the **channel:manage:vips** scope instead.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of VIPs you want to get. This ID must match the user ID in the access token.</param>
        /// <param name="userId">Filters the list for specific VIPs. To specify more than one user, include the _user\\_id_ parameter for each user to get. For example, &#x60;&amp;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. The maximum number of IDs that you may specify is 100\\. Ignores the ID of those users in the list that aren’t VIPs. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\\. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVipsApiResponse"/>&gt;</returns>
        public async Task<IGetVipsApiResponse?> GetVipsOrDefaultAsync(string broadcasterId, Option<List<string>> userId = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetVipsAsync(broadcasterId, userId, first, after, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets a list of the broadcaster’s VIPs. Gets a list of the broadcaster’s VIPs.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:vips** scope. If your app also adds and removes VIP status, you can use the **channel:manage:vips** scope instead.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose list of VIPs you want to get. This ID must match the user ID in the access token.</param>
        /// <param name="userId">Filters the list for specific VIPs. To specify more than one user, include the _user\\_id_ parameter for each user to get. For example, &#x60;&amp;user_id&#x3D;1234&amp;user_id&#x3D;5678&#x60;. The maximum number of IDs that you may specify is 100\\. Ignores the ID of those users in the list that aren’t VIPs. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\\. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVipsApiResponse"/>&gt;</returns>
        public async Task<IGetVipsApiResponse> GetVipsAsync(string broadcasterId, Option<List<string>> userId = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetVips(broadcasterId, userId, after);

                FormatGetVips(ref broadcasterId, userId, ref first, ref after);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/channels/vips"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/channels/vips");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    if (userId.IsSet)
                        parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId.Value);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetVipsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetVipsApiResponse>();

                        GetVipsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channels/vips", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetVipsDefaultImplementation(apiResponseLocalVar, broadcasterId, userId, first, after);

                        Events.ExecuteOnGetVips(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetVipsDefaultImplementation(e, "/channels/vips", uriBuilderLocalVar.Path, broadcasterId, userId, first, after);
                Events.ExecuteOnErrorGetVips(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetVipsApiResponse"/>
        /// </summary>
        public partial class GetVipsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetVipsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetVipsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetVipsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetVipsApiResponse(ILogger<GetVipsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetVIPsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetVIPsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetVIPsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatManageHeldAutomodMessages(Option<ManageHeldAutoModMessagesBody> manageHeldAutoModMessagesBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="manageHeldAutoModMessagesBody"></param>
        /// <returns></returns>
        private void ValidateManageHeldAutomodMessages(Option<ManageHeldAutoModMessagesBody> manageHeldAutoModMessagesBody)
        {
            if (manageHeldAutoModMessagesBody.IsSet && manageHeldAutoModMessagesBody.Value == null)
                throw new ArgumentNullException(nameof(manageHeldAutoModMessagesBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="manageHeldAutoModMessagesBody"></param>
        private void AfterManageHeldAutomodMessagesDefaultImplementation(IManageHeldAutomodMessagesApiResponse apiResponseLocalVar, Option<ManageHeldAutoModMessagesBody> manageHeldAutoModMessagesBody)
        {
            bool suppressDefaultLog = false;
            AfterManageHeldAutomodMessages(ref suppressDefaultLog, apiResponseLocalVar, manageHeldAutoModMessagesBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="manageHeldAutoModMessagesBody"></param>
        partial void AfterManageHeldAutomodMessages(ref bool suppressDefaultLog, IManageHeldAutomodMessagesApiResponse apiResponseLocalVar, Option<ManageHeldAutoModMessagesBody> manageHeldAutoModMessagesBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="manageHeldAutoModMessagesBody"></param>
        private void OnErrorManageHeldAutomodMessagesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<ManageHeldAutoModMessagesBody> manageHeldAutoModMessagesBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorManageHeldAutomodMessages(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, manageHeldAutoModMessagesBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="manageHeldAutoModMessagesBody"></param>
        partial void OnErrorManageHeldAutomodMessages(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<ManageHeldAutoModMessagesBody> manageHeldAutoModMessagesBody);

        /// <summary>
        /// Allow or deny the message that AutoMod flagged for review. Allow or deny the message that AutoMod flagged for review. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).  To get messages that AutoMod is holding for review, subscribe to the **automod-queue.&lt;moderator\\_id&gt;.&lt;channel\\_id&gt;** [topic](https://dev.twitch.tv/docs/pubsub#topics) using [PubSub](https://dev.twitch.tv/docs/pubsub). PubSub sends a notification to your app when AutoMod holds a message for review.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod** scope.
        /// </summary>
        /// <param name="manageHeldAutoModMessagesBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageHeldAutomodMessagesApiResponse"/>&gt;</returns>
        public async Task<IManageHeldAutomodMessagesApiResponse?> ManageHeldAutomodMessagesOrDefaultAsync(Option<ManageHeldAutoModMessagesBody> manageHeldAutoModMessagesBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ManageHeldAutomodMessagesAsync(manageHeldAutoModMessagesBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Allow or deny the message that AutoMod flagged for review. Allow or deny the message that AutoMod flagged for review. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).  To get messages that AutoMod is holding for review, subscribe to the **automod-queue.&lt;moderator\\_id&gt;.&lt;channel\\_id&gt;** [topic](https://dev.twitch.tv/docs/pubsub#topics) using [PubSub](https://dev.twitch.tv/docs/pubsub). PubSub sends a notification to your app when AutoMod holds a message for review.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="manageHeldAutoModMessagesBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageHeldAutomodMessagesApiResponse"/>&gt;</returns>
        public async Task<IManageHeldAutomodMessagesApiResponse> ManageHeldAutomodMessagesAsync(Option<ManageHeldAutoModMessagesBody> manageHeldAutoModMessagesBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateManageHeldAutomodMessages(manageHeldAutoModMessagesBody);

                FormatManageHeldAutomodMessages(manageHeldAutoModMessagesBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/automod/message"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/automod/message");

                    if (manageHeldAutoModMessagesBody.IsSet)
                        httpRequestMessageLocalVar.Content = (manageHeldAutoModMessagesBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(manageHeldAutoModMessagesBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ManageHeldAutomodMessagesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ManageHeldAutomodMessagesApiResponse>();

                        ManageHeldAutomodMessagesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/automod/message", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterManageHeldAutomodMessagesDefaultImplementation(apiResponseLocalVar, manageHeldAutoModMessagesBody);

                        Events.ExecuteOnManageHeldAutomodMessages(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorManageHeldAutomodMessagesDefaultImplementation(e, "/moderation/automod/message", uriBuilderLocalVar.Path, manageHeldAutoModMessagesBody);
                Events.ExecuteOnErrorManageHeldAutomodMessages(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ManageHeldAutomodMessagesApiResponse"/>
        /// </summary>
        public partial class ManageHeldAutomodMessagesApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IManageHeldAutomodMessagesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ManageHeldAutomodMessagesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ManageHeldAutomodMessagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ManageHeldAutomodMessagesApiResponse(ILogger<ManageHeldAutomodMessagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveBlockedTerm(ref string broadcasterId, ref string moderatorId, ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateRemoveBlockedTerm(string broadcasterId, string moderatorId, string id)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="id"></param>
        private void AfterRemoveBlockedTermDefaultImplementation(IRemoveBlockedTermApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, string id)
        {
            bool suppressDefaultLog = false;
            AfterRemoveBlockedTerm(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="id"></param>
        partial void AfterRemoveBlockedTerm(ref bool suppressDefaultLog, IRemoveBlockedTermApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="id"></param>
        private void OnErrorRemoveBlockedTermDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRemoveBlockedTerm(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="id"></param>
        partial void OnErrorRemoveBlockedTerm(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, string id);

        /// <summary>
        /// Removes the word or phrase from the broadcaster’s list of blocked terms. Removes the word or phrase from the broadcaster’s list of blocked terms.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\\_terms** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the list of blocked terms.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="id">The ID of the blocked term to remove from the broadcaster’s list of blocked terms.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveBlockedTermApiResponse"/>&gt;</returns>
        public async Task<IRemoveBlockedTermApiResponse?> RemoveBlockedTermOrDefaultAsync(string broadcasterId, string moderatorId, string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveBlockedTermAsync(broadcasterId, moderatorId, id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Removes the word or phrase from the broadcaster’s list of blocked terms. Removes the word or phrase from the broadcaster’s list of blocked terms.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\\_terms** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the list of blocked terms.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="id">The ID of the blocked term to remove from the broadcaster’s list of blocked terms.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveBlockedTermApiResponse"/>&gt;</returns>
        public async Task<IRemoveBlockedTermApiResponse> RemoveBlockedTermAsync(string broadcasterId, string moderatorId, string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRemoveBlockedTerm(broadcasterId, moderatorId, id);

                FormatRemoveBlockedTerm(ref broadcasterId, ref moderatorId, ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/blocked_terms"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/blocked_terms");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);
                    parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RemoveBlockedTermApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveBlockedTermApiResponse>();

                        RemoveBlockedTermApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/blocked_terms", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRemoveBlockedTermDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, id);

                        Events.ExecuteOnRemoveBlockedTerm(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveBlockedTermDefaultImplementation(e, "/moderation/blocked_terms", uriBuilderLocalVar.Path, broadcasterId, moderatorId, id);
                Events.ExecuteOnErrorRemoveBlockedTerm(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveBlockedTermApiResponse"/>
        /// </summary>
        public partial class RemoveBlockedTermApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IRemoveBlockedTermApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveBlockedTermApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveBlockedTermApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveBlockedTermApiResponse(ILogger<RemoveBlockedTermApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveChannelModerator(ref string broadcasterId, ref string userId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        /// <returns></returns>
        private void ValidateRemoveChannelModerator(string broadcasterId, string userId)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (userId == null)
                throw new ArgumentNullException(nameof(userId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        private void AfterRemoveChannelModeratorDefaultImplementation(IRemoveChannelModeratorApiResponse apiResponseLocalVar, string broadcasterId, string userId)
        {
            bool suppressDefaultLog = false;
            AfterRemoveChannelModerator(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, userId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        partial void AfterRemoveChannelModerator(ref bool suppressDefaultLog, IRemoveChannelModeratorApiResponse apiResponseLocalVar, string broadcasterId, string userId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        private void OnErrorRemoveChannelModeratorDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string userId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRemoveChannelModerator(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, userId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="userId"></param>
        partial void OnErrorRemoveChannelModerator(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string userId);

        /// <summary>
        /// Removes a moderator from the broadcaster’s chat room. Removes a moderator from the broadcaster’s chat room.  **Rate Limits**: The broadcaster may remove a maximum of 10 moderators within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room. This ID must match the user ID in the access token.</param>
        /// <param name="userId">The ID of the user to remove as a moderator from the broadcaster’s chat room.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveChannelModeratorApiResponse"/>&gt;</returns>
        public async Task<IRemoveChannelModeratorApiResponse?> RemoveChannelModeratorOrDefaultAsync(string broadcasterId, string userId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveChannelModeratorAsync(broadcasterId, userId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Removes a moderator from the broadcaster’s chat room. Removes a moderator from the broadcaster’s chat room.  **Rate Limits**: The broadcaster may remove a maximum of 10 moderators within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the chat room. This ID must match the user ID in the access token.</param>
        /// <param name="userId">The ID of the user to remove as a moderator from the broadcaster’s chat room.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveChannelModeratorApiResponse"/>&gt;</returns>
        public async Task<IRemoveChannelModeratorApiResponse> RemoveChannelModeratorAsync(string broadcasterId, string userId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRemoveChannelModerator(broadcasterId, userId);

                FormatRemoveChannelModerator(ref broadcasterId, ref userId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/moderators"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/moderators");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RemoveChannelModeratorApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveChannelModeratorApiResponse>();

                        RemoveChannelModeratorApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/moderators", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRemoveChannelModeratorDefaultImplementation(apiResponseLocalVar, broadcasterId, userId);

                        Events.ExecuteOnRemoveChannelModerator(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveChannelModeratorDefaultImplementation(e, "/moderation/moderators", uriBuilderLocalVar.Path, broadcasterId, userId);
                Events.ExecuteOnErrorRemoveChannelModerator(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveChannelModeratorApiResponse"/>
        /// </summary>
        public partial class RemoveChannelModeratorApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IRemoveChannelModeratorApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveChannelModeratorApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveChannelModeratorApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveChannelModeratorApiResponse(ILogger<RemoveChannelModeratorApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveChannelVip(ref string userId, ref string broadcasterId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="userId"></param>
        /// <param name="broadcasterId"></param>
        /// <returns></returns>
        private void ValidateRemoveChannelVip(string userId, string broadcasterId)
        {
            if (userId == null)
                throw new ArgumentNullException(nameof(userId));

            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="broadcasterId"></param>
        private void AfterRemoveChannelVipDefaultImplementation(IRemoveChannelVipApiResponse apiResponseLocalVar, string userId, string broadcasterId)
        {
            bool suppressDefaultLog = false;
            AfterRemoveChannelVip(ref suppressDefaultLog, apiResponseLocalVar, userId, broadcasterId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="broadcasterId"></param>
        partial void AfterRemoveChannelVip(ref bool suppressDefaultLog, IRemoveChannelVipApiResponse apiResponseLocalVar, string userId, string broadcasterId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="broadcasterId"></param>
        private void OnErrorRemoveChannelVipDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userId, string broadcasterId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRemoveChannelVip(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, userId, broadcasterId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="broadcasterId"></param>
        partial void OnErrorRemoveChannelVip(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string userId, string broadcasterId);

        /// <summary>
        /// Removes the specified user as a VIP in the broadcaster’s channel. Removes the specified user as a VIP in the broadcaster’s channel.  If the broadcaster is removing the user’s VIP status, the ID in the _broadcaster\\_id_ query parameter must match the user ID in the access token; otherwise, if the user is removing their VIP status themselves, the ID in the _user\\_id_ query parameter must match the user ID in the access token.  **Rate Limits**: The broadcaster may remove a maximum of 10 VIPs within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
        /// </summary>
        /// <param name="userId">The ID of the user to remove VIP status from.</param>
        /// <param name="broadcasterId">The ID of the broadcaster who owns the channel where the user has VIP status.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveChannelVipApiResponse"/>&gt;</returns>
        public async Task<IRemoveChannelVipApiResponse?> RemoveChannelVipOrDefaultAsync(string userId, string broadcasterId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveChannelVipAsync(userId, broadcasterId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Removes the specified user as a VIP in the broadcaster’s channel. Removes the specified user as a VIP in the broadcaster’s channel.  If the broadcaster is removing the user’s VIP status, the ID in the _broadcaster\\_id_ query parameter must match the user ID in the access token; otherwise, if the user is removing their VIP status themselves, the ID in the _user\\_id_ query parameter must match the user ID in the access token.  **Rate Limits**: The broadcaster may remove a maximum of 10 VIPs within a 10-second window.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The ID of the user to remove VIP status from.</param>
        /// <param name="broadcasterId">The ID of the broadcaster who owns the channel where the user has VIP status.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveChannelVipApiResponse"/>&gt;</returns>
        public async Task<IRemoveChannelVipApiResponse> RemoveChannelVipAsync(string userId, string broadcasterId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRemoveChannelVip(userId, broadcasterId);

                FormatRemoveChannelVip(ref userId, ref broadcasterId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/channels/vips"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/channels/vips");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId);
                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RemoveChannelVipApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveChannelVipApiResponse>();

                        RemoveChannelVipApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channels/vips", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRemoveChannelVipDefaultImplementation(apiResponseLocalVar, userId, broadcasterId);

                        Events.ExecuteOnRemoveChannelVip(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveChannelVipDefaultImplementation(e, "/channels/vips", uriBuilderLocalVar.Path, userId, broadcasterId);
                Events.ExecuteOnErrorRemoveChannelVip(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveChannelVipApiResponse"/>
        /// </summary>
        public partial class RemoveChannelVipApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IRemoveChannelVipApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveChannelVipApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveChannelVipApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveChannelVipApiResponse(ILogger<RemoveChannelVipApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatResolveUnbanRequests(ref string broadcasterId, ref string moderatorId, ref string unbanRequestId, ref string status, ref Option<string> resolutionText);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="unbanRequestId"></param>
        /// <param name="status"></param>
        /// <param name="resolutionText"></param>
        /// <returns></returns>
        private void ValidateResolveUnbanRequests(string broadcasterId, string moderatorId, string unbanRequestId, string status, Option<string> resolutionText)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (unbanRequestId == null)
                throw new ArgumentNullException(nameof(unbanRequestId));

            if (status == null)
                throw new ArgumentNullException(nameof(status));

            if (resolutionText.IsSet && resolutionText.Value == null)
                throw new ArgumentNullException(nameof(resolutionText));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="unbanRequestId"></param>
        /// <param name="status"></param>
        /// <param name="resolutionText"></param>
        private void AfterResolveUnbanRequestsDefaultImplementation(IResolveUnbanRequestsApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, string unbanRequestId, string status, Option<string> resolutionText)
        {
            bool suppressDefaultLog = false;
            AfterResolveUnbanRequests(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, unbanRequestId, status, resolutionText);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="unbanRequestId"></param>
        /// <param name="status"></param>
        /// <param name="resolutionText"></param>
        partial void AfterResolveUnbanRequests(ref bool suppressDefaultLog, IResolveUnbanRequestsApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, string unbanRequestId, string status, Option<string> resolutionText);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="unbanRequestId"></param>
        /// <param name="status"></param>
        /// <param name="resolutionText"></param>
        private void OnErrorResolveUnbanRequestsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, string unbanRequestId, string status, Option<string> resolutionText)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorResolveUnbanRequests(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, unbanRequestId, status, resolutionText);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="unbanRequestId"></param>
        /// <param name="status"></param>
        /// <param name="resolutionText"></param>
        partial void OnErrorResolveUnbanRequests(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, string unbanRequestId, string status, Option<string> resolutionText);

        /// <summary>
        /// NEW Resolves an unban request by approving or denying it. NEW Resolves an unban request by approving or denying it.  __Authorization:__  * Requires a user access token that includes the **moderator:manage:unban\\_requests** scope. * Query parameter &#x60;moderator_id&#x60; must match the &#x60;user_id&#x60; in the[user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose channel is approving or denying the unban request.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s unban requests. This ID must match the user ID in the user access token.</param>
        /// <param name="unbanRequestId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s unban requests. This ID must match the user ID in the user access token.</param>
        /// <param name="status">Resolution status.       * approved * denied</param>
        /// <param name="resolutionText">Message supplied by the unban request resolver. The message is limited to a maximum of 500 characters. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResolveUnbanRequestsApiResponse"/>&gt;</returns>
        public async Task<IResolveUnbanRequestsApiResponse?> ResolveUnbanRequestsOrDefaultAsync(string broadcasterId, string moderatorId, string unbanRequestId, string status, Option<string> resolutionText = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ResolveUnbanRequestsAsync(broadcasterId, moderatorId, unbanRequestId, status, resolutionText, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// NEW Resolves an unban request by approving or denying it. NEW Resolves an unban request by approving or denying it.  __Authorization:__  * Requires a user access token that includes the **moderator:manage:unban\\_requests** scope. * Query parameter &#x60;moderator_id&#x60; must match the &#x60;user_id&#x60; in the[user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose channel is approving or denying the unban request.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s unban requests. This ID must match the user ID in the user access token.</param>
        /// <param name="unbanRequestId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s unban requests. This ID must match the user ID in the user access token.</param>
        /// <param name="status">Resolution status.       * approved * denied</param>
        /// <param name="resolutionText">Message supplied by the unban request resolver. The message is limited to a maximum of 500 characters. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResolveUnbanRequestsApiResponse"/>&gt;</returns>
        public async Task<IResolveUnbanRequestsApiResponse> ResolveUnbanRequestsAsync(string broadcasterId, string moderatorId, string unbanRequestId, string status, Option<string> resolutionText = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateResolveUnbanRequests(broadcasterId, moderatorId, unbanRequestId, status, resolutionText);

                FormatResolveUnbanRequests(ref broadcasterId, ref moderatorId, ref unbanRequestId, ref status, ref resolutionText);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/unban_requests"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/unban_requests");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);
                    parseQueryStringLocalVar["unban_request_id"] = ClientUtils.ParameterToString(unbanRequestId);
                    parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status);

                    if (resolutionText.IsSet)
                        parseQueryStringLocalVar["resolution_text"] = ClientUtils.ParameterToString(resolutionText.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ResolveUnbanRequestsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ResolveUnbanRequestsApiResponse>();

                        ResolveUnbanRequestsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/unban_requests", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterResolveUnbanRequestsDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, unbanRequestId, status, resolutionText);

                        Events.ExecuteOnResolveUnbanRequests(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorResolveUnbanRequestsDefaultImplementation(e, "/moderation/unban_requests", uriBuilderLocalVar.Path, broadcasterId, moderatorId, unbanRequestId, status, resolutionText);
                Events.ExecuteOnErrorResolveUnbanRequests(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ResolveUnbanRequestsApiResponse"/>
        /// </summary>
        public partial class ResolveUnbanRequestsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IResolveUnbanRequestsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ResolveUnbanRequestsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ResolveUnbanRequestsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ResolveUnbanRequestsApiResponse(ILogger<ResolveUnbanRequestsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.ResolveUnbanRequestsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.ResolveUnbanRequestsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.ResolveUnbanRequestsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUnbanUser(ref string broadcasterId, ref string moderatorId, ref string userId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="userId"></param>
        /// <returns></returns>
        private void ValidateUnbanUser(string broadcasterId, string moderatorId, string userId)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (userId == null)
                throw new ArgumentNullException(nameof(userId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="userId"></param>
        private void AfterUnbanUserDefaultImplementation(IUnbanUserApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, string userId)
        {
            bool suppressDefaultLog = false;
            AfterUnbanUser(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, userId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="userId"></param>
        partial void AfterUnbanUser(ref bool suppressDefaultLog, IUnbanUserApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, string userId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="userId"></param>
        private void OnErrorUnbanUserDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, string userId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUnbanUser(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, userId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="userId"></param>
        partial void OnErrorUnbanUser(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, string userId);

        /// <summary>
        /// Removes the ban or timeout that was placed on the specified user. Removes the ban or timeout that was placed on the specified user.  To ban a user, see [Ban user](https://dev.twitch.tv/docs/api/reference#ban-user).  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\\_users** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat room the user is banned from chatting in.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="userId">The ID of the user to remove the ban or timeout from.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUnbanUserApiResponse"/>&gt;</returns>
        public async Task<IUnbanUserApiResponse?> UnbanUserOrDefaultAsync(string broadcasterId, string moderatorId, string userId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UnbanUserAsync(broadcasterId, moderatorId, userId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Removes the ban or timeout that was placed on the specified user. Removes the ban or timeout that was placed on the specified user.  To ban a user, see [Ban user](https://dev.twitch.tv/docs/api/reference#ban-user).  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\\_users** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose chat room the user is banned from chatting in.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="userId">The ID of the user to remove the ban or timeout from.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUnbanUserApiResponse"/>&gt;</returns>
        public async Task<IUnbanUserApiResponse> UnbanUserAsync(string broadcasterId, string moderatorId, string userId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUnbanUser(broadcasterId, moderatorId, userId);

                FormatUnbanUser(ref broadcasterId, ref moderatorId, ref userId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/bans"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/bans");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);
                    parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UnbanUserApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UnbanUserApiResponse>();

                        UnbanUserApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/bans", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUnbanUserDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, userId);

                        Events.ExecuteOnUnbanUser(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUnbanUserDefaultImplementation(e, "/moderation/bans", uriBuilderLocalVar.Path, broadcasterId, moderatorId, userId);
                Events.ExecuteOnErrorUnbanUser(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UnbanUserApiResponse"/>
        /// </summary>
        public partial class UnbanUserApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IUnbanUserApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UnbanUserApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UnbanUserApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UnbanUserApiResponse(ILogger<UnbanUserApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateAutomodSettings(ref string broadcasterId, ref string moderatorId, Option<UpdateAutoModSettingsBody> updateAutoModSettingsBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateAutoModSettingsBody"></param>
        /// <returns></returns>
        private void ValidateUpdateAutomodSettings(string broadcasterId, string moderatorId, Option<UpdateAutoModSettingsBody> updateAutoModSettingsBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (updateAutoModSettingsBody.IsSet && updateAutoModSettingsBody.Value == null)
                throw new ArgumentNullException(nameof(updateAutoModSettingsBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateAutoModSettingsBody"></param>
        private void AfterUpdateAutomodSettingsDefaultImplementation(IUpdateAutomodSettingsApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<UpdateAutoModSettingsBody> updateAutoModSettingsBody)
        {
            bool suppressDefaultLog = false;
            AfterUpdateAutomodSettings(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, updateAutoModSettingsBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateAutoModSettingsBody"></param>
        partial void AfterUpdateAutomodSettings(ref bool suppressDefaultLog, IUpdateAutomodSettingsApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<UpdateAutoModSettingsBody> updateAutoModSettingsBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateAutoModSettingsBody"></param>
        private void OnErrorUpdateAutomodSettingsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<UpdateAutoModSettingsBody> updateAutoModSettingsBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateAutomodSettings(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, updateAutoModSettingsBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateAutoModSettingsBody"></param>
        partial void OnErrorUpdateAutomodSettings(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<UpdateAutoModSettingsBody> updateAutoModSettingsBody);

        /// <summary>
        /// Updates the broadcaster’s AutoMod settings. Updates the broadcaster’s AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod\\_settings** scope.  __Request Body:__  Because PUT is an overwrite operation, you must include all the fields that you want set after the operation completes. Typically, you’ll send a GET request, update the fields you want to change, and pass that object in the PUT request.  You may set either &#x60;overall_level&#x60; or the individual settings like &#x60;aggression&#x60;, but not both.  Setting &#x60;overall_level&#x60; applies default values to the individual settings. However, setting &#x60;overall_level&#x60; to 4 does not necessarily mean that it applies 4 to all the individual settings. Instead, it applies a set of recommended defaults to the rest of the settings. For example, if you set &#x60;overall_level&#x60; to 2, Twitch provides some filtering on discrimination and sexual content, but more filtering on hostility (see the first example response).  If &#x60;overall_level&#x60; is currently set and you update &#x60;swearing&#x60; to 3, &#x60;overall_level&#x60; will be set to **null** and all settings other than &#x60;swearing&#x60; will be set to 0\\. The same is true if individual settings are set and you update &#x60;overall_level&#x60; to 3 — all the individual settings are updated to reflect the default level.  Note that if you set all the individual settings to values that match what &#x60;overall_level&#x60; would have set them to, Twitch changes AutoMod to use the default AutoMod level instead of using the individual settings.  Valid values for all levels are from 0 (no filtering) through 4 (most aggressive filtering). These levels affect how aggressively AutoMod holds back messages for moderators to review before they appear in chat or are denied (not shown).
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose AutoMod settings you want to update.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="updateAutoModSettingsBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateAutomodSettingsApiResponse"/>&gt;</returns>
        public async Task<IUpdateAutomodSettingsApiResponse?> UpdateAutomodSettingsOrDefaultAsync(string broadcasterId, string moderatorId, Option<UpdateAutoModSettingsBody> updateAutoModSettingsBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateAutomodSettingsAsync(broadcasterId, moderatorId, updateAutoModSettingsBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Updates the broadcaster’s AutoMod settings. Updates the broadcaster’s AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcaster’s chat room.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod\\_settings** scope.  __Request Body:__  Because PUT is an overwrite operation, you must include all the fields that you want set after the operation completes. Typically, you’ll send a GET request, update the fields you want to change, and pass that object in the PUT request.  You may set either &#x60;overall_level&#x60; or the individual settings like &#x60;aggression&#x60;, but not both.  Setting &#x60;overall_level&#x60; applies default values to the individual settings. However, setting &#x60;overall_level&#x60; to 4 does not necessarily mean that it applies 4 to all the individual settings. Instead, it applies a set of recommended defaults to the rest of the settings. For example, if you set &#x60;overall_level&#x60; to 2, Twitch provides some filtering on discrimination and sexual content, but more filtering on hostility (see the first example response).  If &#x60;overall_level&#x60; is currently set and you update &#x60;swearing&#x60; to 3, &#x60;overall_level&#x60; will be set to **null** and all settings other than &#x60;swearing&#x60; will be set to 0\\. The same is true if individual settings are set and you update &#x60;overall_level&#x60; to 3 — all the individual settings are updated to reflect the default level.  Note that if you set all the individual settings to values that match what &#x60;overall_level&#x60; would have set them to, Twitch changes AutoMod to use the default AutoMod level instead of using the individual settings.  Valid values for all levels are from 0 (no filtering) through 4 (most aggressive filtering). These levels affect how aggressively AutoMod holds back messages for moderators to review before they appear in chat or are denied (not shown).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose AutoMod settings you want to update.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that has permission to moderate the broadcaster’s chat room. This ID must match the user ID in the user access token.</param>
        /// <param name="updateAutoModSettingsBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateAutomodSettingsApiResponse"/>&gt;</returns>
        public async Task<IUpdateAutomodSettingsApiResponse> UpdateAutomodSettingsAsync(string broadcasterId, string moderatorId, Option<UpdateAutoModSettingsBody> updateAutoModSettingsBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateAutomodSettings(broadcasterId, moderatorId, updateAutoModSettingsBody);

                FormatUpdateAutomodSettings(ref broadcasterId, ref moderatorId, updateAutoModSettingsBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/automod/settings"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/automod/settings");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (updateAutoModSettingsBody.IsSet)
                        httpRequestMessageLocalVar.Content = (updateAutoModSettingsBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(updateAutoModSettingsBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateAutomodSettingsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateAutomodSettingsApiResponse>();

                        UpdateAutomodSettingsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/automod/settings", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateAutomodSettingsDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, updateAutoModSettingsBody);

                        Events.ExecuteOnUpdateAutomodSettings(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateAutomodSettingsDefaultImplementation(e, "/moderation/automod/settings", uriBuilderLocalVar.Path, broadcasterId, moderatorId, updateAutoModSettingsBody);
                Events.ExecuteOnErrorUpdateAutomodSettings(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateAutomodSettingsApiResponse"/>
        /// </summary>
        public partial class UpdateAutomodSettingsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IUpdateAutomodSettingsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateAutomodSettingsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateAutomodSettingsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateAutomodSettingsApiResponse(ILogger<UpdateAutomodSettingsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateAutoModSettingsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateAutoModSettingsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateAutoModSettingsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateShieldModeStatus(ref string broadcasterId, ref string moderatorId, Option<UpdateShieldModeStatusBody> updateShieldModeStatusBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateShieldModeStatusBody"></param>
        /// <returns></returns>
        private void ValidateUpdateShieldModeStatus(string broadcasterId, string moderatorId, Option<UpdateShieldModeStatusBody> updateShieldModeStatusBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (updateShieldModeStatusBody.IsSet && updateShieldModeStatusBody.Value == null)
                throw new ArgumentNullException(nameof(updateShieldModeStatusBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateShieldModeStatusBody"></param>
        private void AfterUpdateShieldModeStatusDefaultImplementation(IUpdateShieldModeStatusApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<UpdateShieldModeStatusBody> updateShieldModeStatusBody)
        {
            bool suppressDefaultLog = false;
            AfterUpdateShieldModeStatus(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, updateShieldModeStatusBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateShieldModeStatusBody"></param>
        partial void AfterUpdateShieldModeStatus(ref bool suppressDefaultLog, IUpdateShieldModeStatusApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<UpdateShieldModeStatusBody> updateShieldModeStatusBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateShieldModeStatusBody"></param>
        private void OnErrorUpdateShieldModeStatusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<UpdateShieldModeStatusBody> updateShieldModeStatusBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateShieldModeStatus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, updateShieldModeStatusBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="updateShieldModeStatusBody"></param>
        partial void OnErrorUpdateShieldModeStatus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<UpdateShieldModeStatusBody> updateShieldModeStatusBody);

        /// <summary>
        /// Activates or deactivates the broadcaster’s Shield Mode. Activates or deactivates the broadcaster’s Shield Mode.  Twitch’s Shield Mode feature is like a panic button that broadcasters can push to protect themselves from chat abuse coming from one or more accounts. When activated, Shield Mode applies the overrides that the broadcaster configured in the Twitch UX. If the broadcaster hasn’t configured Shield Mode, it applies default overrides.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shield\\_mode** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose Shield Mode you want to activate or deactivate.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that is one of the broadcaster’s moderators. This ID must match the user ID in the access token.</param>
        /// <param name="updateShieldModeStatusBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateShieldModeStatusApiResponse"/>&gt;</returns>
        public async Task<IUpdateShieldModeStatusApiResponse?> UpdateShieldModeStatusOrDefaultAsync(string broadcasterId, string moderatorId, Option<UpdateShieldModeStatusBody> updateShieldModeStatusBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateShieldModeStatusAsync(broadcasterId, moderatorId, updateShieldModeStatusBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Activates or deactivates the broadcaster’s Shield Mode. Activates or deactivates the broadcaster’s Shield Mode.  Twitch’s Shield Mode feature is like a panic button that broadcasters can push to protect themselves from chat abuse coming from one or more accounts. When activated, Shield Mode applies the overrides that the broadcaster configured in the Twitch UX. If the broadcaster hasn’t configured Shield Mode, it applies default overrides.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shield\\_mode** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose Shield Mode you want to activate or deactivate.</param>
        /// <param name="moderatorId">The ID of the broadcaster or a user that is one of the broadcaster’s moderators. This ID must match the user ID in the access token.</param>
        /// <param name="updateShieldModeStatusBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateShieldModeStatusApiResponse"/>&gt;</returns>
        public async Task<IUpdateShieldModeStatusApiResponse> UpdateShieldModeStatusAsync(string broadcasterId, string moderatorId, Option<UpdateShieldModeStatusBody> updateShieldModeStatusBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateShieldModeStatus(broadcasterId, moderatorId, updateShieldModeStatusBody);

                FormatUpdateShieldModeStatus(ref broadcasterId, ref moderatorId, updateShieldModeStatusBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/shield_mode"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/shield_mode");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (updateShieldModeStatusBody.IsSet)
                        httpRequestMessageLocalVar.Content = (updateShieldModeStatusBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(updateShieldModeStatusBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateShieldModeStatusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateShieldModeStatusApiResponse>();

                        UpdateShieldModeStatusApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/shield_mode", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateShieldModeStatusDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, updateShieldModeStatusBody);

                        Events.ExecuteOnUpdateShieldModeStatus(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateShieldModeStatusDefaultImplementation(e, "/moderation/shield_mode", uriBuilderLocalVar.Path, broadcasterId, moderatorId, updateShieldModeStatusBody);
                Events.ExecuteOnErrorUpdateShieldModeStatus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateShieldModeStatusApiResponse"/>
        /// </summary>
        public partial class UpdateShieldModeStatusApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IUpdateShieldModeStatusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateShieldModeStatusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateShieldModeStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateShieldModeStatusApiResponse(ILogger<UpdateShieldModeStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateShieldModeStatusResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateShieldModeStatusResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateShieldModeStatusResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatWarnChatUser(ref string broadcasterId, ref string moderatorId, Option<WarnChatUserBody> warnChatUserBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="warnChatUserBody"></param>
        /// <returns></returns>
        private void ValidateWarnChatUser(string broadcasterId, string moderatorId, Option<WarnChatUserBody> warnChatUserBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (moderatorId == null)
                throw new ArgumentNullException(nameof(moderatorId));

            if (warnChatUserBody.IsSet && warnChatUserBody.Value == null)
                throw new ArgumentNullException(nameof(warnChatUserBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="warnChatUserBody"></param>
        private void AfterWarnChatUserDefaultImplementation(IWarnChatUserApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<WarnChatUserBody> warnChatUserBody)
        {
            bool suppressDefaultLog = false;
            AfterWarnChatUser(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, moderatorId, warnChatUserBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="warnChatUserBody"></param>
        partial void AfterWarnChatUser(ref bool suppressDefaultLog, IWarnChatUserApiResponse apiResponseLocalVar, string broadcasterId, string moderatorId, Option<WarnChatUserBody> warnChatUserBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="warnChatUserBody"></param>
        private void OnErrorWarnChatUserDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<WarnChatUserBody> warnChatUserBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorWarnChatUser(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, moderatorId, warnChatUserBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="moderatorId"></param>
        /// <param name="warnChatUserBody"></param>
        partial void OnErrorWarnChatUser(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string moderatorId, Option<WarnChatUserBody> warnChatUserBody);

        /// <summary>
        /// NEW Warns a user in the specified broadcaster’s chat room, preventing them from chat interaction until the warning is acknowledged. NEW Warns a user in the specified broadcaster’s chat room, preventing them from chat interaction until the warning is acknowledged. New warnings can be issued to a user when they already have a warning in the channel (new warning will replace old warning).  __Authorization:__  Requires a user access token that includes the **moderator:manage:warnings** scope. Query parameter &#x60;moderator_id&#x60; must match the &#x60;user_id&#x60; in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </summary>
        /// <param name="broadcasterId">The ID of the channel in which the warning will take effect.</param>
        /// <param name="moderatorId">The ID of the twitch user who requested the warning.</param>
        /// <param name="warnChatUserBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWarnChatUserApiResponse"/>&gt;</returns>
        public async Task<IWarnChatUserApiResponse?> WarnChatUserOrDefaultAsync(string broadcasterId, string moderatorId, Option<WarnChatUserBody> warnChatUserBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await WarnChatUserAsync(broadcasterId, moderatorId, warnChatUserBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// NEW Warns a user in the specified broadcaster’s chat room, preventing them from chat interaction until the warning is acknowledged. NEW Warns a user in the specified broadcaster’s chat room, preventing them from chat interaction until the warning is acknowledged. New warnings can be issued to a user when they already have a warning in the channel (new warning will replace old warning).  __Authorization:__  Requires a user access token that includes the **moderator:manage:warnings** scope. Query parameter &#x60;moderator_id&#x60; must match the &#x60;user_id&#x60; in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the channel in which the warning will take effect.</param>
        /// <param name="moderatorId">The ID of the twitch user who requested the warning.</param>
        /// <param name="warnChatUserBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWarnChatUserApiResponse"/>&gt;</returns>
        public async Task<IWarnChatUserApiResponse> WarnChatUserAsync(string broadcasterId, string moderatorId, Option<WarnChatUserBody> warnChatUserBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateWarnChatUser(broadcasterId, moderatorId, warnChatUserBody);

                FormatWarnChatUser(ref broadcasterId, ref moderatorId, warnChatUserBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/moderation/warnings"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/moderation/warnings");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["moderator_id"] = ClientUtils.ParameterToString(moderatorId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (warnChatUserBody.IsSet)
                        httpRequestMessageLocalVar.Content = (warnChatUserBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(warnChatUserBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<WarnChatUserApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<WarnChatUserApiResponse>();

                        WarnChatUserApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/moderation/warnings", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterWarnChatUserDefaultImplementation(apiResponseLocalVar, broadcasterId, moderatorId, warnChatUserBody);

                        Events.ExecuteOnWarnChatUser(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorWarnChatUserDefaultImplementation(e, "/moderation/warnings", uriBuilderLocalVar.Path, broadcasterId, moderatorId, warnChatUserBody);
                Events.ExecuteOnErrorWarnChatUser(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="WarnChatUserApiResponse"/>
        /// </summary>
        public partial class WarnChatUserApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IWarnChatUserApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<WarnChatUserApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="WarnChatUserApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public WarnChatUserApiResponse(ILogger<WarnChatUserApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.WarnChatUserResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.WarnChatUserResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.WarnChatUserResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
