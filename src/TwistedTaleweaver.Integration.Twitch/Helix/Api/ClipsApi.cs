// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;
using TwistedTaleweaver.Integration.Twitch.Helix.Model;
using System.Diagnostics.CodeAnalysis;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IClipsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ClipsApiEvents Events { get; }

        /// <summary>
        /// Creates a clip from the broadcaster’s stream.
        /// </summary>
        /// <remarks>
        /// Creates a clip from the broadcaster’s stream.  This API captures up to 90 seconds of the broadcaster’s stream. The 90 seconds spans the point in the stream from when you called the API. For example, if you call the API at the 4:00 minute mark, the API captures from approximately the 3:35 mark to approximately the 4:05 minute mark. Twitch tries its best to capture 90 seconds of the stream, but the actual length may be less. This may occur if you begin capturing the clip near the beginning or end of the stream.  By default, Twitch publishes up to the last 30 seconds of the 90 seconds window and provides a default title for the clip. To specify the title and the portion of the 90 seconds window that’s used for the clip, use the URL in the response’s &#x60;edit_url&#x60; field. You can specify a clip that’s from 5 seconds to 60 seconds in length. The URL is valid for up to 24 hours or until the clip is published, whichever comes first.  Creating a clip is an asynchronous process that can take a short amount of time to complete. To determine whether the clip was successfully created, call [Get Clips](https://dev.twitch.tv/docs/api/reference#get-clips) using the clip ID that this request returned. If Get Clips returns the clip, the clip was successfully created. If after 15 seconds Get Clips hasn’t returned the clip, assume it failed.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **clips:edit** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose stream you want to create a clip from.</param>
        /// <param name="hasDelay">A Boolean value that determines whether the API captures the clip at the moment the viewer requests it or after a delay. If **false** (default), Twitch captures the clip at the moment the viewer requests it (this is the same clip experience as the Twitch UX). If **true**, Twitch adds a delay before capturing the clip (this basically shifts the capture window to the right slightly). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateClipApiResponse"/>&gt;</returns>
        Task<ICreateClipApiResponse> CreateClipAsync(string broadcasterId, Option<bool> hasDelay = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates a clip from the broadcaster’s stream.
        /// </summary>
        /// <remarks>
        /// Creates a clip from the broadcaster’s stream.  This API captures up to 90 seconds of the broadcaster’s stream. The 90 seconds spans the point in the stream from when you called the API. For example, if you call the API at the 4:00 minute mark, the API captures from approximately the 3:35 mark to approximately the 4:05 minute mark. Twitch tries its best to capture 90 seconds of the stream, but the actual length may be less. This may occur if you begin capturing the clip near the beginning or end of the stream.  By default, Twitch publishes up to the last 30 seconds of the 90 seconds window and provides a default title for the clip. To specify the title and the portion of the 90 seconds window that’s used for the clip, use the URL in the response’s &#x60;edit_url&#x60; field. You can specify a clip that’s from 5 seconds to 60 seconds in length. The URL is valid for up to 24 hours or until the clip is published, whichever comes first.  Creating a clip is an asynchronous process that can take a short amount of time to complete. To determine whether the clip was successfully created, call [Get Clips](https://dev.twitch.tv/docs/api/reference#get-clips) using the clip ID that this request returned. If Get Clips returns the clip, the clip was successfully created. If after 15 seconds Get Clips hasn’t returned the clip, assume it failed.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **clips:edit** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose stream you want to create a clip from.</param>
        /// <param name="hasDelay">A Boolean value that determines whether the API captures the clip at the moment the viewer requests it or after a delay. If **false** (default), Twitch captures the clip at the moment the viewer requests it (this is the same clip experience as the Twitch UX). If **true**, Twitch adds a delay before capturing the clip (this basically shifts the capture window to the right slightly). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateClipApiResponse"/>?&gt;</returns>
        Task<ICreateClipApiResponse?> CreateClipOrDefaultAsync(string broadcasterId, Option<bool> hasDelay = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets one or more video clips.
        /// </summary>
        /// <remarks>
        /// Gets one or more video clips that were captured from streams. For information about clips, see [How to use clips](https://help.twitch.tv/s/article/how-to-use-clips).  When using pagination for clips, note that the maximum number of results returned over multiple requests will be approximately 1,000\\. If additional results are necessary, paginate over different query parameters such as multiple &#x60;started_at&#x60; and &#x60;ended_at&#x60; timeframes to refine the search.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).  __Request Query Parameters:__  The _id_, _game\\_id_, and _broadcaster\\_id_ query parameters are mutually exclusive.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">An ID that identifies the broadcaster whose video clips you want to get. Use this parameter to get clips that were captured from the broadcaster’s streams. (optional)</param>
        /// <param name="gameId">An ID that identifies the game whose clips you want to get. Use this parameter to get clips that were captured from streams that were playing this game. (optional)</param>
        /// <param name="id">An ID that identifies the clip to get. To specify more than one ID, include this parameter for each clip you want to get. For example, &#x60;id&#x3D;foo&amp;id&#x3D;bar&#x60;. You may specify a maximum of 100 IDs. The API ignores duplicate IDs and IDs that aren’t found. (optional)</param>
        /// <param name="startedAt">The start date used to filter clips. The API returns only clips within the start and end date window. Specify the date and time in RFC3339 format. (optional)</param>
        /// <param name="endedAt">The end date used to filter clips. If not specified, the time window is the start date plus one week. Specify the date and time in RFC3339 format. (optional)</param>
        /// <param name="first">The maximum number of clips to return per page in the response. The minimum page size is 1 clip per page and the maximum is 100\\. The default is 20. (optional)</param>
        /// <param name="before">The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="isFeatured">A Boolean value that determines whether the response includes featured clips. If **true**, returns only clips that are featured. If **false**, returns only clips that aren’t featured. All clips are returned if this parameter is not present. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipsApiResponse"/>&gt;</returns>
        Task<IGetClipsApiResponse> GetClipsAsync(Option<string> broadcasterId = default, Option<string> gameId = default, Option<List<string>> id = default, Option<DateTime> startedAt = default, Option<DateTime> endedAt = default, Option<int> first = default, Option<string> before = default, Option<string> after = default, Option<bool> isFeatured = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets one or more video clips.
        /// </summary>
        /// <remarks>
        /// Gets one or more video clips that were captured from streams. For information about clips, see [How to use clips](https://help.twitch.tv/s/article/how-to-use-clips).  When using pagination for clips, note that the maximum number of results returned over multiple requests will be approximately 1,000\\. If additional results are necessary, paginate over different query parameters such as multiple &#x60;started_at&#x60; and &#x60;ended_at&#x60; timeframes to refine the search.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).  __Request Query Parameters:__  The _id_, _game\\_id_, and _broadcaster\\_id_ query parameters are mutually exclusive.
        /// </remarks>
        /// <param name="broadcasterId">An ID that identifies the broadcaster whose video clips you want to get. Use this parameter to get clips that were captured from the broadcaster’s streams. (optional)</param>
        /// <param name="gameId">An ID that identifies the game whose clips you want to get. Use this parameter to get clips that were captured from streams that were playing this game. (optional)</param>
        /// <param name="id">An ID that identifies the clip to get. To specify more than one ID, include this parameter for each clip you want to get. For example, &#x60;id&#x3D;foo&amp;id&#x3D;bar&#x60;. You may specify a maximum of 100 IDs. The API ignores duplicate IDs and IDs that aren’t found. (optional)</param>
        /// <param name="startedAt">The start date used to filter clips. The API returns only clips within the start and end date window. Specify the date and time in RFC3339 format. (optional)</param>
        /// <param name="endedAt">The end date used to filter clips. If not specified, the time window is the start date plus one week. Specify the date and time in RFC3339 format. (optional)</param>
        /// <param name="first">The maximum number of clips to return per page in the response. The minimum page size is 1 clip per page and the maximum is 100\\. The default is 20. (optional)</param>
        /// <param name="before">The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="isFeatured">A Boolean value that determines whether the response includes featured clips. If **true**, returns only clips that are featured. If **false**, returns only clips that aren’t featured. All clips are returned if this parameter is not present. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipsApiResponse"/>?&gt;</returns>
        Task<IGetClipsApiResponse?> GetClipsOrDefaultAsync(Option<string> broadcasterId = default, Option<string> gameId = default, Option<List<string>> id = default, Option<DateTime> startedAt = default, Option<DateTime> endedAt = default, Option<int> first = default, Option<string> before = default, Option<string> after = default, Option<bool> isFeatured = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateClipApiResponse"/>
    /// </summary>
    public interface ICreateClipApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IAccepted<TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateClipResponse?>
    {
        /// <summary>
        /// Returns true if the response is 202 Accepted
        /// </summary>
        /// <returns></returns>
        bool IsAccepted { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetClipsApiResponse"/>
    /// </summary>
    public interface IGetClipsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetClipsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ClipsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateClip;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateClip;

        internal void ExecuteOnCreateClip(ClipsApi.CreateClipApiResponse apiResponse)
        {
            OnCreateClip?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateClip(Exception exception)
        {
            OnErrorCreateClip?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetClips;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetClips;

        internal void ExecuteOnGetClips(ClipsApi.GetClipsApiResponse apiResponse)
        {
            OnGetClips?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetClips(Exception exception)
        {
            OnErrorGetClips?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ClipsApi : IClipsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ClipsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ClipsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ClipsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ClipsApi(ILogger<ClipsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ClipsApiEvents clipsApiEvents,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ClipsApi>();
            HttpClient = httpClient;
            Events = clipsApiEvents;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatCreateClip(ref string broadcasterId, ref Option<bool> hasDelay);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <returns></returns>
        private void ValidateCreateClip(string broadcasterId)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="hasDelay"></param>
        private void AfterCreateClipDefaultImplementation(ICreateClipApiResponse apiResponseLocalVar, string broadcasterId, Option<bool> hasDelay)
        {
            bool suppressDefaultLog = false;
            AfterCreateClip(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, hasDelay);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="hasDelay"></param>
        partial void AfterCreateClip(ref bool suppressDefaultLog, ICreateClipApiResponse apiResponseLocalVar, string broadcasterId, Option<bool> hasDelay);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="hasDelay"></param>
        private void OnErrorCreateClipDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<bool> hasDelay)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateClip(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, hasDelay);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="hasDelay"></param>
        partial void OnErrorCreateClip(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<bool> hasDelay);

        /// <summary>
        /// Creates a clip from the broadcaster’s stream. Creates a clip from the broadcaster’s stream.  This API captures up to 90 seconds of the broadcaster’s stream. The 90 seconds spans the point in the stream from when you called the API. For example, if you call the API at the 4:00 minute mark, the API captures from approximately the 3:35 mark to approximately the 4:05 minute mark. Twitch tries its best to capture 90 seconds of the stream, but the actual length may be less. This may occur if you begin capturing the clip near the beginning or end of the stream.  By default, Twitch publishes up to the last 30 seconds of the 90 seconds window and provides a default title for the clip. To specify the title and the portion of the 90 seconds window that’s used for the clip, use the URL in the response’s &#x60;edit_url&#x60; field. You can specify a clip that’s from 5 seconds to 60 seconds in length. The URL is valid for up to 24 hours or until the clip is published, whichever comes first.  Creating a clip is an asynchronous process that can take a short amount of time to complete. To determine whether the clip was successfully created, call [Get Clips](https://dev.twitch.tv/docs/api/reference#get-clips) using the clip ID that this request returned. If Get Clips returns the clip, the clip was successfully created. If after 15 seconds Get Clips hasn’t returned the clip, assume it failed.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **clips:edit** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose stream you want to create a clip from.</param>
        /// <param name="hasDelay">A Boolean value that determines whether the API captures the clip at the moment the viewer requests it or after a delay. If **false** (default), Twitch captures the clip at the moment the viewer requests it (this is the same clip experience as the Twitch UX). If **true**, Twitch adds a delay before capturing the clip (this basically shifts the capture window to the right slightly). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateClipApiResponse"/>&gt;</returns>
        public async Task<ICreateClipApiResponse?> CreateClipOrDefaultAsync(string broadcasterId, Option<bool> hasDelay = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateClipAsync(broadcasterId, hasDelay, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Creates a clip from the broadcaster’s stream. Creates a clip from the broadcaster’s stream.  This API captures up to 90 seconds of the broadcaster’s stream. The 90 seconds spans the point in the stream from when you called the API. For example, if you call the API at the 4:00 minute mark, the API captures from approximately the 3:35 mark to approximately the 4:05 minute mark. Twitch tries its best to capture 90 seconds of the stream, but the actual length may be less. This may occur if you begin capturing the clip near the beginning or end of the stream.  By default, Twitch publishes up to the last 30 seconds of the 90 seconds window and provides a default title for the clip. To specify the title and the portion of the 90 seconds window that’s used for the clip, use the URL in the response’s &#x60;edit_url&#x60; field. You can specify a clip that’s from 5 seconds to 60 seconds in length. The URL is valid for up to 24 hours or until the clip is published, whichever comes first.  Creating a clip is an asynchronous process that can take a short amount of time to complete. To determine whether the clip was successfully created, call [Get Clips](https://dev.twitch.tv/docs/api/reference#get-clips) using the clip ID that this request returned. If Get Clips returns the clip, the clip was successfully created. If after 15 seconds Get Clips hasn’t returned the clip, assume it failed.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **clips:edit** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose stream you want to create a clip from.</param>
        /// <param name="hasDelay">A Boolean value that determines whether the API captures the clip at the moment the viewer requests it or after a delay. If **false** (default), Twitch captures the clip at the moment the viewer requests it (this is the same clip experience as the Twitch UX). If **true**, Twitch adds a delay before capturing the clip (this basically shifts the capture window to the right slightly). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateClipApiResponse"/>&gt;</returns>
        public async Task<ICreateClipApiResponse> CreateClipAsync(string broadcasterId, Option<bool> hasDelay = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateClip(broadcasterId);

                FormatCreateClip(ref broadcasterId, ref hasDelay);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/clips"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/clips");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    if (hasDelay.IsSet)
                        parseQueryStringLocalVar["has_delay"] = ClientUtils.ParameterToString(hasDelay.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateClipApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateClipApiResponse>();

                        CreateClipApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clips", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateClipDefaultImplementation(apiResponseLocalVar, broadcasterId, hasDelay);

                        Events.ExecuteOnCreateClip(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateClipDefaultImplementation(e, "/clips", uriBuilderLocalVar.Path, broadcasterId, hasDelay);
                Events.ExecuteOnErrorCreateClip(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateClipApiResponse"/>
        /// </summary>
        public partial class CreateClipApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ICreateClipApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateClipApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateClipApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateClipApiResponse(ILogger<CreateClipApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 202 Accepted
            /// </summary>
            /// <returns></returns>
            public bool IsAccepted => 202 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 202 Accepted
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateClipResponse? Accepted()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsAccepted
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateClipResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 202 Accepted and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryAccepted([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateClipResponse? result)
            {
                result = null;

                try
                {
                    result = Accepted();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)202);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetClips(ref Option<string> broadcasterId, ref Option<string> gameId, Option<List<string>> id, ref Option<DateTime> startedAt, ref Option<DateTime> endedAt, ref Option<int> first, ref Option<string> before, ref Option<string> after, ref Option<bool> isFeatured);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="gameId"></param>
        /// <param name="id"></param>
        /// <param name="before"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetClips(Option<string> broadcasterId, Option<string> gameId, Option<List<string>> id, Option<string> before, Option<string> after)
        {
            if (broadcasterId.IsSet && broadcasterId.Value == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (gameId.IsSet && gameId.Value == null)
                throw new ArgumentNullException(nameof(gameId));

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));

            if (before.IsSet && before.Value == null)
                throw new ArgumentNullException(nameof(before));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="gameId"></param>
        /// <param name="id"></param>
        /// <param name="startedAt"></param>
        /// <param name="endedAt"></param>
        /// <param name="first"></param>
        /// <param name="before"></param>
        /// <param name="after"></param>
        /// <param name="isFeatured"></param>
        private void AfterGetClipsDefaultImplementation(IGetClipsApiResponse apiResponseLocalVar, Option<string> broadcasterId, Option<string> gameId, Option<List<string>> id, Option<DateTime> startedAt, Option<DateTime> endedAt, Option<int> first, Option<string> before, Option<string> after, Option<bool> isFeatured)
        {
            bool suppressDefaultLog = false;
            AfterGetClips(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, gameId, id, startedAt, endedAt, first, before, after, isFeatured);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="gameId"></param>
        /// <param name="id"></param>
        /// <param name="startedAt"></param>
        /// <param name="endedAt"></param>
        /// <param name="first"></param>
        /// <param name="before"></param>
        /// <param name="after"></param>
        /// <param name="isFeatured"></param>
        partial void AfterGetClips(ref bool suppressDefaultLog, IGetClipsApiResponse apiResponseLocalVar, Option<string> broadcasterId, Option<string> gameId, Option<List<string>> id, Option<DateTime> startedAt, Option<DateTime> endedAt, Option<int> first, Option<string> before, Option<string> after, Option<bool> isFeatured);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="gameId"></param>
        /// <param name="id"></param>
        /// <param name="startedAt"></param>
        /// <param name="endedAt"></param>
        /// <param name="first"></param>
        /// <param name="before"></param>
        /// <param name="after"></param>
        /// <param name="isFeatured"></param>
        private void OnErrorGetClipsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> broadcasterId, Option<string> gameId, Option<List<string>> id, Option<DateTime> startedAt, Option<DateTime> endedAt, Option<int> first, Option<string> before, Option<string> after, Option<bool> isFeatured)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetClips(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, gameId, id, startedAt, endedAt, first, before, after, isFeatured);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="gameId"></param>
        /// <param name="id"></param>
        /// <param name="startedAt"></param>
        /// <param name="endedAt"></param>
        /// <param name="first"></param>
        /// <param name="before"></param>
        /// <param name="after"></param>
        /// <param name="isFeatured"></param>
        partial void OnErrorGetClips(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> broadcasterId, Option<string> gameId, Option<List<string>> id, Option<DateTime> startedAt, Option<DateTime> endedAt, Option<int> first, Option<string> before, Option<string> after, Option<bool> isFeatured);

        /// <summary>
        /// Gets one or more video clips. Gets one or more video clips that were captured from streams. For information about clips, see [How to use clips](https://help.twitch.tv/s/article/how-to-use-clips).  When using pagination for clips, note that the maximum number of results returned over multiple requests will be approximately 1,000\\. If additional results are necessary, paginate over different query parameters such as multiple &#x60;started_at&#x60; and &#x60;ended_at&#x60; timeframes to refine the search.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).  __Request Query Parameters:__  The _id_, _game\\_id_, and _broadcaster\\_id_ query parameters are mutually exclusive.
        /// </summary>
        /// <param name="broadcasterId">An ID that identifies the broadcaster whose video clips you want to get. Use this parameter to get clips that were captured from the broadcaster’s streams. (optional)</param>
        /// <param name="gameId">An ID that identifies the game whose clips you want to get. Use this parameter to get clips that were captured from streams that were playing this game. (optional)</param>
        /// <param name="id">An ID that identifies the clip to get. To specify more than one ID, include this parameter for each clip you want to get. For example, &#x60;id&#x3D;foo&amp;id&#x3D;bar&#x60;. You may specify a maximum of 100 IDs. The API ignores duplicate IDs and IDs that aren’t found. (optional)</param>
        /// <param name="startedAt">The start date used to filter clips. The API returns only clips within the start and end date window. Specify the date and time in RFC3339 format. (optional)</param>
        /// <param name="endedAt">The end date used to filter clips. If not specified, the time window is the start date plus one week. Specify the date and time in RFC3339 format. (optional)</param>
        /// <param name="first">The maximum number of clips to return per page in the response. The minimum page size is 1 clip per page and the maximum is 100\\. The default is 20. (optional)</param>
        /// <param name="before">The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="isFeatured">A Boolean value that determines whether the response includes featured clips. If **true**, returns only clips that are featured. If **false**, returns only clips that aren’t featured. All clips are returned if this parameter is not present. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipsApiResponse"/>&gt;</returns>
        public async Task<IGetClipsApiResponse?> GetClipsOrDefaultAsync(Option<string> broadcasterId = default, Option<string> gameId = default, Option<List<string>> id = default, Option<DateTime> startedAt = default, Option<DateTime> endedAt = default, Option<int> first = default, Option<string> before = default, Option<string> after = default, Option<bool> isFeatured = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetClipsAsync(broadcasterId, gameId, id, startedAt, endedAt, first, before, after, isFeatured, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets one or more video clips. Gets one or more video clips that were captured from streams. For information about clips, see [How to use clips](https://help.twitch.tv/s/article/how-to-use-clips).  When using pagination for clips, note that the maximum number of results returned over multiple requests will be approximately 1,000\\. If additional results are necessary, paginate over different query parameters such as multiple &#x60;started_at&#x60; and &#x60;ended_at&#x60; timeframes to refine the search.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).  __Request Query Parameters:__  The _id_, _game\\_id_, and _broadcaster\\_id_ query parameters are mutually exclusive.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">An ID that identifies the broadcaster whose video clips you want to get. Use this parameter to get clips that were captured from the broadcaster’s streams. (optional)</param>
        /// <param name="gameId">An ID that identifies the game whose clips you want to get. Use this parameter to get clips that were captured from streams that were playing this game. (optional)</param>
        /// <param name="id">An ID that identifies the clip to get. To specify more than one ID, include this parameter for each clip you want to get. For example, &#x60;id&#x3D;foo&amp;id&#x3D;bar&#x60;. You may specify a maximum of 100 IDs. The API ignores duplicate IDs and IDs that aren’t found. (optional)</param>
        /// <param name="startedAt">The start date used to filter clips. The API returns only clips within the start and end date window. Specify the date and time in RFC3339 format. (optional)</param>
        /// <param name="endedAt">The end date used to filter clips. If not specified, the time window is the start date plus one week. Specify the date and time in RFC3339 format. (optional)</param>
        /// <param name="first">The maximum number of clips to return per page in the response. The minimum page size is 1 clip per page and the maximum is 100\\. The default is 20. (optional)</param>
        /// <param name="before">The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="isFeatured">A Boolean value that determines whether the response includes featured clips. If **true**, returns only clips that are featured. If **false**, returns only clips that aren’t featured. All clips are returned if this parameter is not present. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipsApiResponse"/>&gt;</returns>
        public async Task<IGetClipsApiResponse> GetClipsAsync(Option<string> broadcasterId = default, Option<string> gameId = default, Option<List<string>> id = default, Option<DateTime> startedAt = default, Option<DateTime> endedAt = default, Option<int> first = default, Option<string> before = default, Option<string> after = default, Option<bool> isFeatured = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetClips(broadcasterId, gameId, id, before, after);

                FormatGetClips(ref broadcasterId, ref gameId, id, ref startedAt, ref endedAt, ref first, ref before, ref after, ref isFeatured);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/clips"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/clips");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (broadcasterId.IsSet)
                        parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId.Value);

                    if (gameId.IsSet)
                        parseQueryStringLocalVar["game_id"] = ClientUtils.ParameterToString(gameId.Value);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (startedAt.IsSet)
                        parseQueryStringLocalVar["started_at"] = ClientUtils.ParameterToString(startedAt.Value);

                    if (endedAt.IsSet)
                        parseQueryStringLocalVar["ended_at"] = ClientUtils.ParameterToString(endedAt.Value);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    if (isFeatured.IsSet)
                        parseQueryStringLocalVar["is_featured"] = ClientUtils.ParameterToString(isFeatured.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetClipsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetClipsApiResponse>();

                        GetClipsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clips", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetClipsDefaultImplementation(apiResponseLocalVar, broadcasterId, gameId, id, startedAt, endedAt, first, before, after, isFeatured);

                        Events.ExecuteOnGetClips(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetClipsDefaultImplementation(e, "/clips", uriBuilderLocalVar.Path, broadcasterId, gameId, id, startedAt, endedAt, first, before, after, isFeatured);
                Events.ExecuteOnErrorGetClips(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetClipsApiResponse"/>
        /// </summary>
        public partial class GetClipsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetClipsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetClipsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetClipsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetClipsApiResponse(ILogger<GetClipsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetClipsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetClipsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetClipsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
