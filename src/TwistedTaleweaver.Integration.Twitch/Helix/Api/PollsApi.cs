// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;
using TwistedTaleweaver.Integration.Twitch.Helix.Model;
using System.Diagnostics.CodeAnalysis;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IPollsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        PollsApiEvents Events { get; }

        /// <summary>
        /// Creates a poll that viewers in the broadcaster’s channel can vote on.
        /// </summary>
        /// <remarks>
        /// Creates a poll that viewers in the broadcaster’s channel can vote on.  The poll begins as soon as it’s created. You may run only one poll at a time.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createPollBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreatePollApiResponse"/>&gt;</returns>
        Task<ICreatePollApiResponse> CreatePollAsync(Option<CreatePollBody> createPollBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates a poll that viewers in the broadcaster’s channel can vote on.
        /// </summary>
        /// <remarks>
        /// Creates a poll that viewers in the broadcaster’s channel can vote on.  The poll begins as soon as it’s created. You may run only one poll at a time.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
        /// </remarks>
        /// <param name="createPollBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreatePollApiResponse"/>?&gt;</returns>
        Task<ICreatePollApiResponse?> CreatePollOrDefaultAsync(Option<CreatePollBody> createPollBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// End an active poll.
        /// </summary>
        /// <remarks>
        /// Ends an active poll. You have the option to end it or end it and archive it.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="endPollBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEndPollApiResponse"/>&gt;</returns>
        Task<IEndPollApiResponse> EndPollAsync(Option<EndPollBody> endPollBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// End an active poll.
        /// </summary>
        /// <remarks>
        /// Ends an active poll. You have the option to end it or end it and archive it.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
        /// </remarks>
        /// <param name="endPollBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEndPollApiResponse"/>?&gt;</returns>
        Task<IEndPollApiResponse?> EndPollOrDefaultAsync(Option<EndPollBody> endPollBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of polls that the broadcaster created.
        /// </summary>
        /// <remarks>
        /// Gets a list of polls that the broadcaster created.  Polls are available for 90 days after they’re created.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:polls** or **channel:manage:polls** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that created the polls. This ID must match the user ID in the user access token.</param>
        /// <param name="id">A list of IDs that identify the polls to return. To specify more than one ID, include this parameter for each poll you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 20 IDs.      Specify this parameter only if you want to filter the list that the request returns. The endpoint ignores duplicate IDs and those not owned by this broadcaster. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 20 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPollsApiResponse"/>&gt;</returns>
        Task<IGetPollsApiResponse> GetPollsAsync(string broadcasterId, Option<List<string>> id = default, Option<string> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of polls that the broadcaster created.
        /// </summary>
        /// <remarks>
        /// Gets a list of polls that the broadcaster created.  Polls are available for 90 days after they’re created.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:polls** or **channel:manage:polls** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that created the polls. This ID must match the user ID in the user access token.</param>
        /// <param name="id">A list of IDs that identify the polls to return. To specify more than one ID, include this parameter for each poll you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 20 IDs.      Specify this parameter only if you want to filter the list that the request returns. The endpoint ignores duplicate IDs and those not owned by this broadcaster. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 20 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPollsApiResponse"/>?&gt;</returns>
        Task<IGetPollsApiResponse?> GetPollsOrDefaultAsync(string broadcasterId, Option<List<string>> id = default, Option<string> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreatePollApiResponse"/>
    /// </summary>
    public interface ICreatePollApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.CreatePollResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IEndPollApiResponse"/>
    /// </summary>
    public interface IEndPollApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.EndPollResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetPollsApiResponse"/>
    /// </summary>
    public interface IGetPollsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetPollsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class PollsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreatePoll;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreatePoll;

        internal void ExecuteOnCreatePoll(PollsApi.CreatePollApiResponse apiResponse)
        {
            OnCreatePoll?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreatePoll(Exception exception)
        {
            OnErrorCreatePoll?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEndPoll;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEndPoll;

        internal void ExecuteOnEndPoll(PollsApi.EndPollApiResponse apiResponse)
        {
            OnEndPoll?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEndPoll(Exception exception)
        {
            OnErrorEndPoll?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetPolls;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetPolls;

        internal void ExecuteOnGetPolls(PollsApi.GetPollsApiResponse apiResponse)
        {
            OnGetPolls?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetPolls(Exception exception)
        {
            OnErrorGetPolls?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class PollsApi : IPollsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<PollsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public PollsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="PollsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PollsApi(ILogger<PollsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, PollsApiEvents pollsApiEvents,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<PollsApi>();
            HttpClient = httpClient;
            Events = pollsApiEvents;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatCreatePoll(Option<CreatePollBody> createPollBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createPollBody"></param>
        /// <returns></returns>
        private void ValidateCreatePoll(Option<CreatePollBody> createPollBody)
        {
            if (createPollBody.IsSet && createPollBody.Value == null)
                throw new ArgumentNullException(nameof(createPollBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createPollBody"></param>
        private void AfterCreatePollDefaultImplementation(ICreatePollApiResponse apiResponseLocalVar, Option<CreatePollBody> createPollBody)
        {
            bool suppressDefaultLog = false;
            AfterCreatePoll(ref suppressDefaultLog, apiResponseLocalVar, createPollBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createPollBody"></param>
        partial void AfterCreatePoll(ref bool suppressDefaultLog, ICreatePollApiResponse apiResponseLocalVar, Option<CreatePollBody> createPollBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createPollBody"></param>
        private void OnErrorCreatePollDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreatePollBody> createPollBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreatePoll(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, createPollBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createPollBody"></param>
        partial void OnErrorCreatePoll(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreatePollBody> createPollBody);

        /// <summary>
        /// Creates a poll that viewers in the broadcaster’s channel can vote on. Creates a poll that viewers in the broadcaster’s channel can vote on.  The poll begins as soon as it’s created. You may run only one poll at a time.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
        /// </summary>
        /// <param name="createPollBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreatePollApiResponse"/>&gt;</returns>
        public async Task<ICreatePollApiResponse?> CreatePollOrDefaultAsync(Option<CreatePollBody> createPollBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreatePollAsync(createPollBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Creates a poll that viewers in the broadcaster’s channel can vote on. Creates a poll that viewers in the broadcaster’s channel can vote on.  The poll begins as soon as it’s created. You may run only one poll at a time.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createPollBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreatePollApiResponse"/>&gt;</returns>
        public async Task<ICreatePollApiResponse> CreatePollAsync(Option<CreatePollBody> createPollBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreatePoll(createPollBody);

                FormatCreatePoll(createPollBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/polls"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/polls");

                    if (createPollBody.IsSet)
                        httpRequestMessageLocalVar.Content = (createPollBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createPollBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreatePollApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreatePollApiResponse>();

                        CreatePollApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/polls", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreatePollDefaultImplementation(apiResponseLocalVar, createPollBody);

                        Events.ExecuteOnCreatePoll(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreatePollDefaultImplementation(e, "/polls", uriBuilderLocalVar.Path, createPollBody);
                Events.ExecuteOnErrorCreatePoll(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreatePollApiResponse"/>
        /// </summary>
        public partial class CreatePollApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ICreatePollApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreatePollApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreatePollApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreatePollApiResponse(ILogger<CreatePollApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.CreatePollResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.CreatePollResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.CreatePollResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEndPoll(Option<EndPollBody> endPollBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="endPollBody"></param>
        /// <returns></returns>
        private void ValidateEndPoll(Option<EndPollBody> endPollBody)
        {
            if (endPollBody.IsSet && endPollBody.Value == null)
                throw new ArgumentNullException(nameof(endPollBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="endPollBody"></param>
        private void AfterEndPollDefaultImplementation(IEndPollApiResponse apiResponseLocalVar, Option<EndPollBody> endPollBody)
        {
            bool suppressDefaultLog = false;
            AfterEndPoll(ref suppressDefaultLog, apiResponseLocalVar, endPollBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="endPollBody"></param>
        partial void AfterEndPoll(ref bool suppressDefaultLog, IEndPollApiResponse apiResponseLocalVar, Option<EndPollBody> endPollBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="endPollBody"></param>
        private void OnErrorEndPollDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<EndPollBody> endPollBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorEndPoll(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, endPollBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="endPollBody"></param>
        partial void OnErrorEndPoll(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<EndPollBody> endPollBody);

        /// <summary>
        /// End an active poll. Ends an active poll. You have the option to end it or end it and archive it.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
        /// </summary>
        /// <param name="endPollBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEndPollApiResponse"/>&gt;</returns>
        public async Task<IEndPollApiResponse?> EndPollOrDefaultAsync(Option<EndPollBody> endPollBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EndPollAsync(endPollBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// End an active poll. Ends an active poll. You have the option to end it or end it and archive it.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="endPollBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEndPollApiResponse"/>&gt;</returns>
        public async Task<IEndPollApiResponse> EndPollAsync(Option<EndPollBody> endPollBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEndPoll(endPollBody);

                FormatEndPoll(endPollBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/polls"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/polls");

                    if (endPollBody.IsSet)
                        httpRequestMessageLocalVar.Content = (endPollBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(endPollBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EndPollApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EndPollApiResponse>();

                        EndPollApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/polls", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEndPollDefaultImplementation(apiResponseLocalVar, endPollBody);

                        Events.ExecuteOnEndPoll(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEndPollDefaultImplementation(e, "/polls", uriBuilderLocalVar.Path, endPollBody);
                Events.ExecuteOnErrorEndPoll(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EndPollApiResponse"/>
        /// </summary>
        public partial class EndPollApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IEndPollApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EndPollApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EndPollApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EndPollApiResponse(ILogger<EndPollApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.EndPollResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.EndPollResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.EndPollResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetPolls(ref string broadcasterId, Option<List<string>> id, ref Option<string> first, ref Option<string> after);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetPolls(string broadcasterId, Option<List<string>> id, Option<string> first, Option<string> after)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));

            if (first.IsSet && first.Value == null)
                throw new ArgumentNullException(nameof(first));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void AfterGetPollsDefaultImplementation(IGetPollsApiResponse apiResponseLocalVar, string broadcasterId, Option<List<string>> id, Option<string> first, Option<string> after)
        {
            bool suppressDefaultLog = false;
            AfterGetPolls(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, id, first, after);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void AfterGetPolls(ref bool suppressDefaultLog, IGetPollsApiResponse apiResponseLocalVar, string broadcasterId, Option<List<string>> id, Option<string> first, Option<string> after);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void OnErrorGetPollsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<List<string>> id, Option<string> first, Option<string> after)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetPolls(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, id, first, after);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void OnErrorGetPolls(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<List<string>> id, Option<string> first, Option<string> after);

        /// <summary>
        /// Gets a list of polls that the broadcaster created. Gets a list of polls that the broadcaster created.  Polls are available for 90 days after they’re created.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:polls** or **channel:manage:polls** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that created the polls. This ID must match the user ID in the user access token.</param>
        /// <param name="id">A list of IDs that identify the polls to return. To specify more than one ID, include this parameter for each poll you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 20 IDs.      Specify this parameter only if you want to filter the list that the request returns. The endpoint ignores duplicate IDs and those not owned by this broadcaster. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 20 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPollsApiResponse"/>&gt;</returns>
        public async Task<IGetPollsApiResponse?> GetPollsOrDefaultAsync(string broadcasterId, Option<List<string>> id = default, Option<string> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetPollsAsync(broadcasterId, id, first, after, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets a list of polls that the broadcaster created. Gets a list of polls that the broadcaster created.  Polls are available for 90 days after they’re created.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:polls** or **channel:manage:polls** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that created the polls. This ID must match the user ID in the user access token.</param>
        /// <param name="id">A list of IDs that identify the polls to return. To specify more than one ID, include this parameter for each poll you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 20 IDs.      Specify this parameter only if you want to filter the list that the request returns. The endpoint ignores duplicate IDs and those not owned by this broadcaster. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 20 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPollsApiResponse"/>&gt;</returns>
        public async Task<IGetPollsApiResponse> GetPollsAsync(string broadcasterId, Option<List<string>> id = default, Option<string> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetPolls(broadcasterId, id, first, after);

                FormatGetPolls(ref broadcasterId, id, ref first, ref after);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/polls"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/polls");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetPollsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetPollsApiResponse>();

                        GetPollsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/polls", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetPollsDefaultImplementation(apiResponseLocalVar, broadcasterId, id, first, after);

                        Events.ExecuteOnGetPolls(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetPollsDefaultImplementation(e, "/polls", uriBuilderLocalVar.Path, broadcasterId, id, first, after);
                Events.ExecuteOnErrorGetPolls(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetPollsApiResponse"/>
        /// </summary>
        public partial class GetPollsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetPollsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetPollsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetPollsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetPollsApiResponse(ILogger<GetPollsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetPollsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetPollsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetPollsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
