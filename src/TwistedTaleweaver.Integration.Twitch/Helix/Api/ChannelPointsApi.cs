// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;
using TwistedTaleweaver.Integration.Twitch.Helix.Model;
using System.Diagnostics.CodeAnalysis;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IChannelPointsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ChannelPointsApiEvents Events { get; }

        /// <summary>
        /// Creates a Custom Reward in the broadcaster’s channel.
        /// </summary>
        /// <remarks>
        /// Creates a Custom Reward in the broadcaster’s channel. The maximum number of custom rewards per channel is 50, which includes both enabled and disabled rewards.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster to add the custom reward to. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="createCustomRewardsBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateCustomRewardsApiResponse"/>&gt;</returns>
        Task<ICreateCustomRewardsApiResponse> CreateCustomRewardsAsync(string broadcasterId, Option<CreateCustomRewardsBody> createCustomRewardsBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates a Custom Reward in the broadcaster’s channel.
        /// </summary>
        /// <remarks>
        /// Creates a Custom Reward in the broadcaster’s channel. The maximum number of custom rewards per channel is 50, which includes both enabled and disabled rewards.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster to add the custom reward to. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="createCustomRewardsBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateCustomRewardsApiResponse"/>?&gt;</returns>
        Task<ICreateCustomRewardsApiResponse?> CreateCustomRewardsOrDefaultAsync(string broadcasterId, Option<CreateCustomRewardsBody> createCustomRewardsBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes a custom reward that the broadcaster created.
        /// </summary>
        /// <remarks>
        /// Deletes a custom reward that the broadcaster created.  The app used to create the reward is the only app that may delete it. If the reward’s redemption status is UNFULFILLED at the time the reward is deleted, its redemption status is marked as FULFILLED.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that created the custom reward. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="id">The ID of the custom reward to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCustomRewardApiResponse"/>&gt;</returns>
        Task<IDeleteCustomRewardApiResponse> DeleteCustomRewardAsync(string broadcasterId, string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes a custom reward that the broadcaster created.
        /// </summary>
        /// <remarks>
        /// Deletes a custom reward that the broadcaster created.  The app used to create the reward is the only app that may delete it. If the reward’s redemption status is UNFULFILLED at the time the reward is deleted, its redemption status is marked as FULFILLED.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that created the custom reward. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="id">The ID of the custom reward to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCustomRewardApiResponse"/>?&gt;</returns>
        Task<IDeleteCustomRewardApiResponse?> DeleteCustomRewardOrDefaultAsync(string broadcasterId, string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of custom rewards that the specified broadcaster created.
        /// </summary>
        /// <remarks>
        /// Gets a list of custom rewards that the specified broadcaster created.  **NOTE**: A channel may offer a maximum of 50 rewards, which includes both enabled and disabled rewards.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose custom rewards you want to get. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="id">A list of IDs to filter the rewards by. To specify more than one ID, include this parameter for each reward you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 50 IDs.      Duplicate IDs are ignored. The response contains only the IDs that were found. If none of the IDs were found, the response is 404 Not Found. (optional)</param>
        /// <param name="onlyManageableRewards">A Boolean value that determines whether the response contains only the custom rewards that the app may manage (the app is identified by the ID in the Client-Id header). Set to **true** to get only the custom rewards that the app may manage. The default is **false**. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCustomRewardApiResponse"/>&gt;</returns>
        Task<IGetCustomRewardApiResponse> GetCustomRewardAsync(string broadcasterId, Option<List<string>> id = default, Option<bool> onlyManageableRewards = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of custom rewards that the specified broadcaster created.
        /// </summary>
        /// <remarks>
        /// Gets a list of custom rewards that the specified broadcaster created.  **NOTE**: A channel may offer a maximum of 50 rewards, which includes both enabled and disabled rewards.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose custom rewards you want to get. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="id">A list of IDs to filter the rewards by. To specify more than one ID, include this parameter for each reward you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 50 IDs.      Duplicate IDs are ignored. The response contains only the IDs that were found. If none of the IDs were found, the response is 404 Not Found. (optional)</param>
        /// <param name="onlyManageableRewards">A Boolean value that determines whether the response contains only the custom rewards that the app may manage (the app is identified by the ID in the Client-Id header). Set to **true** to get only the custom rewards that the app may manage. The default is **false**. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCustomRewardApiResponse"/>?&gt;</returns>
        Task<IGetCustomRewardApiResponse?> GetCustomRewardOrDefaultAsync(string broadcasterId, Option<List<string>> id = default, Option<bool> onlyManageableRewards = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of redemptions for a custom reward.
        /// </summary>
        /// <remarks>
        /// Gets a list of redemptions for the specified custom reward. The app used to create the reward is the only app that may get the redemptions.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the custom reward. This ID must match the user ID found in the user OAuth token.</param>
        /// <param name="rewardId">The ID that identifies the custom reward whose redemptions you want to get.</param>
        /// <param name="status">The status of the redemptions to return. The possible case-sensitive values are:      * CANCELED * FULFILLED * UNFULFILLED    **NOTE**: This field is required only if you don’t specify the _id_ query parameter.      **NOTE**: Canceled and fulfilled redemptions are returned for only a few days after they’re canceled or fulfilled. (optional)</param>
        /// <param name="id">A list of IDs to filter the redemptions by. To specify more than one ID, include this parameter for each redemption you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 50 IDs.      Duplicate IDs are ignored. The response contains only the IDs that were found. If none of the IDs were found, the response is 404 Not Found. (optional)</param>
        /// <param name="sort">The order to sort redemptions by. The possible case-sensitive values are:      * OLDEST * NEWEST    The default is OLDEST. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read more](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="first">The maximum number of redemptions to return per page in the response. The minimum page size is 1 redemption per page and the maximum is 50\\. The default is 20. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCustomRewardRedemptionApiResponse"/>&gt;</returns>
        Task<IGetCustomRewardRedemptionApiResponse> GetCustomRewardRedemptionAsync(string broadcasterId, string rewardId, Option<string> status = default, Option<List<string>> id = default, Option<string> sort = default, Option<string> after = default, Option<int> first = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of redemptions for a custom reward.
        /// </summary>
        /// <remarks>
        /// Gets a list of redemptions for the specified custom reward. The app used to create the reward is the only app that may get the redemptions.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the custom reward. This ID must match the user ID found in the user OAuth token.</param>
        /// <param name="rewardId">The ID that identifies the custom reward whose redemptions you want to get.</param>
        /// <param name="status">The status of the redemptions to return. The possible case-sensitive values are:      * CANCELED * FULFILLED * UNFULFILLED    **NOTE**: This field is required only if you don’t specify the _id_ query parameter.      **NOTE**: Canceled and fulfilled redemptions are returned for only a few days after they’re canceled or fulfilled. (optional)</param>
        /// <param name="id">A list of IDs to filter the redemptions by. To specify more than one ID, include this parameter for each redemption you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 50 IDs.      Duplicate IDs are ignored. The response contains only the IDs that were found. If none of the IDs were found, the response is 404 Not Found. (optional)</param>
        /// <param name="sort">The order to sort redemptions by. The possible case-sensitive values are:      * OLDEST * NEWEST    The default is OLDEST. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read more](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="first">The maximum number of redemptions to return per page in the response. The minimum page size is 1 redemption per page and the maximum is 50\\. The default is 20. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCustomRewardRedemptionApiResponse"/>?&gt;</returns>
        Task<IGetCustomRewardRedemptionApiResponse?> GetCustomRewardRedemptionOrDefaultAsync(string broadcasterId, string rewardId, Option<string> status = default, Option<List<string>> id = default, Option<string> sort = default, Option<string> after = default, Option<int> first = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates a custom reward.
        /// </summary>
        /// <remarks>
        /// Updates a custom reward. The app used to create the reward is the only app that may update the reward.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/api/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.  __Request Body:__  The body of the request should contain only the fields you’re updating.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that’s updating the reward. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="id">The ID of the reward to update.</param>
        /// <param name="updateCustomRewardBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCustomRewardApiResponse"/>&gt;</returns>
        Task<IUpdateCustomRewardApiResponse> UpdateCustomRewardAsync(string broadcasterId, string id, Option<UpdateCustomRewardBody> updateCustomRewardBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates a custom reward.
        /// </summary>
        /// <remarks>
        /// Updates a custom reward. The app used to create the reward is the only app that may update the reward.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/api/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.  __Request Body:__  The body of the request should contain only the fields you’re updating.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that’s updating the reward. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="id">The ID of the reward to update.</param>
        /// <param name="updateCustomRewardBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCustomRewardApiResponse"/>?&gt;</returns>
        Task<IUpdateCustomRewardApiResponse?> UpdateCustomRewardOrDefaultAsync(string broadcasterId, string id, Option<UpdateCustomRewardBody> updateCustomRewardBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates a redemption’s status.
        /// </summary>
        /// <remarks>
        /// Updates a redemption’s status. You may update a redemption only if its status is UNFULFILLED. The app used to create the reward is the only app that may update the redemption.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A list of IDs that identify the redemptions to update. To specify more than one ID, include this parameter for each redemption you want to update. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 50 IDs.</param>
        /// <param name="broadcasterId">The ID of the broadcaster that’s updating the redemption. This ID must match the user ID in the user access token.</param>
        /// <param name="rewardId">The ID that identifies the reward that’s been redeemed.</param>
        /// <param name="updateRedemptionStatusBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateRedemptionStatusApiResponse"/>&gt;</returns>
        Task<IUpdateRedemptionStatusApiResponse> UpdateRedemptionStatusAsync(List<string> id, string broadcasterId, string rewardId, Option<UpdateRedemptionStatusBody> updateRedemptionStatusBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates a redemption’s status.
        /// </summary>
        /// <remarks>
        /// Updates a redemption’s status. You may update a redemption only if its status is UNFULFILLED. The app used to create the reward is the only app that may update the redemption.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
        /// </remarks>
        /// <param name="id">A list of IDs that identify the redemptions to update. To specify more than one ID, include this parameter for each redemption you want to update. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 50 IDs.</param>
        /// <param name="broadcasterId">The ID of the broadcaster that’s updating the redemption. This ID must match the user ID in the user access token.</param>
        /// <param name="rewardId">The ID that identifies the reward that’s been redeemed.</param>
        /// <param name="updateRedemptionStatusBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateRedemptionStatusApiResponse"/>?&gt;</returns>
        Task<IUpdateRedemptionStatusApiResponse?> UpdateRedemptionStatusOrDefaultAsync(List<string> id, string broadcasterId, string rewardId, Option<UpdateRedemptionStatusBody> updateRedemptionStatusBody = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateCustomRewardsApiResponse"/>
    /// </summary>
    public interface ICreateCustomRewardsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateCustomRewardsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteCustomRewardApiResponse"/>
    /// </summary>
    public interface IDeleteCustomRewardApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetCustomRewardApiResponse"/>
    /// </summary>
    public interface IGetCustomRewardApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetCustomRewardResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetCustomRewardRedemptionApiResponse"/>
    /// </summary>
    public interface IGetCustomRewardRedemptionApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetCustomRewardRedemptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateCustomRewardApiResponse"/>
    /// </summary>
    public interface IUpdateCustomRewardApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateCustomRewardResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateRedemptionStatusApiResponse"/>
    /// </summary>
    public interface IUpdateRedemptionStatusApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateRedemptionStatusResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ChannelPointsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateCustomRewards;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateCustomRewards;

        internal void ExecuteOnCreateCustomRewards(ChannelPointsApi.CreateCustomRewardsApiResponse apiResponse)
        {
            OnCreateCustomRewards?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateCustomRewards(Exception exception)
        {
            OnErrorCreateCustomRewards?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteCustomReward;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteCustomReward;

        internal void ExecuteOnDeleteCustomReward(ChannelPointsApi.DeleteCustomRewardApiResponse apiResponse)
        {
            OnDeleteCustomReward?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteCustomReward(Exception exception)
        {
            OnErrorDeleteCustomReward?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetCustomReward;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetCustomReward;

        internal void ExecuteOnGetCustomReward(ChannelPointsApi.GetCustomRewardApiResponse apiResponse)
        {
            OnGetCustomReward?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetCustomReward(Exception exception)
        {
            OnErrorGetCustomReward?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetCustomRewardRedemption;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetCustomRewardRedemption;

        internal void ExecuteOnGetCustomRewardRedemption(ChannelPointsApi.GetCustomRewardRedemptionApiResponse apiResponse)
        {
            OnGetCustomRewardRedemption?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetCustomRewardRedemption(Exception exception)
        {
            OnErrorGetCustomRewardRedemption?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateCustomReward;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateCustomReward;

        internal void ExecuteOnUpdateCustomReward(ChannelPointsApi.UpdateCustomRewardApiResponse apiResponse)
        {
            OnUpdateCustomReward?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateCustomReward(Exception exception)
        {
            OnErrorUpdateCustomReward?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateRedemptionStatus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateRedemptionStatus;

        internal void ExecuteOnUpdateRedemptionStatus(ChannelPointsApi.UpdateRedemptionStatusApiResponse apiResponse)
        {
            OnUpdateRedemptionStatus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateRedemptionStatus(Exception exception)
        {
            OnErrorUpdateRedemptionStatus?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ChannelPointsApi : IChannelPointsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ChannelPointsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ChannelPointsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelPointsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ChannelPointsApi(ILogger<ChannelPointsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ChannelPointsApiEvents channelPointsApiEvents,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ChannelPointsApi>();
            HttpClient = httpClient;
            Events = channelPointsApiEvents;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatCreateCustomRewards(ref string broadcasterId, Option<CreateCustomRewardsBody> createCustomRewardsBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="createCustomRewardsBody"></param>
        /// <returns></returns>
        private void ValidateCreateCustomRewards(string broadcasterId, Option<CreateCustomRewardsBody> createCustomRewardsBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (createCustomRewardsBody.IsSet && createCustomRewardsBody.Value == null)
                throw new ArgumentNullException(nameof(createCustomRewardsBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="createCustomRewardsBody"></param>
        private void AfterCreateCustomRewardsDefaultImplementation(ICreateCustomRewardsApiResponse apiResponseLocalVar, string broadcasterId, Option<CreateCustomRewardsBody> createCustomRewardsBody)
        {
            bool suppressDefaultLog = false;
            AfterCreateCustomRewards(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, createCustomRewardsBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="createCustomRewardsBody"></param>
        partial void AfterCreateCustomRewards(ref bool suppressDefaultLog, ICreateCustomRewardsApiResponse apiResponseLocalVar, string broadcasterId, Option<CreateCustomRewardsBody> createCustomRewardsBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="createCustomRewardsBody"></param>
        private void OnErrorCreateCustomRewardsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<CreateCustomRewardsBody> createCustomRewardsBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateCustomRewards(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, createCustomRewardsBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="createCustomRewardsBody"></param>
        partial void OnErrorCreateCustomRewards(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<CreateCustomRewardsBody> createCustomRewardsBody);

        /// <summary>
        /// Creates a Custom Reward in the broadcaster’s channel. Creates a Custom Reward in the broadcaster’s channel. The maximum number of custom rewards per channel is 50, which includes both enabled and disabled rewards.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster to add the custom reward to. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="createCustomRewardsBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateCustomRewardsApiResponse"/>&gt;</returns>
        public async Task<ICreateCustomRewardsApiResponse?> CreateCustomRewardsOrDefaultAsync(string broadcasterId, Option<CreateCustomRewardsBody> createCustomRewardsBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateCustomRewardsAsync(broadcasterId, createCustomRewardsBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Creates a Custom Reward in the broadcaster’s channel. Creates a Custom Reward in the broadcaster’s channel. The maximum number of custom rewards per channel is 50, which includes both enabled and disabled rewards.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster to add the custom reward to. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="createCustomRewardsBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateCustomRewardsApiResponse"/>&gt;</returns>
        public async Task<ICreateCustomRewardsApiResponse> CreateCustomRewardsAsync(string broadcasterId, Option<CreateCustomRewardsBody> createCustomRewardsBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateCustomRewards(broadcasterId, createCustomRewardsBody);

                FormatCreateCustomRewards(ref broadcasterId, createCustomRewardsBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/channel_points/custom_rewards"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/channel_points/custom_rewards");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (createCustomRewardsBody.IsSet)
                        httpRequestMessageLocalVar.Content = (createCustomRewardsBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createCustomRewardsBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateCustomRewardsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateCustomRewardsApiResponse>();

                        CreateCustomRewardsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channel_points/custom_rewards", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateCustomRewardsDefaultImplementation(apiResponseLocalVar, broadcasterId, createCustomRewardsBody);

                        Events.ExecuteOnCreateCustomRewards(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateCustomRewardsDefaultImplementation(e, "/channel_points/custom_rewards", uriBuilderLocalVar.Path, broadcasterId, createCustomRewardsBody);
                Events.ExecuteOnErrorCreateCustomRewards(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateCustomRewardsApiResponse"/>
        /// </summary>
        public partial class CreateCustomRewardsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ICreateCustomRewardsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateCustomRewardsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateCustomRewardsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateCustomRewardsApiResponse(ILogger<CreateCustomRewardsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateCustomRewardsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateCustomRewardsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateCustomRewardsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteCustomReward(ref string broadcasterId, ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateDeleteCustomReward(string broadcasterId, string id)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        private void AfterDeleteCustomRewardDefaultImplementation(IDeleteCustomRewardApiResponse apiResponseLocalVar, string broadcasterId, string id)
        {
            bool suppressDefaultLog = false;
            AfterDeleteCustomReward(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        partial void AfterDeleteCustomReward(ref bool suppressDefaultLog, IDeleteCustomRewardApiResponse apiResponseLocalVar, string broadcasterId, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteCustomRewardDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteCustomReward(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        partial void OnErrorDeleteCustomReward(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string id);

        /// <summary>
        /// Deletes a custom reward that the broadcaster created. Deletes a custom reward that the broadcaster created.  The app used to create the reward is the only app that may delete it. If the reward’s redemption status is UNFULFILLED at the time the reward is deleted, its redemption status is marked as FULFILLED.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that created the custom reward. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="id">The ID of the custom reward to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCustomRewardApiResponse"/>&gt;</returns>
        public async Task<IDeleteCustomRewardApiResponse?> DeleteCustomRewardOrDefaultAsync(string broadcasterId, string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteCustomRewardAsync(broadcasterId, id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Deletes a custom reward that the broadcaster created. Deletes a custom reward that the broadcaster created.  The app used to create the reward is the only app that may delete it. If the reward’s redemption status is UNFULFILLED at the time the reward is deleted, its redemption status is marked as FULFILLED.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that created the custom reward. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="id">The ID of the custom reward to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCustomRewardApiResponse"/>&gt;</returns>
        public async Task<IDeleteCustomRewardApiResponse> DeleteCustomRewardAsync(string broadcasterId, string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteCustomReward(broadcasterId, id);

                FormatDeleteCustomReward(ref broadcasterId, ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/channel_points/custom_rewards"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/channel_points/custom_rewards");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteCustomRewardApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteCustomRewardApiResponse>();

                        DeleteCustomRewardApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channel_points/custom_rewards", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteCustomRewardDefaultImplementation(apiResponseLocalVar, broadcasterId, id);

                        Events.ExecuteOnDeleteCustomReward(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteCustomRewardDefaultImplementation(e, "/channel_points/custom_rewards", uriBuilderLocalVar.Path, broadcasterId, id);
                Events.ExecuteOnErrorDeleteCustomReward(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteCustomRewardApiResponse"/>
        /// </summary>
        public partial class DeleteCustomRewardApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IDeleteCustomRewardApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteCustomRewardApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteCustomRewardApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteCustomRewardApiResponse(ILogger<DeleteCustomRewardApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetCustomReward(ref string broadcasterId, Option<List<string>> id, ref Option<bool> onlyManageableRewards);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateGetCustomReward(string broadcasterId, Option<List<string>> id)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="onlyManageableRewards"></param>
        private void AfterGetCustomRewardDefaultImplementation(IGetCustomRewardApiResponse apiResponseLocalVar, string broadcasterId, Option<List<string>> id, Option<bool> onlyManageableRewards)
        {
            bool suppressDefaultLog = false;
            AfterGetCustomReward(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, id, onlyManageableRewards);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="onlyManageableRewards"></param>
        partial void AfterGetCustomReward(ref bool suppressDefaultLog, IGetCustomRewardApiResponse apiResponseLocalVar, string broadcasterId, Option<List<string>> id, Option<bool> onlyManageableRewards);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="onlyManageableRewards"></param>
        private void OnErrorGetCustomRewardDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<List<string>> id, Option<bool> onlyManageableRewards)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetCustomReward(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, id, onlyManageableRewards);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="onlyManageableRewards"></param>
        partial void OnErrorGetCustomReward(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<List<string>> id, Option<bool> onlyManageableRewards);

        /// <summary>
        /// Gets a list of custom rewards that the specified broadcaster created. Gets a list of custom rewards that the specified broadcaster created.  **NOTE**: A channel may offer a maximum of 50 rewards, which includes both enabled and disabled rewards.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose custom rewards you want to get. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="id">A list of IDs to filter the rewards by. To specify more than one ID, include this parameter for each reward you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 50 IDs.      Duplicate IDs are ignored. The response contains only the IDs that were found. If none of the IDs were found, the response is 404 Not Found. (optional)</param>
        /// <param name="onlyManageableRewards">A Boolean value that determines whether the response contains only the custom rewards that the app may manage (the app is identified by the ID in the Client-Id header). Set to **true** to get only the custom rewards that the app may manage. The default is **false**. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCustomRewardApiResponse"/>&gt;</returns>
        public async Task<IGetCustomRewardApiResponse?> GetCustomRewardOrDefaultAsync(string broadcasterId, Option<List<string>> id = default, Option<bool> onlyManageableRewards = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetCustomRewardAsync(broadcasterId, id, onlyManageableRewards, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets a list of custom rewards that the specified broadcaster created. Gets a list of custom rewards that the specified broadcaster created.  **NOTE**: A channel may offer a maximum of 50 rewards, which includes both enabled and disabled rewards.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose custom rewards you want to get. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="id">A list of IDs to filter the rewards by. To specify more than one ID, include this parameter for each reward you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 50 IDs.      Duplicate IDs are ignored. The response contains only the IDs that were found. If none of the IDs were found, the response is 404 Not Found. (optional)</param>
        /// <param name="onlyManageableRewards">A Boolean value that determines whether the response contains only the custom rewards that the app may manage (the app is identified by the ID in the Client-Id header). Set to **true** to get only the custom rewards that the app may manage. The default is **false**. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCustomRewardApiResponse"/>&gt;</returns>
        public async Task<IGetCustomRewardApiResponse> GetCustomRewardAsync(string broadcasterId, Option<List<string>> id = default, Option<bool> onlyManageableRewards = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetCustomReward(broadcasterId, id);

                FormatGetCustomReward(ref broadcasterId, id, ref onlyManageableRewards);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/channel_points/custom_rewards"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/channel_points/custom_rewards");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (onlyManageableRewards.IsSet)
                        parseQueryStringLocalVar["only_manageable_rewards"] = ClientUtils.ParameterToString(onlyManageableRewards.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetCustomRewardApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetCustomRewardApiResponse>();

                        GetCustomRewardApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channel_points/custom_rewards", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetCustomRewardDefaultImplementation(apiResponseLocalVar, broadcasterId, id, onlyManageableRewards);

                        Events.ExecuteOnGetCustomReward(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetCustomRewardDefaultImplementation(e, "/channel_points/custom_rewards", uriBuilderLocalVar.Path, broadcasterId, id, onlyManageableRewards);
                Events.ExecuteOnErrorGetCustomReward(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetCustomRewardApiResponse"/>
        /// </summary>
        public partial class GetCustomRewardApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetCustomRewardApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetCustomRewardApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetCustomRewardApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetCustomRewardApiResponse(ILogger<GetCustomRewardApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetCustomRewardResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetCustomRewardResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetCustomRewardResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetCustomRewardRedemption(ref string broadcasterId, ref string rewardId, ref Option<string> status, Option<List<string>> id, ref Option<string> sort, ref Option<string> after, ref Option<int> first);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="rewardId"></param>
        /// <param name="status"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetCustomRewardRedemption(string broadcasterId, string rewardId, Option<string> status, Option<List<string>> id, Option<string> sort, Option<string> after)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (rewardId == null)
                throw new ArgumentNullException(nameof(rewardId));

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));

            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="rewardId"></param>
        /// <param name="status"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="after"></param>
        /// <param name="first"></param>
        private void AfterGetCustomRewardRedemptionDefaultImplementation(IGetCustomRewardRedemptionApiResponse apiResponseLocalVar, string broadcasterId, string rewardId, Option<string> status, Option<List<string>> id, Option<string> sort, Option<string> after, Option<int> first)
        {
            bool suppressDefaultLog = false;
            AfterGetCustomRewardRedemption(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, rewardId, status, id, sort, after, first);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="rewardId"></param>
        /// <param name="status"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="after"></param>
        /// <param name="first"></param>
        partial void AfterGetCustomRewardRedemption(ref bool suppressDefaultLog, IGetCustomRewardRedemptionApiResponse apiResponseLocalVar, string broadcasterId, string rewardId, Option<string> status, Option<List<string>> id, Option<string> sort, Option<string> after, Option<int> first);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="rewardId"></param>
        /// <param name="status"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="after"></param>
        /// <param name="first"></param>
        private void OnErrorGetCustomRewardRedemptionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string rewardId, Option<string> status, Option<List<string>> id, Option<string> sort, Option<string> after, Option<int> first)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetCustomRewardRedemption(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, rewardId, status, id, sort, after, first);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="rewardId"></param>
        /// <param name="status"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="after"></param>
        /// <param name="first"></param>
        partial void OnErrorGetCustomRewardRedemption(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string rewardId, Option<string> status, Option<List<string>> id, Option<string> sort, Option<string> after, Option<int> first);

        /// <summary>
        /// Gets a list of redemptions for a custom reward. Gets a list of redemptions for the specified custom reward. The app used to create the reward is the only app that may get the redemptions.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the custom reward. This ID must match the user ID found in the user OAuth token.</param>
        /// <param name="rewardId">The ID that identifies the custom reward whose redemptions you want to get.</param>
        /// <param name="status">The status of the redemptions to return. The possible case-sensitive values are:      * CANCELED * FULFILLED * UNFULFILLED    **NOTE**: This field is required only if you don’t specify the _id_ query parameter.      **NOTE**: Canceled and fulfilled redemptions are returned for only a few days after they’re canceled or fulfilled. (optional)</param>
        /// <param name="id">A list of IDs to filter the redemptions by. To specify more than one ID, include this parameter for each redemption you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 50 IDs.      Duplicate IDs are ignored. The response contains only the IDs that were found. If none of the IDs were found, the response is 404 Not Found. (optional)</param>
        /// <param name="sort">The order to sort redemptions by. The possible case-sensitive values are:      * OLDEST * NEWEST    The default is OLDEST. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read more](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="first">The maximum number of redemptions to return per page in the response. The minimum page size is 1 redemption per page and the maximum is 50\\. The default is 20. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCustomRewardRedemptionApiResponse"/>&gt;</returns>
        public async Task<IGetCustomRewardRedemptionApiResponse?> GetCustomRewardRedemptionOrDefaultAsync(string broadcasterId, string rewardId, Option<string> status = default, Option<List<string>> id = default, Option<string> sort = default, Option<string> after = default, Option<int> first = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetCustomRewardRedemptionAsync(broadcasterId, rewardId, status, id, sort, after, first, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets a list of redemptions for a custom reward. Gets a list of redemptions for the specified custom reward. The app used to create the reward is the only app that may get the redemptions.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the custom reward. This ID must match the user ID found in the user OAuth token.</param>
        /// <param name="rewardId">The ID that identifies the custom reward whose redemptions you want to get.</param>
        /// <param name="status">The status of the redemptions to return. The possible case-sensitive values are:      * CANCELED * FULFILLED * UNFULFILLED    **NOTE**: This field is required only if you don’t specify the _id_ query parameter.      **NOTE**: Canceled and fulfilled redemptions are returned for only a few days after they’re canceled or fulfilled. (optional)</param>
        /// <param name="id">A list of IDs to filter the redemptions by. To specify more than one ID, include this parameter for each redemption you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 50 IDs.      Duplicate IDs are ignored. The response contains only the IDs that were found. If none of the IDs were found, the response is 404 Not Found. (optional)</param>
        /// <param name="sort">The order to sort redemptions by. The possible case-sensitive values are:      * OLDEST * NEWEST    The default is OLDEST. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read more](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="first">The maximum number of redemptions to return per page in the response. The minimum page size is 1 redemption per page and the maximum is 50\\. The default is 20. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCustomRewardRedemptionApiResponse"/>&gt;</returns>
        public async Task<IGetCustomRewardRedemptionApiResponse> GetCustomRewardRedemptionAsync(string broadcasterId, string rewardId, Option<string> status = default, Option<List<string>> id = default, Option<string> sort = default, Option<string> after = default, Option<int> first = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetCustomRewardRedemption(broadcasterId, rewardId, status, id, sort, after);

                FormatGetCustomRewardRedemption(ref broadcasterId, ref rewardId, ref status, id, ref sort, ref after, ref first);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/channel_points/custom_rewards/redemptions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/channel_points/custom_rewards/redemptions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["reward_id"] = ClientUtils.ParameterToString(rewardId);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetCustomRewardRedemptionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetCustomRewardRedemptionApiResponse>();

                        GetCustomRewardRedemptionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channel_points/custom_rewards/redemptions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetCustomRewardRedemptionDefaultImplementation(apiResponseLocalVar, broadcasterId, rewardId, status, id, sort, after, first);

                        Events.ExecuteOnGetCustomRewardRedemption(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetCustomRewardRedemptionDefaultImplementation(e, "/channel_points/custom_rewards/redemptions", uriBuilderLocalVar.Path, broadcasterId, rewardId, status, id, sort, after, first);
                Events.ExecuteOnErrorGetCustomRewardRedemption(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetCustomRewardRedemptionApiResponse"/>
        /// </summary>
        public partial class GetCustomRewardRedemptionApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetCustomRewardRedemptionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetCustomRewardRedemptionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetCustomRewardRedemptionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetCustomRewardRedemptionApiResponse(ILogger<GetCustomRewardRedemptionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetCustomRewardRedemptionResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetCustomRewardRedemptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetCustomRewardRedemptionResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateCustomReward(ref string broadcasterId, ref string id, Option<UpdateCustomRewardBody> updateCustomRewardBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="updateCustomRewardBody"></param>
        /// <returns></returns>
        private void ValidateUpdateCustomReward(string broadcasterId, string id, Option<UpdateCustomRewardBody> updateCustomRewardBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (updateCustomRewardBody.IsSet && updateCustomRewardBody.Value == null)
                throw new ArgumentNullException(nameof(updateCustomRewardBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="updateCustomRewardBody"></param>
        private void AfterUpdateCustomRewardDefaultImplementation(IUpdateCustomRewardApiResponse apiResponseLocalVar, string broadcasterId, string id, Option<UpdateCustomRewardBody> updateCustomRewardBody)
        {
            bool suppressDefaultLog = false;
            AfterUpdateCustomReward(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, id, updateCustomRewardBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="updateCustomRewardBody"></param>
        partial void AfterUpdateCustomReward(ref bool suppressDefaultLog, IUpdateCustomRewardApiResponse apiResponseLocalVar, string broadcasterId, string id, Option<UpdateCustomRewardBody> updateCustomRewardBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="updateCustomRewardBody"></param>
        private void OnErrorUpdateCustomRewardDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string id, Option<UpdateCustomRewardBody> updateCustomRewardBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateCustomReward(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, id, updateCustomRewardBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="updateCustomRewardBody"></param>
        partial void OnErrorUpdateCustomReward(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string id, Option<UpdateCustomRewardBody> updateCustomRewardBody);

        /// <summary>
        /// Updates a custom reward. Updates a custom reward. The app used to create the reward is the only app that may update the reward.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/api/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.  __Request Body:__  The body of the request should contain only the fields you’re updating.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that’s updating the reward. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="id">The ID of the reward to update.</param>
        /// <param name="updateCustomRewardBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCustomRewardApiResponse"/>&gt;</returns>
        public async Task<IUpdateCustomRewardApiResponse?> UpdateCustomRewardOrDefaultAsync(string broadcasterId, string id, Option<UpdateCustomRewardBody> updateCustomRewardBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateCustomRewardAsync(broadcasterId, id, updateCustomRewardBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Updates a custom reward. Updates a custom reward. The app used to create the reward is the only app that may update the reward.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/api/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.  __Request Body:__  The body of the request should contain only the fields you’re updating.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that’s updating the reward. This ID must match the user ID found in the OAuth token.</param>
        /// <param name="id">The ID of the reward to update.</param>
        /// <param name="updateCustomRewardBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCustomRewardApiResponse"/>&gt;</returns>
        public async Task<IUpdateCustomRewardApiResponse> UpdateCustomRewardAsync(string broadcasterId, string id, Option<UpdateCustomRewardBody> updateCustomRewardBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateCustomReward(broadcasterId, id, updateCustomRewardBody);

                FormatUpdateCustomReward(ref broadcasterId, ref id, updateCustomRewardBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/channel_points/custom_rewards"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/channel_points/custom_rewards");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (updateCustomRewardBody.IsSet)
                        httpRequestMessageLocalVar.Content = (updateCustomRewardBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(updateCustomRewardBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateCustomRewardApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateCustomRewardApiResponse>();

                        UpdateCustomRewardApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channel_points/custom_rewards", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateCustomRewardDefaultImplementation(apiResponseLocalVar, broadcasterId, id, updateCustomRewardBody);

                        Events.ExecuteOnUpdateCustomReward(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateCustomRewardDefaultImplementation(e, "/channel_points/custom_rewards", uriBuilderLocalVar.Path, broadcasterId, id, updateCustomRewardBody);
                Events.ExecuteOnErrorUpdateCustomReward(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateCustomRewardApiResponse"/>
        /// </summary>
        public partial class UpdateCustomRewardApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IUpdateCustomRewardApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateCustomRewardApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateCustomRewardApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateCustomRewardApiResponse(ILogger<UpdateCustomRewardApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateCustomRewardResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateCustomRewardResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateCustomRewardResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateRedemptionStatus(List<string> id, ref string broadcasterId, ref string rewardId, Option<UpdateRedemptionStatusBody> updateRedemptionStatusBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="rewardId"></param>
        /// <param name="updateRedemptionStatusBody"></param>
        /// <returns></returns>
        private void ValidateUpdateRedemptionStatus(List<string> id, string broadcasterId, string rewardId, Option<UpdateRedemptionStatusBody> updateRedemptionStatusBody)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (rewardId == null)
                throw new ArgumentNullException(nameof(rewardId));

            if (updateRedemptionStatusBody.IsSet && updateRedemptionStatusBody.Value == null)
                throw new ArgumentNullException(nameof(updateRedemptionStatusBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="rewardId"></param>
        /// <param name="updateRedemptionStatusBody"></param>
        private void AfterUpdateRedemptionStatusDefaultImplementation(IUpdateRedemptionStatusApiResponse apiResponseLocalVar, List<string> id, string broadcasterId, string rewardId, Option<UpdateRedemptionStatusBody> updateRedemptionStatusBody)
        {
            bool suppressDefaultLog = false;
            AfterUpdateRedemptionStatus(ref suppressDefaultLog, apiResponseLocalVar, id, broadcasterId, rewardId, updateRedemptionStatusBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="rewardId"></param>
        /// <param name="updateRedemptionStatusBody"></param>
        partial void AfterUpdateRedemptionStatus(ref bool suppressDefaultLog, IUpdateRedemptionStatusApiResponse apiResponseLocalVar, List<string> id, string broadcasterId, string rewardId, Option<UpdateRedemptionStatusBody> updateRedemptionStatusBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="rewardId"></param>
        /// <param name="updateRedemptionStatusBody"></param>
        private void OnErrorUpdateRedemptionStatusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> id, string broadcasterId, string rewardId, Option<UpdateRedemptionStatusBody> updateRedemptionStatusBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateRedemptionStatus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, broadcasterId, rewardId, updateRedemptionStatusBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="rewardId"></param>
        /// <param name="updateRedemptionStatusBody"></param>
        partial void OnErrorUpdateRedemptionStatus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> id, string broadcasterId, string rewardId, Option<UpdateRedemptionStatusBody> updateRedemptionStatusBody);

        /// <summary>
        /// Updates a redemption’s status. Updates a redemption’s status. You may update a redemption only if its status is UNFULFILLED. The app used to create the reward is the only app that may update the redemption.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
        /// </summary>
        /// <param name="id">A list of IDs that identify the redemptions to update. To specify more than one ID, include this parameter for each redemption you want to update. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 50 IDs.</param>
        /// <param name="broadcasterId">The ID of the broadcaster that’s updating the redemption. This ID must match the user ID in the user access token.</param>
        /// <param name="rewardId">The ID that identifies the reward that’s been redeemed.</param>
        /// <param name="updateRedemptionStatusBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateRedemptionStatusApiResponse"/>&gt;</returns>
        public async Task<IUpdateRedemptionStatusApiResponse?> UpdateRedemptionStatusOrDefaultAsync(List<string> id, string broadcasterId, string rewardId, Option<UpdateRedemptionStatusBody> updateRedemptionStatusBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateRedemptionStatusAsync(id, broadcasterId, rewardId, updateRedemptionStatusBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Updates a redemption’s status. Updates a redemption’s status. You may update a redemption only if its status is UNFULFILLED. The app used to create the reward is the only app that may update the redemption.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A list of IDs that identify the redemptions to update. To specify more than one ID, include this parameter for each redemption you want to update. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 50 IDs.</param>
        /// <param name="broadcasterId">The ID of the broadcaster that’s updating the redemption. This ID must match the user ID in the user access token.</param>
        /// <param name="rewardId">The ID that identifies the reward that’s been redeemed.</param>
        /// <param name="updateRedemptionStatusBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateRedemptionStatusApiResponse"/>&gt;</returns>
        public async Task<IUpdateRedemptionStatusApiResponse> UpdateRedemptionStatusAsync(List<string> id, string broadcasterId, string rewardId, Option<UpdateRedemptionStatusBody> updateRedemptionStatusBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateRedemptionStatus(id, broadcasterId, rewardId, updateRedemptionStatusBody);

                FormatUpdateRedemptionStatus(id, ref broadcasterId, ref rewardId, updateRedemptionStatusBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/channel_points/custom_rewards/redemptions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/channel_points/custom_rewards/redemptions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id);
                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["reward_id"] = ClientUtils.ParameterToString(rewardId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (updateRedemptionStatusBody.IsSet)
                        httpRequestMessageLocalVar.Content = (updateRedemptionStatusBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(updateRedemptionStatusBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateRedemptionStatusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateRedemptionStatusApiResponse>();

                        UpdateRedemptionStatusApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channel_points/custom_rewards/redemptions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateRedemptionStatusDefaultImplementation(apiResponseLocalVar, id, broadcasterId, rewardId, updateRedemptionStatusBody);

                        Events.ExecuteOnUpdateRedemptionStatus(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateRedemptionStatusDefaultImplementation(e, "/channel_points/custom_rewards/redemptions", uriBuilderLocalVar.Path, id, broadcasterId, rewardId, updateRedemptionStatusBody);
                Events.ExecuteOnErrorUpdateRedemptionStatus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateRedemptionStatusApiResponse"/>
        /// </summary>
        public partial class UpdateRedemptionStatusApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IUpdateRedemptionStatusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateRedemptionStatusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateRedemptionStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateRedemptionStatusApiResponse(ILogger<UpdateRedemptionStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateRedemptionStatusResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateRedemptionStatusResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateRedemptionStatusResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
