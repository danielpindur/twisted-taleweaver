// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;
using TwistedTaleweaver.Integration.Twitch.Helix.Model;
using System.Diagnostics.CodeAnalysis;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IExtensionsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ExtensionsApiEvents Events { get; }

        /// <summary>
        /// Creates a shared secret used to sign and verify JWT tokens.
        /// </summary>
        /// <remarks>
        /// Creates a shared secret used to sign and verify JWT tokens. Creating a new secret removes the current secrets from service. Use this function only when you are ready to use the new secret it returns.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="extensionId">The ID of the extension to apply the shared secret to.</param>
        /// <param name="delay">The amount of time, in seconds, to delay activating the secret. The delay should provide enough time for instances of the extension to gracefully switch over to the new secret. The minimum delay is 300 seconds (5 minutes). The default is 300 seconds. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateExtensionSecretApiResponse"/>&gt;</returns>
        Task<ICreateExtensionSecretApiResponse> CreateExtensionSecretAsync(string extensionId, Option<int> delay = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates a shared secret used to sign and verify JWT tokens.
        /// </summary>
        /// <remarks>
        /// Creates a shared secret used to sign and verify JWT tokens. Creating a new secret removes the current secrets from service. Use this function only when you are ready to use the new secret it returns.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </remarks>
        /// <param name="extensionId">The ID of the extension to apply the shared secret to.</param>
        /// <param name="delay">The amount of time, in seconds, to delay activating the secret. The delay should provide enough time for instances of the extension to gracefully switch over to the new secret. The minimum delay is 300 seconds (5 minutes). The default is 300 seconds. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateExtensionSecretApiResponse"/>?&gt;</returns>
        Task<ICreateExtensionSecretApiResponse?> CreateExtensionSecretOrDefaultAsync(string extensionId, Option<int> delay = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the list of Bits products that belongs to the extension.
        /// </summary>
        /// <remarks>
        /// Gets the list of Bits products that belongs to the extension. The client ID in the app access token identifies the extension.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must be the extension’s client ID.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="shouldIncludeAll">A Boolean value that determines whether to include disabled or expired Bits products in the response. The default is **false**. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionBitsProductsApiResponse"/>&gt;</returns>
        Task<IGetExtensionBitsProductsApiResponse> GetExtensionBitsProductsAsync(Option<bool> shouldIncludeAll = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the list of Bits products that belongs to the extension.
        /// </summary>
        /// <remarks>
        /// Gets the list of Bits products that belongs to the extension. The client ID in the app access token identifies the extension.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must be the extension’s client ID.
        /// </remarks>
        /// <param name="shouldIncludeAll">A Boolean value that determines whether to include disabled or expired Bits products in the response. The default is **false**. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionBitsProductsApiResponse"/>?&gt;</returns>
        Task<IGetExtensionBitsProductsApiResponse?> GetExtensionBitsProductsOrDefaultAsync(Option<bool> shouldIncludeAll = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the specified configuration segment from the specified extension.
        /// </summary>
        /// <remarks>
        /// Gets the specified configuration segment from the specified extension.  **Rate Limits**: You may retrieve each segment a maximum of 20 times per minute.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="extensionId">The ID of the extension that contains the configuration segment you want to get.</param>
        /// <param name="segment">The type of configuration segment to get. Possible case-sensitive values are:       * broadcaster * developer * global    You may specify one or more segments. To specify multiple segments, include the &#x60;segment&#x60; parameter for each segment to get. For example, &#x60;segment&#x3D;broadcaster&amp;segment&#x3D;developer&#x60;. Ignores duplicate segments.</param>
        /// <param name="broadcasterId">The ID of the broadcaster that installed the extension. This parameter is required if you set the _segment_ parameter to broadcaster or developer. Do not specify this parameter if you set _segment_ to global. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionConfigurationSegmentApiResponse"/>&gt;</returns>
        Task<IGetExtensionConfigurationSegmentApiResponse> GetExtensionConfigurationSegmentAsync(string extensionId, string segment, Option<string> broadcasterId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the specified configuration segment from the specified extension.
        /// </summary>
        /// <remarks>
        /// Gets the specified configuration segment from the specified extension.  **Rate Limits**: You may retrieve each segment a maximum of 20 times per minute.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </remarks>
        /// <param name="extensionId">The ID of the extension that contains the configuration segment you want to get.</param>
        /// <param name="segment">The type of configuration segment to get. Possible case-sensitive values are:       * broadcaster * developer * global    You may specify one or more segments. To specify multiple segments, include the &#x60;segment&#x60; parameter for each segment to get. For example, &#x60;segment&#x3D;broadcaster&amp;segment&#x3D;developer&#x60;. Ignores duplicate segments.</param>
        /// <param name="broadcasterId">The ID of the broadcaster that installed the extension. This parameter is required if you set the _segment_ parameter to broadcaster or developer. Do not specify this parameter if you set _segment_ to global. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionConfigurationSegmentApiResponse"/>?&gt;</returns>
        Task<IGetExtensionConfigurationSegmentApiResponse?> GetExtensionConfigurationSegmentOrDefaultAsync(string extensionId, string segment, Option<string> broadcasterId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of broadcasters that are streaming live and have installed or activated the extension.
        /// </summary>
        /// <remarks>
        /// Gets a list of broadcasters that are streaming live and have installed or activated the extension.  It may take a few minutes for the list to include or remove broadcasters that have recently gone live or stopped broadcasting.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="extensionId">The ID of the extension to get. Returns the list of broadcasters that are live and that have installed or activated this extension.</param>
        /// <param name="first">The specific maximum number of items per page in the response. The actual number returned may be less than this limit. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The &#x60;pagination&#x60; field in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionLiveChannelsApiResponse"/>&gt;</returns>
        Task<IGetExtensionLiveChannelsApiResponse> GetExtensionLiveChannelsAsync(string extensionId, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of broadcasters that are streaming live and have installed or activated the extension.
        /// </summary>
        /// <remarks>
        /// Gets a list of broadcasters that are streaming live and have installed or activated the extension.  It may take a few minutes for the list to include or remove broadcasters that have recently gone live or stopped broadcasting.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <param name="extensionId">The ID of the extension to get. Returns the list of broadcasters that are live and that have installed or activated this extension.</param>
        /// <param name="first">The specific maximum number of items per page in the response. The actual number returned may be less than this limit. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The &#x60;pagination&#x60; field in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionLiveChannelsApiResponse"/>?&gt;</returns>
        Task<IGetExtensionLiveChannelsApiResponse?> GetExtensionLiveChannelsOrDefaultAsync(string extensionId, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets an extension’s list of shared secrets.
        /// </summary>
        /// <remarks>
        /// Gets an extension’s list of shared secrets.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionSecretsApiResponse"/>&gt;</returns>
        Task<IGetExtensionSecretsApiResponse> GetExtensionSecretsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets an extension’s list of shared secrets.
        /// </summary>
        /// <remarks>
        /// Gets an extension’s list of shared secrets.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionSecretsApiResponse"/>?&gt;</returns>
        Task<IGetExtensionSecretsApiResponse?> GetExtensionSecretsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets information about an extension.
        /// </summary>
        /// <remarks>
        /// Gets information about an extension.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60; field (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)), and the &#x60;role&#x60; field must be set to _external_.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="extensionId">The ID of the extension to get.</param>
        /// <param name="extensionVersion">The version of the extension to get. If not specified, it returns the latest, released version. If you don’t have a released version, you must specify a version; otherwise, the list is empty. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionsApiResponse"/>&gt;</returns>
        Task<IGetExtensionsApiResponse> GetExtensionsAsync(string extensionId, Option<string> extensionVersion = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets information about an extension.
        /// </summary>
        /// <remarks>
        /// Gets information about an extension.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60; field (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)), and the &#x60;role&#x60; field must be set to _external_.
        /// </remarks>
        /// <param name="extensionId">The ID of the extension to get.</param>
        /// <param name="extensionVersion">The version of the extension to get. If not specified, it returns the latest, released version. If you don’t have a released version, you must specify a version; otherwise, the list is empty. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionsApiResponse"/>?&gt;</returns>
        Task<IGetExtensionsApiResponse?> GetExtensionsOrDefaultAsync(string extensionId, Option<string> extensionVersion = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets information about a released extension.
        /// </summary>
        /// <remarks>
        /// Gets information about a released extension. Returns the extension if its &#x60;state&#x60; is Released.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="extensionId">The ID of the extension to get.</param>
        /// <param name="extensionVersion">The version of the extension to get. If not specified, it returns the latest version. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetReleasedExtensionsApiResponse"/>&gt;</returns>
        Task<IGetReleasedExtensionsApiResponse> GetReleasedExtensionsAsync(string extensionId, Option<string> extensionVersion = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets information about a released extension.
        /// </summary>
        /// <remarks>
        /// Gets information about a released extension. Returns the extension if its &#x60;state&#x60; is Released.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <param name="extensionId">The ID of the extension to get.</param>
        /// <param name="extensionVersion">The version of the extension to get. If not specified, it returns the latest version. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetReleasedExtensionsApiResponse"/>?&gt;</returns>
        Task<IGetReleasedExtensionsApiResponse?> GetReleasedExtensionsOrDefaultAsync(string extensionId, Option<string> extensionVersion = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Sends a message to the specified broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// Sends a message to the specified broadcaster’s chat room. The extension’s name is used as the username for the message in the chat room. To send a chat message, your extension must enable **Chat Capabilities** (under your extension’s **Capabilities** tab).  **Rate Limits**: You may send a maximum of 12 messages per minute per channel.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60; and &#x60;user_id&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that has activated the extension.</param>
        /// <param name="sendExtensionChatMessageBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendExtensionChatMessageApiResponse"/>&gt;</returns>
        Task<ISendExtensionChatMessageApiResponse> SendExtensionChatMessageAsync(string broadcasterId, Option<SendExtensionChatMessageBody> sendExtensionChatMessageBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Sends a message to the specified broadcaster’s chat room.
        /// </summary>
        /// <remarks>
        /// Sends a message to the specified broadcaster’s chat room. The extension’s name is used as the username for the message in the chat room. To send a chat message, your extension must enable **Chat Capabilities** (under your extension’s **Capabilities** tab).  **Rate Limits**: You may send a maximum of 12 messages per minute per channel.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60; and &#x60;user_id&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that has activated the extension.</param>
        /// <param name="sendExtensionChatMessageBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendExtensionChatMessageApiResponse"/>?&gt;</returns>
        Task<ISendExtensionChatMessageApiResponse?> SendExtensionChatMessageOrDefaultAsync(string broadcasterId, Option<SendExtensionChatMessageBody> sendExtensionChatMessageBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Sends a message to one or more viewers.
        /// </summary>
        /// <remarks>
        /// Sends a message to one or more viewers. You can send messages to a specific channel or to all channels where your extension is active. This endpoint uses the same mechanism as the [send](https://dev.twitch.tv/docs/extensions/reference#send) JavaScript helper function used to send messages.  **Rate Limits**: You may send a maximum of 100 messages per minute per combination of extension client ID and broadcaster ID.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)) along with the &#x60;channel_id&#x60; and &#x60;pubsub_perms&#x60; fields. The &#x60;role&#x60; field must be set to _external_.  To send the message to a specific channel, set the &#x60;channel_id&#x60; field in the JWT to the channel’s ID and set the &#x60;pubsub_perms.send&#x60; array to _broadcast_.  &#x60;&#x60;&#x60; {   \&quot;exp\&quot;: 1503343947,   \&quot;user_id\&quot;: \&quot;27419011\&quot;,   \&quot;role\&quot;: \&quot;external\&quot;,   \&quot;channel_id\&quot;: \&quot;27419011\&quot;,   \&quot;pubsub_perms\&quot;: {     \&quot;send\&quot;:[       \&quot;broadcast\&quot;     ]   } }  &#x60;&#x60;&#x60;  To send the message to all channels on which your extension is active, set the &#x60;channel_id&#x60; field to _all_ and set the &#x60;pubsub_perms.send&#x60; array to _global_.  &#x60;&#x60;&#x60; {   \&quot;exp\&quot;: 1503343947,   \&quot;user_id\&quot;: \&quot;27419011\&quot;,   \&quot;role\&quot;: \&quot;external\&quot;,   \&quot;channel_id\&quot;: \&quot;all\&quot;,   \&quot;pubsub_perms\&quot;: {     \&quot;send\&quot;:[       \&quot;global\&quot;     ]   } }  &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendExtensionPubSubMessageBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendExtensionPubsubMessageApiResponse"/>&gt;</returns>
        Task<ISendExtensionPubsubMessageApiResponse> SendExtensionPubsubMessageAsync(Option<SendExtensionPubSubMessageBody> sendExtensionPubSubMessageBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Sends a message to one or more viewers.
        /// </summary>
        /// <remarks>
        /// Sends a message to one or more viewers. You can send messages to a specific channel or to all channels where your extension is active. This endpoint uses the same mechanism as the [send](https://dev.twitch.tv/docs/extensions/reference#send) JavaScript helper function used to send messages.  **Rate Limits**: You may send a maximum of 100 messages per minute per combination of extension client ID and broadcaster ID.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)) along with the &#x60;channel_id&#x60; and &#x60;pubsub_perms&#x60; fields. The &#x60;role&#x60; field must be set to _external_.  To send the message to a specific channel, set the &#x60;channel_id&#x60; field in the JWT to the channel’s ID and set the &#x60;pubsub_perms.send&#x60; array to _broadcast_.  &#x60;&#x60;&#x60; {   \&quot;exp\&quot;: 1503343947,   \&quot;user_id\&quot;: \&quot;27419011\&quot;,   \&quot;role\&quot;: \&quot;external\&quot;,   \&quot;channel_id\&quot;: \&quot;27419011\&quot;,   \&quot;pubsub_perms\&quot;: {     \&quot;send\&quot;:[       \&quot;broadcast\&quot;     ]   } }  &#x60;&#x60;&#x60;  To send the message to all channels on which your extension is active, set the &#x60;channel_id&#x60; field to _all_ and set the &#x60;pubsub_perms.send&#x60; array to _global_.  &#x60;&#x60;&#x60; {   \&quot;exp\&quot;: 1503343947,   \&quot;user_id\&quot;: \&quot;27419011\&quot;,   \&quot;role\&quot;: \&quot;external\&quot;,   \&quot;channel_id\&quot;: \&quot;all\&quot;,   \&quot;pubsub_perms\&quot;: {     \&quot;send\&quot;:[       \&quot;global\&quot;     ]   } }  &#x60;&#x60;&#x60;
        /// </remarks>
        /// <param name="sendExtensionPubSubMessageBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendExtensionPubsubMessageApiResponse"/>?&gt;</returns>
        Task<ISendExtensionPubsubMessageApiResponse?> SendExtensionPubsubMessageOrDefaultAsync(Option<SendExtensionPubSubMessageBody> sendExtensionPubSubMessageBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates a configuration segment.
        /// </summary>
        /// <remarks>
        /// Updates a configuration segment. The segment is limited to 5 KB. Extensions that are active on a channel do not receive the updated configuration.  **Rate Limits**: You may update the configuration a maximum of 20 times per minute.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="setExtensionConfigurationSegmentBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetExtensionConfigurationSegmentApiResponse"/>&gt;</returns>
        Task<ISetExtensionConfigurationSegmentApiResponse> SetExtensionConfigurationSegmentAsync(Option<SetExtensionConfigurationSegmentBody> setExtensionConfigurationSegmentBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates a configuration segment.
        /// </summary>
        /// <remarks>
        /// Updates a configuration segment. The segment is limited to 5 KB. Extensions that are active on a channel do not receive the updated configuration.  **Rate Limits**: You may update the configuration a maximum of 20 times per minute.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </remarks>
        /// <param name="setExtensionConfigurationSegmentBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetExtensionConfigurationSegmentApiResponse"/>?&gt;</returns>
        Task<ISetExtensionConfigurationSegmentApiResponse?> SetExtensionConfigurationSegmentOrDefaultAsync(Option<SetExtensionConfigurationSegmentBody> setExtensionConfigurationSegmentBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the extension’s required_configuration string.
        /// </summary>
        /// <remarks>
        /// Updates the extension’s required\\_configuration string. Use this endpoint if your extension requires the broadcaster to configure the extension before activating it (to require configuration, you must select **Custom/My Own Service** in Extension [Capabilities](https://dev.twitch.tv/docs/extensions/life-cycle/#capabilities)). For more information, see [Required Configurations](https://dev.twitch.tv/docs/extensions/building#required-configurations) and [Setting Required Configuration](https://dev.twitch.tv/docs/extensions/building#setting-required-configuration-with-the-configuration-service-optional).  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an EBS. For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). Set the &#x60;role&#x60; field to _external_ and the &#x60;user_id&#x60; field to the ID of the user that owns the extension.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that installed the extension on their channel.</param>
        /// <param name="setExtensionRequiredConfigurationBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetExtensionRequiredConfigurationApiResponse"/>&gt;</returns>
        Task<ISetExtensionRequiredConfigurationApiResponse> SetExtensionRequiredConfigurationAsync(string broadcasterId, Option<SetExtensionRequiredConfigurationBody> setExtensionRequiredConfigurationBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the extension’s required_configuration string.
        /// </summary>
        /// <remarks>
        /// Updates the extension’s required\\_configuration string. Use this endpoint if your extension requires the broadcaster to configure the extension before activating it (to require configuration, you must select **Custom/My Own Service** in Extension [Capabilities](https://dev.twitch.tv/docs/extensions/life-cycle/#capabilities)). For more information, see [Required Configurations](https://dev.twitch.tv/docs/extensions/building#required-configurations) and [Setting Required Configuration](https://dev.twitch.tv/docs/extensions/building#setting-required-configuration-with-the-configuration-service-optional).  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an EBS. For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). Set the &#x60;role&#x60; field to _external_ and the &#x60;user_id&#x60; field to the ID of the user that owns the extension.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that installed the extension on their channel.</param>
        /// <param name="setExtensionRequiredConfigurationBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetExtensionRequiredConfigurationApiResponse"/>?&gt;</returns>
        Task<ISetExtensionRequiredConfigurationApiResponse?> SetExtensionRequiredConfigurationOrDefaultAsync(string broadcasterId, Option<SetExtensionRequiredConfigurationBody> setExtensionRequiredConfigurationBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Adds or updates a Bits product that the extension created.
        /// </summary>
        /// <remarks>
        /// Adds or updates a Bits product that the extension created. If the SKU doesn’t exist, the product is added. You may update all fields except the &#x60;sku&#x60; field.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must match the extension’s client ID.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateExtensionBitsProductBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateExtensionBitsProductApiResponse"/>&gt;</returns>
        Task<IUpdateExtensionBitsProductApiResponse> UpdateExtensionBitsProductAsync(Option<UpdateExtensionBitsProductBody> updateExtensionBitsProductBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Adds or updates a Bits product that the extension created.
        /// </summary>
        /// <remarks>
        /// Adds or updates a Bits product that the extension created. If the SKU doesn’t exist, the product is added. You may update all fields except the &#x60;sku&#x60; field.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must match the extension’s client ID.
        /// </remarks>
        /// <param name="updateExtensionBitsProductBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateExtensionBitsProductApiResponse"/>?&gt;</returns>
        Task<IUpdateExtensionBitsProductApiResponse?> UpdateExtensionBitsProductOrDefaultAsync(Option<UpdateExtensionBitsProductBody> updateExtensionBitsProductBody = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateExtensionSecretApiResponse"/>
    /// </summary>
    public interface ICreateExtensionSecretApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateExtensionSecretResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetExtensionBitsProductsApiResponse"/>
    /// </summary>
    public interface IGetExtensionBitsProductsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionBitsProductsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetExtensionConfigurationSegmentApiResponse"/>
    /// </summary>
    public interface IGetExtensionConfigurationSegmentApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionConfigurationSegmentResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IGetExtensionLiveChannelsApiResponse"/>
    /// </summary>
    public interface IGetExtensionLiveChannelsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionLiveChannelsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetExtensionSecretsApiResponse"/>
    /// </summary>
    public interface IGetExtensionSecretsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionSecretsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetExtensionsApiResponse"/>
    /// </summary>
    public interface IGetExtensionsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetReleasedExtensionsApiResponse"/>
    /// </summary>
    public interface IGetReleasedExtensionsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetReleasedExtensionsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="ISendExtensionChatMessageApiResponse"/>
    /// </summary>
    public interface ISendExtensionChatMessageApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="ISendExtensionPubsubMessageApiResponse"/>
    /// </summary>
    public interface ISendExtensionPubsubMessageApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }
    }

    /// <summary>
    /// The <see cref="ISetExtensionConfigurationSegmentApiResponse"/>
    /// </summary>
    public interface ISetExtensionConfigurationSegmentApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="ISetExtensionRequiredConfigurationApiResponse"/>
    /// </summary>
    public interface ISetExtensionRequiredConfigurationApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateExtensionBitsProductApiResponse"/>
    /// </summary>
    public interface IUpdateExtensionBitsProductApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateExtensionBitsProductResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ExtensionsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateExtensionSecret;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateExtensionSecret;

        internal void ExecuteOnCreateExtensionSecret(ExtensionsApi.CreateExtensionSecretApiResponse apiResponse)
        {
            OnCreateExtensionSecret?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateExtensionSecret(Exception exception)
        {
            OnErrorCreateExtensionSecret?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetExtensionBitsProducts;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetExtensionBitsProducts;

        internal void ExecuteOnGetExtensionBitsProducts(ExtensionsApi.GetExtensionBitsProductsApiResponse apiResponse)
        {
            OnGetExtensionBitsProducts?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetExtensionBitsProducts(Exception exception)
        {
            OnErrorGetExtensionBitsProducts?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetExtensionConfigurationSegment;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetExtensionConfigurationSegment;

        internal void ExecuteOnGetExtensionConfigurationSegment(ExtensionsApi.GetExtensionConfigurationSegmentApiResponse apiResponse)
        {
            OnGetExtensionConfigurationSegment?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetExtensionConfigurationSegment(Exception exception)
        {
            OnErrorGetExtensionConfigurationSegment?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetExtensionLiveChannels;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetExtensionLiveChannels;

        internal void ExecuteOnGetExtensionLiveChannels(ExtensionsApi.GetExtensionLiveChannelsApiResponse apiResponse)
        {
            OnGetExtensionLiveChannels?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetExtensionLiveChannels(Exception exception)
        {
            OnErrorGetExtensionLiveChannels?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetExtensionSecrets;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetExtensionSecrets;

        internal void ExecuteOnGetExtensionSecrets(ExtensionsApi.GetExtensionSecretsApiResponse apiResponse)
        {
            OnGetExtensionSecrets?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetExtensionSecrets(Exception exception)
        {
            OnErrorGetExtensionSecrets?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetExtensions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetExtensions;

        internal void ExecuteOnGetExtensions(ExtensionsApi.GetExtensionsApiResponse apiResponse)
        {
            OnGetExtensions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetExtensions(Exception exception)
        {
            OnErrorGetExtensions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetReleasedExtensions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetReleasedExtensions;

        internal void ExecuteOnGetReleasedExtensions(ExtensionsApi.GetReleasedExtensionsApiResponse apiResponse)
        {
            OnGetReleasedExtensions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetReleasedExtensions(Exception exception)
        {
            OnErrorGetReleasedExtensions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSendExtensionChatMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSendExtensionChatMessage;

        internal void ExecuteOnSendExtensionChatMessage(ExtensionsApi.SendExtensionChatMessageApiResponse apiResponse)
        {
            OnSendExtensionChatMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendExtensionChatMessage(Exception exception)
        {
            OnErrorSendExtensionChatMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSendExtensionPubsubMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSendExtensionPubsubMessage;

        internal void ExecuteOnSendExtensionPubsubMessage(ExtensionsApi.SendExtensionPubsubMessageApiResponse apiResponse)
        {
            OnSendExtensionPubsubMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendExtensionPubsubMessage(Exception exception)
        {
            OnErrorSendExtensionPubsubMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSetExtensionConfigurationSegment;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSetExtensionConfigurationSegment;

        internal void ExecuteOnSetExtensionConfigurationSegment(ExtensionsApi.SetExtensionConfigurationSegmentApiResponse apiResponse)
        {
            OnSetExtensionConfigurationSegment?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSetExtensionConfigurationSegment(Exception exception)
        {
            OnErrorSetExtensionConfigurationSegment?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSetExtensionRequiredConfiguration;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSetExtensionRequiredConfiguration;

        internal void ExecuteOnSetExtensionRequiredConfiguration(ExtensionsApi.SetExtensionRequiredConfigurationApiResponse apiResponse)
        {
            OnSetExtensionRequiredConfiguration?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSetExtensionRequiredConfiguration(Exception exception)
        {
            OnErrorSetExtensionRequiredConfiguration?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateExtensionBitsProduct;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateExtensionBitsProduct;

        internal void ExecuteOnUpdateExtensionBitsProduct(ExtensionsApi.UpdateExtensionBitsProductApiResponse apiResponse)
        {
            OnUpdateExtensionBitsProduct?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateExtensionBitsProduct(Exception exception)
        {
            OnErrorUpdateExtensionBitsProduct?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ExtensionsApi : IExtensionsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ExtensionsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ExtensionsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExtensionsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ExtensionsApi(ILogger<ExtensionsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ExtensionsApiEvents extensionsApiEvents,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ExtensionsApi>();
            HttpClient = httpClient;
            Events = extensionsApiEvents;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatCreateExtensionSecret(ref string extensionId, ref Option<int> delay);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="extensionId"></param>
        /// <returns></returns>
        private void ValidateCreateExtensionSecret(string extensionId)
        {
            if (extensionId == null)
                throw new ArgumentNullException(nameof(extensionId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="delay"></param>
        private void AfterCreateExtensionSecretDefaultImplementation(ICreateExtensionSecretApiResponse apiResponseLocalVar, string extensionId, Option<int> delay)
        {
            bool suppressDefaultLog = false;
            AfterCreateExtensionSecret(ref suppressDefaultLog, apiResponseLocalVar, extensionId, delay);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="delay"></param>
        partial void AfterCreateExtensionSecret(ref bool suppressDefaultLog, ICreateExtensionSecretApiResponse apiResponseLocalVar, string extensionId, Option<int> delay);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="delay"></param>
        private void OnErrorCreateExtensionSecretDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string extensionId, Option<int> delay)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateExtensionSecret(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, extensionId, delay);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="delay"></param>
        partial void OnErrorCreateExtensionSecret(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string extensionId, Option<int> delay);

        /// <summary>
        /// Creates a shared secret used to sign and verify JWT tokens. Creates a shared secret used to sign and verify JWT tokens. Creating a new secret removes the current secrets from service. Use this function only when you are ready to use the new secret it returns.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </summary>
        /// <param name="extensionId">The ID of the extension to apply the shared secret to.</param>
        /// <param name="delay">The amount of time, in seconds, to delay activating the secret. The delay should provide enough time for instances of the extension to gracefully switch over to the new secret. The minimum delay is 300 seconds (5 minutes). The default is 300 seconds. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateExtensionSecretApiResponse"/>&gt;</returns>
        public async Task<ICreateExtensionSecretApiResponse?> CreateExtensionSecretOrDefaultAsync(string extensionId, Option<int> delay = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateExtensionSecretAsync(extensionId, delay, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Creates a shared secret used to sign and verify JWT tokens. Creates a shared secret used to sign and verify JWT tokens. Creating a new secret removes the current secrets from service. Use this function only when you are ready to use the new secret it returns.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="extensionId">The ID of the extension to apply the shared secret to.</param>
        /// <param name="delay">The amount of time, in seconds, to delay activating the secret. The delay should provide enough time for instances of the extension to gracefully switch over to the new secret. The minimum delay is 300 seconds (5 minutes). The default is 300 seconds. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateExtensionSecretApiResponse"/>&gt;</returns>
        public async Task<ICreateExtensionSecretApiResponse> CreateExtensionSecretAsync(string extensionId, Option<int> delay = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateExtensionSecret(extensionId);

                FormatCreateExtensionSecret(ref extensionId, ref delay);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/extensions/jwt/secrets"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/extensions/jwt/secrets");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["extension_id"] = ClientUtils.ParameterToString(extensionId);

                    if (delay.IsSet)
                        parseQueryStringLocalVar["delay"] = ClientUtils.ParameterToString(delay.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateExtensionSecretApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateExtensionSecretApiResponse>();

                        CreateExtensionSecretApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/extensions/jwt/secrets", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateExtensionSecretDefaultImplementation(apiResponseLocalVar, extensionId, delay);

                        Events.ExecuteOnCreateExtensionSecret(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateExtensionSecretDefaultImplementation(e, "/extensions/jwt/secrets", uriBuilderLocalVar.Path, extensionId, delay);
                Events.ExecuteOnErrorCreateExtensionSecret(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateExtensionSecretApiResponse"/>
        /// </summary>
        public partial class CreateExtensionSecretApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ICreateExtensionSecretApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateExtensionSecretApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateExtensionSecretApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateExtensionSecretApiResponse(ILogger<CreateExtensionSecretApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateExtensionSecretResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateExtensionSecretResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateExtensionSecretResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetExtensionBitsProducts(ref Option<bool> shouldIncludeAll);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="shouldIncludeAll"></param>
        private void AfterGetExtensionBitsProductsDefaultImplementation(IGetExtensionBitsProductsApiResponse apiResponseLocalVar, Option<bool> shouldIncludeAll)
        {
            bool suppressDefaultLog = false;
            AfterGetExtensionBitsProducts(ref suppressDefaultLog, apiResponseLocalVar, shouldIncludeAll);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="shouldIncludeAll"></param>
        partial void AfterGetExtensionBitsProducts(ref bool suppressDefaultLog, IGetExtensionBitsProductsApiResponse apiResponseLocalVar, Option<bool> shouldIncludeAll);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="shouldIncludeAll"></param>
        private void OnErrorGetExtensionBitsProductsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool> shouldIncludeAll)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetExtensionBitsProducts(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, shouldIncludeAll);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="shouldIncludeAll"></param>
        partial void OnErrorGetExtensionBitsProducts(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool> shouldIncludeAll);

        /// <summary>
        /// Gets the list of Bits products that belongs to the extension. Gets the list of Bits products that belongs to the extension. The client ID in the app access token identifies the extension.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must be the extension’s client ID.
        /// </summary>
        /// <param name="shouldIncludeAll">A Boolean value that determines whether to include disabled or expired Bits products in the response. The default is **false**. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionBitsProductsApiResponse"/>&gt;</returns>
        public async Task<IGetExtensionBitsProductsApiResponse?> GetExtensionBitsProductsOrDefaultAsync(Option<bool> shouldIncludeAll = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetExtensionBitsProductsAsync(shouldIncludeAll, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the list of Bits products that belongs to the extension. Gets the list of Bits products that belongs to the extension. The client ID in the app access token identifies the extension.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must be the extension’s client ID.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="shouldIncludeAll">A Boolean value that determines whether to include disabled or expired Bits products in the response. The default is **false**. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionBitsProductsApiResponse"/>&gt;</returns>
        public async Task<IGetExtensionBitsProductsApiResponse> GetExtensionBitsProductsAsync(Option<bool> shouldIncludeAll = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetExtensionBitsProducts(ref shouldIncludeAll);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/bits/extensions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/bits/extensions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (shouldIncludeAll.IsSet)
                        parseQueryStringLocalVar["should_include_all"] = ClientUtils.ParameterToString(shouldIncludeAll.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetExtensionBitsProductsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetExtensionBitsProductsApiResponse>();

                        GetExtensionBitsProductsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/bits/extensions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetExtensionBitsProductsDefaultImplementation(apiResponseLocalVar, shouldIncludeAll);

                        Events.ExecuteOnGetExtensionBitsProducts(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetExtensionBitsProductsDefaultImplementation(e, "/bits/extensions", uriBuilderLocalVar.Path, shouldIncludeAll);
                Events.ExecuteOnErrorGetExtensionBitsProducts(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetExtensionBitsProductsApiResponse"/>
        /// </summary>
        public partial class GetExtensionBitsProductsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetExtensionBitsProductsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetExtensionBitsProductsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetExtensionBitsProductsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetExtensionBitsProductsApiResponse(ILogger<GetExtensionBitsProductsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionBitsProductsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionBitsProductsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionBitsProductsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetExtensionConfigurationSegment(ref string extensionId, ref string segment, ref Option<string> broadcasterId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="extensionId"></param>
        /// <param name="segment"></param>
        /// <param name="broadcasterId"></param>
        /// <returns></returns>
        private void ValidateGetExtensionConfigurationSegment(string extensionId, string segment, Option<string> broadcasterId)
        {
            if (extensionId == null)
                throw new ArgumentNullException(nameof(extensionId));

            if (segment == null)
                throw new ArgumentNullException(nameof(segment));

            if (broadcasterId.IsSet && broadcasterId.Value == null)
                throw new ArgumentNullException(nameof(broadcasterId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="segment"></param>
        /// <param name="broadcasterId"></param>
        private void AfterGetExtensionConfigurationSegmentDefaultImplementation(IGetExtensionConfigurationSegmentApiResponse apiResponseLocalVar, string extensionId, string segment, Option<string> broadcasterId)
        {
            bool suppressDefaultLog = false;
            AfterGetExtensionConfigurationSegment(ref suppressDefaultLog, apiResponseLocalVar, extensionId, segment, broadcasterId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="segment"></param>
        /// <param name="broadcasterId"></param>
        partial void AfterGetExtensionConfigurationSegment(ref bool suppressDefaultLog, IGetExtensionConfigurationSegmentApiResponse apiResponseLocalVar, string extensionId, string segment, Option<string> broadcasterId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="segment"></param>
        /// <param name="broadcasterId"></param>
        private void OnErrorGetExtensionConfigurationSegmentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string extensionId, string segment, Option<string> broadcasterId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetExtensionConfigurationSegment(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, extensionId, segment, broadcasterId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="segment"></param>
        /// <param name="broadcasterId"></param>
        partial void OnErrorGetExtensionConfigurationSegment(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string extensionId, string segment, Option<string> broadcasterId);

        /// <summary>
        /// Gets the specified configuration segment from the specified extension. Gets the specified configuration segment from the specified extension.  **Rate Limits**: You may retrieve each segment a maximum of 20 times per minute.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </summary>
        /// <param name="extensionId">The ID of the extension that contains the configuration segment you want to get.</param>
        /// <param name="segment">The type of configuration segment to get. Possible case-sensitive values are:       * broadcaster * developer * global    You may specify one or more segments. To specify multiple segments, include the &#x60;segment&#x60; parameter for each segment to get. For example, &#x60;segment&#x3D;broadcaster&amp;segment&#x3D;developer&#x60;. Ignores duplicate segments.</param>
        /// <param name="broadcasterId">The ID of the broadcaster that installed the extension. This parameter is required if you set the _segment_ parameter to broadcaster or developer. Do not specify this parameter if you set _segment_ to global. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionConfigurationSegmentApiResponse"/>&gt;</returns>
        public async Task<IGetExtensionConfigurationSegmentApiResponse?> GetExtensionConfigurationSegmentOrDefaultAsync(string extensionId, string segment, Option<string> broadcasterId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetExtensionConfigurationSegmentAsync(extensionId, segment, broadcasterId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the specified configuration segment from the specified extension. Gets the specified configuration segment from the specified extension.  **Rate Limits**: You may retrieve each segment a maximum of 20 times per minute.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="extensionId">The ID of the extension that contains the configuration segment you want to get.</param>
        /// <param name="segment">The type of configuration segment to get. Possible case-sensitive values are:       * broadcaster * developer * global    You may specify one or more segments. To specify multiple segments, include the &#x60;segment&#x60; parameter for each segment to get. For example, &#x60;segment&#x3D;broadcaster&amp;segment&#x3D;developer&#x60;. Ignores duplicate segments.</param>
        /// <param name="broadcasterId">The ID of the broadcaster that installed the extension. This parameter is required if you set the _segment_ parameter to broadcaster or developer. Do not specify this parameter if you set _segment_ to global. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionConfigurationSegmentApiResponse"/>&gt;</returns>
        public async Task<IGetExtensionConfigurationSegmentApiResponse> GetExtensionConfigurationSegmentAsync(string extensionId, string segment, Option<string> broadcasterId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetExtensionConfigurationSegment(extensionId, segment, broadcasterId);

                FormatGetExtensionConfigurationSegment(ref extensionId, ref segment, ref broadcasterId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/extensions/configurations"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/extensions/configurations");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["extension_id"] = ClientUtils.ParameterToString(extensionId);
                    parseQueryStringLocalVar["segment"] = ClientUtils.ParameterToString(segment);

                    if (broadcasterId.IsSet)
                        parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetExtensionConfigurationSegmentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetExtensionConfigurationSegmentApiResponse>();

                        GetExtensionConfigurationSegmentApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/extensions/configurations", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetExtensionConfigurationSegmentDefaultImplementation(apiResponseLocalVar, extensionId, segment, broadcasterId);

                        Events.ExecuteOnGetExtensionConfigurationSegment(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetExtensionConfigurationSegmentDefaultImplementation(e, "/extensions/configurations", uriBuilderLocalVar.Path, extensionId, segment, broadcasterId);
                Events.ExecuteOnErrorGetExtensionConfigurationSegment(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetExtensionConfigurationSegmentApiResponse"/>
        /// </summary>
        public partial class GetExtensionConfigurationSegmentApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetExtensionConfigurationSegmentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetExtensionConfigurationSegmentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetExtensionConfigurationSegmentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetExtensionConfigurationSegmentApiResponse(ILogger<GetExtensionConfigurationSegmentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionConfigurationSegmentResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionConfigurationSegmentResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionConfigurationSegmentResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetExtensionLiveChannels(ref string extensionId, ref Option<int> first, ref Option<string> after);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="extensionId"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetExtensionLiveChannels(string extensionId, Option<string> after)
        {
            if (extensionId == null)
                throw new ArgumentNullException(nameof(extensionId));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void AfterGetExtensionLiveChannelsDefaultImplementation(IGetExtensionLiveChannelsApiResponse apiResponseLocalVar, string extensionId, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLog = false;
            AfterGetExtensionLiveChannels(ref suppressDefaultLog, apiResponseLocalVar, extensionId, first, after);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void AfterGetExtensionLiveChannels(ref bool suppressDefaultLog, IGetExtensionLiveChannelsApiResponse apiResponseLocalVar, string extensionId, Option<int> first, Option<string> after);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void OnErrorGetExtensionLiveChannelsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string extensionId, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetExtensionLiveChannels(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, extensionId, first, after);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void OnErrorGetExtensionLiveChannels(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string extensionId, Option<int> first, Option<string> after);

        /// <summary>
        /// Gets a list of broadcasters that are streaming live and have installed or activated the extension. Gets a list of broadcasters that are streaming live and have installed or activated the extension.  It may take a few minutes for the list to include or remove broadcasters that have recently gone live or stopped broadcasting.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <param name="extensionId">The ID of the extension to get. Returns the list of broadcasters that are live and that have installed or activated this extension.</param>
        /// <param name="first">The specific maximum number of items per page in the response. The actual number returned may be less than this limit. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The &#x60;pagination&#x60; field in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionLiveChannelsApiResponse"/>&gt;</returns>
        public async Task<IGetExtensionLiveChannelsApiResponse?> GetExtensionLiveChannelsOrDefaultAsync(string extensionId, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetExtensionLiveChannelsAsync(extensionId, first, after, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets a list of broadcasters that are streaming live and have installed or activated the extension. Gets a list of broadcasters that are streaming live and have installed or activated the extension.  It may take a few minutes for the list to include or remove broadcasters that have recently gone live or stopped broadcasting.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="extensionId">The ID of the extension to get. Returns the list of broadcasters that are live and that have installed or activated this extension.</param>
        /// <param name="first">The specific maximum number of items per page in the response. The actual number returned may be less than this limit. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The &#x60;pagination&#x60; field in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionLiveChannelsApiResponse"/>&gt;</returns>
        public async Task<IGetExtensionLiveChannelsApiResponse> GetExtensionLiveChannelsAsync(string extensionId, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetExtensionLiveChannels(extensionId, after);

                FormatGetExtensionLiveChannels(ref extensionId, ref first, ref after);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/extensions/live"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/extensions/live");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["extension_id"] = ClientUtils.ParameterToString(extensionId);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetExtensionLiveChannelsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetExtensionLiveChannelsApiResponse>();

                        GetExtensionLiveChannelsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/extensions/live", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetExtensionLiveChannelsDefaultImplementation(apiResponseLocalVar, extensionId, first, after);

                        Events.ExecuteOnGetExtensionLiveChannels(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetExtensionLiveChannelsDefaultImplementation(e, "/extensions/live", uriBuilderLocalVar.Path, extensionId, first, after);
                Events.ExecuteOnErrorGetExtensionLiveChannels(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetExtensionLiveChannelsApiResponse"/>
        /// </summary>
        public partial class GetExtensionLiveChannelsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetExtensionLiveChannelsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetExtensionLiveChannelsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetExtensionLiveChannelsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetExtensionLiveChannelsApiResponse(ILogger<GetExtensionLiveChannelsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionLiveChannelsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionLiveChannelsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionLiveChannelsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetExtensionSecretsDefaultImplementation(IGetExtensionSecretsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetExtensionSecrets(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetExtensionSecrets(ref bool suppressDefaultLog, IGetExtensionSecretsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetExtensionSecretsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetExtensionSecrets(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetExtensionSecrets(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Gets an extension’s list of shared secrets. Gets an extension’s list of shared secrets.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionSecretsApiResponse"/>&gt;</returns>
        public async Task<IGetExtensionSecretsApiResponse?> GetExtensionSecretsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetExtensionSecretsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets an extension’s list of shared secrets. Gets an extension’s list of shared secrets.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionSecretsApiResponse"/>&gt;</returns>
        public async Task<IGetExtensionSecretsApiResponse> GetExtensionSecretsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/extensions/jwt/secrets"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/extensions/jwt/secrets");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetExtensionSecretsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetExtensionSecretsApiResponse>();

                        GetExtensionSecretsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/extensions/jwt/secrets", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetExtensionSecretsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetExtensionSecrets(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetExtensionSecretsDefaultImplementation(e, "/extensions/jwt/secrets", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetExtensionSecrets(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetExtensionSecretsApiResponse"/>
        /// </summary>
        public partial class GetExtensionSecretsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetExtensionSecretsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetExtensionSecretsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetExtensionSecretsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetExtensionSecretsApiResponse(ILogger<GetExtensionSecretsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionSecretsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionSecretsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionSecretsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetExtensions(ref string extensionId, ref Option<string> extensionVersion);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="extensionId"></param>
        /// <param name="extensionVersion"></param>
        /// <returns></returns>
        private void ValidateGetExtensions(string extensionId, Option<string> extensionVersion)
        {
            if (extensionId == null)
                throw new ArgumentNullException(nameof(extensionId));

            if (extensionVersion.IsSet && extensionVersion.Value == null)
                throw new ArgumentNullException(nameof(extensionVersion));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="extensionVersion"></param>
        private void AfterGetExtensionsDefaultImplementation(IGetExtensionsApiResponse apiResponseLocalVar, string extensionId, Option<string> extensionVersion)
        {
            bool suppressDefaultLog = false;
            AfterGetExtensions(ref suppressDefaultLog, apiResponseLocalVar, extensionId, extensionVersion);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="extensionVersion"></param>
        partial void AfterGetExtensions(ref bool suppressDefaultLog, IGetExtensionsApiResponse apiResponseLocalVar, string extensionId, Option<string> extensionVersion);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="extensionVersion"></param>
        private void OnErrorGetExtensionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string extensionId, Option<string> extensionVersion)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetExtensions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, extensionId, extensionVersion);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="extensionVersion"></param>
        partial void OnErrorGetExtensions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string extensionId, Option<string> extensionVersion);

        /// <summary>
        /// Gets information about an extension. Gets information about an extension.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60; field (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)), and the &#x60;role&#x60; field must be set to _external_.
        /// </summary>
        /// <param name="extensionId">The ID of the extension to get.</param>
        /// <param name="extensionVersion">The version of the extension to get. If not specified, it returns the latest, released version. If you don’t have a released version, you must specify a version; otherwise, the list is empty. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionsApiResponse"/>&gt;</returns>
        public async Task<IGetExtensionsApiResponse?> GetExtensionsOrDefaultAsync(string extensionId, Option<string> extensionVersion = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetExtensionsAsync(extensionId, extensionVersion, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets information about an extension. Gets information about an extension.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60; field (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)), and the &#x60;role&#x60; field must be set to _external_.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="extensionId">The ID of the extension to get.</param>
        /// <param name="extensionVersion">The version of the extension to get. If not specified, it returns the latest, released version. If you don’t have a released version, you must specify a version; otherwise, the list is empty. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionsApiResponse"/>&gt;</returns>
        public async Task<IGetExtensionsApiResponse> GetExtensionsAsync(string extensionId, Option<string> extensionVersion = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetExtensions(extensionId, extensionVersion);

                FormatGetExtensions(ref extensionId, ref extensionVersion);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/extensions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/extensions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["extension_id"] = ClientUtils.ParameterToString(extensionId);

                    if (extensionVersion.IsSet)
                        parseQueryStringLocalVar["extension_version"] = ClientUtils.ParameterToString(extensionVersion.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetExtensionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetExtensionsApiResponse>();

                        GetExtensionsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/extensions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetExtensionsDefaultImplementation(apiResponseLocalVar, extensionId, extensionVersion);

                        Events.ExecuteOnGetExtensions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetExtensionsDefaultImplementation(e, "/extensions", uriBuilderLocalVar.Path, extensionId, extensionVersion);
                Events.ExecuteOnErrorGetExtensions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetExtensionsApiResponse"/>
        /// </summary>
        public partial class GetExtensionsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetExtensionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetExtensionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetExtensionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetExtensionsApiResponse(ILogger<GetExtensionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetReleasedExtensions(ref string extensionId, ref Option<string> extensionVersion);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="extensionId"></param>
        /// <param name="extensionVersion"></param>
        /// <returns></returns>
        private void ValidateGetReleasedExtensions(string extensionId, Option<string> extensionVersion)
        {
            if (extensionId == null)
                throw new ArgumentNullException(nameof(extensionId));

            if (extensionVersion.IsSet && extensionVersion.Value == null)
                throw new ArgumentNullException(nameof(extensionVersion));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="extensionVersion"></param>
        private void AfterGetReleasedExtensionsDefaultImplementation(IGetReleasedExtensionsApiResponse apiResponseLocalVar, string extensionId, Option<string> extensionVersion)
        {
            bool suppressDefaultLog = false;
            AfterGetReleasedExtensions(ref suppressDefaultLog, apiResponseLocalVar, extensionId, extensionVersion);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="extensionVersion"></param>
        partial void AfterGetReleasedExtensions(ref bool suppressDefaultLog, IGetReleasedExtensionsApiResponse apiResponseLocalVar, string extensionId, Option<string> extensionVersion);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="extensionVersion"></param>
        private void OnErrorGetReleasedExtensionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string extensionId, Option<string> extensionVersion)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetReleasedExtensions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, extensionId, extensionVersion);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="extensionVersion"></param>
        partial void OnErrorGetReleasedExtensions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string extensionId, Option<string> extensionVersion);

        /// <summary>
        /// Gets information about a released extension. Gets information about a released extension. Returns the extension if its &#x60;state&#x60; is Released.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <param name="extensionId">The ID of the extension to get.</param>
        /// <param name="extensionVersion">The version of the extension to get. If not specified, it returns the latest version. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetReleasedExtensionsApiResponse"/>&gt;</returns>
        public async Task<IGetReleasedExtensionsApiResponse?> GetReleasedExtensionsOrDefaultAsync(string extensionId, Option<string> extensionVersion = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetReleasedExtensionsAsync(extensionId, extensionVersion, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets information about a released extension. Gets information about a released extension. Returns the extension if its &#x60;state&#x60; is Released.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="extensionId">The ID of the extension to get.</param>
        /// <param name="extensionVersion">The version of the extension to get. If not specified, it returns the latest version. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetReleasedExtensionsApiResponse"/>&gt;</returns>
        public async Task<IGetReleasedExtensionsApiResponse> GetReleasedExtensionsAsync(string extensionId, Option<string> extensionVersion = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetReleasedExtensions(extensionId, extensionVersion);

                FormatGetReleasedExtensions(ref extensionId, ref extensionVersion);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/extensions/released"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/extensions/released");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["extension_id"] = ClientUtils.ParameterToString(extensionId);

                    if (extensionVersion.IsSet)
                        parseQueryStringLocalVar["extension_version"] = ClientUtils.ParameterToString(extensionVersion.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetReleasedExtensionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetReleasedExtensionsApiResponse>();

                        GetReleasedExtensionsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/extensions/released", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetReleasedExtensionsDefaultImplementation(apiResponseLocalVar, extensionId, extensionVersion);

                        Events.ExecuteOnGetReleasedExtensions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetReleasedExtensionsDefaultImplementation(e, "/extensions/released", uriBuilderLocalVar.Path, extensionId, extensionVersion);
                Events.ExecuteOnErrorGetReleasedExtensions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetReleasedExtensionsApiResponse"/>
        /// </summary>
        public partial class GetReleasedExtensionsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetReleasedExtensionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetReleasedExtensionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetReleasedExtensionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetReleasedExtensionsApiResponse(ILogger<GetReleasedExtensionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetReleasedExtensionsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetReleasedExtensionsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetReleasedExtensionsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendExtensionChatMessage(ref string broadcasterId, Option<SendExtensionChatMessageBody> sendExtensionChatMessageBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="sendExtensionChatMessageBody"></param>
        /// <returns></returns>
        private void ValidateSendExtensionChatMessage(string broadcasterId, Option<SendExtensionChatMessageBody> sendExtensionChatMessageBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (sendExtensionChatMessageBody.IsSet && sendExtensionChatMessageBody.Value == null)
                throw new ArgumentNullException(nameof(sendExtensionChatMessageBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="sendExtensionChatMessageBody"></param>
        private void AfterSendExtensionChatMessageDefaultImplementation(ISendExtensionChatMessageApiResponse apiResponseLocalVar, string broadcasterId, Option<SendExtensionChatMessageBody> sendExtensionChatMessageBody)
        {
            bool suppressDefaultLog = false;
            AfterSendExtensionChatMessage(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, sendExtensionChatMessageBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="sendExtensionChatMessageBody"></param>
        partial void AfterSendExtensionChatMessage(ref bool suppressDefaultLog, ISendExtensionChatMessageApiResponse apiResponseLocalVar, string broadcasterId, Option<SendExtensionChatMessageBody> sendExtensionChatMessageBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="sendExtensionChatMessageBody"></param>
        private void OnErrorSendExtensionChatMessageDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<SendExtensionChatMessageBody> sendExtensionChatMessageBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendExtensionChatMessage(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, sendExtensionChatMessageBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="sendExtensionChatMessageBody"></param>
        partial void OnErrorSendExtensionChatMessage(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<SendExtensionChatMessageBody> sendExtensionChatMessageBody);

        /// <summary>
        /// Sends a message to the specified broadcaster’s chat room. Sends a message to the specified broadcaster’s chat room. The extension’s name is used as the username for the message in the chat room. To send a chat message, your extension must enable **Chat Capabilities** (under your extension’s **Capabilities** tab).  **Rate Limits**: You may send a maximum of 12 messages per minute per channel.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60; and &#x60;user_id&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that has activated the extension.</param>
        /// <param name="sendExtensionChatMessageBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendExtensionChatMessageApiResponse"/>&gt;</returns>
        public async Task<ISendExtensionChatMessageApiResponse?> SendExtensionChatMessageOrDefaultAsync(string broadcasterId, Option<SendExtensionChatMessageBody> sendExtensionChatMessageBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendExtensionChatMessageAsync(broadcasterId, sendExtensionChatMessageBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Sends a message to the specified broadcaster’s chat room. Sends a message to the specified broadcaster’s chat room. The extension’s name is used as the username for the message in the chat room. To send a chat message, your extension must enable **Chat Capabilities** (under your extension’s **Capabilities** tab).  **Rate Limits**: You may send a maximum of 12 messages per minute per channel.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60; and &#x60;user_id&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that has activated the extension.</param>
        /// <param name="sendExtensionChatMessageBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendExtensionChatMessageApiResponse"/>&gt;</returns>
        public async Task<ISendExtensionChatMessageApiResponse> SendExtensionChatMessageAsync(string broadcasterId, Option<SendExtensionChatMessageBody> sendExtensionChatMessageBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendExtensionChatMessage(broadcasterId, sendExtensionChatMessageBody);

                FormatSendExtensionChatMessage(ref broadcasterId, sendExtensionChatMessageBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/extensions/chat"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/extensions/chat");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (sendExtensionChatMessageBody.IsSet)
                        httpRequestMessageLocalVar.Content = (sendExtensionChatMessageBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendExtensionChatMessageBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SendExtensionChatMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendExtensionChatMessageApiResponse>();

                        SendExtensionChatMessageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/extensions/chat", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendExtensionChatMessageDefaultImplementation(apiResponseLocalVar, broadcasterId, sendExtensionChatMessageBody);

                        Events.ExecuteOnSendExtensionChatMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendExtensionChatMessageDefaultImplementation(e, "/extensions/chat", uriBuilderLocalVar.Path, broadcasterId, sendExtensionChatMessageBody);
                Events.ExecuteOnErrorSendExtensionChatMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendExtensionChatMessageApiResponse"/>
        /// </summary>
        public partial class SendExtensionChatMessageApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ISendExtensionChatMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendExtensionChatMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendExtensionChatMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendExtensionChatMessageApiResponse(ILogger<SendExtensionChatMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendExtensionPubsubMessage(Option<SendExtensionPubSubMessageBody> sendExtensionPubSubMessageBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sendExtensionPubSubMessageBody"></param>
        /// <returns></returns>
        private void ValidateSendExtensionPubsubMessage(Option<SendExtensionPubSubMessageBody> sendExtensionPubSubMessageBody)
        {
            if (sendExtensionPubSubMessageBody.IsSet && sendExtensionPubSubMessageBody.Value == null)
                throw new ArgumentNullException(nameof(sendExtensionPubSubMessageBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sendExtensionPubSubMessageBody"></param>
        private void AfterSendExtensionPubsubMessageDefaultImplementation(ISendExtensionPubsubMessageApiResponse apiResponseLocalVar, Option<SendExtensionPubSubMessageBody> sendExtensionPubSubMessageBody)
        {
            bool suppressDefaultLog = false;
            AfterSendExtensionPubsubMessage(ref suppressDefaultLog, apiResponseLocalVar, sendExtensionPubSubMessageBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sendExtensionPubSubMessageBody"></param>
        partial void AfterSendExtensionPubsubMessage(ref bool suppressDefaultLog, ISendExtensionPubsubMessageApiResponse apiResponseLocalVar, Option<SendExtensionPubSubMessageBody> sendExtensionPubSubMessageBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sendExtensionPubSubMessageBody"></param>
        private void OnErrorSendExtensionPubsubMessageDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<SendExtensionPubSubMessageBody> sendExtensionPubSubMessageBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendExtensionPubsubMessage(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, sendExtensionPubSubMessageBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sendExtensionPubSubMessageBody"></param>
        partial void OnErrorSendExtensionPubsubMessage(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<SendExtensionPubSubMessageBody> sendExtensionPubSubMessageBody);

        /// <summary>
        /// Sends a message to one or more viewers. Sends a message to one or more viewers. You can send messages to a specific channel or to all channels where your extension is active. This endpoint uses the same mechanism as the [send](https://dev.twitch.tv/docs/extensions/reference#send) JavaScript helper function used to send messages.  **Rate Limits**: You may send a maximum of 100 messages per minute per combination of extension client ID and broadcaster ID.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)) along with the &#x60;channel_id&#x60; and &#x60;pubsub_perms&#x60; fields. The &#x60;role&#x60; field must be set to _external_.  To send the message to a specific channel, set the &#x60;channel_id&#x60; field in the JWT to the channel’s ID and set the &#x60;pubsub_perms.send&#x60; array to _broadcast_.  &#x60;&#x60;&#x60; {   \&quot;exp\&quot;: 1503343947,   \&quot;user_id\&quot;: \&quot;27419011\&quot;,   \&quot;role\&quot;: \&quot;external\&quot;,   \&quot;channel_id\&quot;: \&quot;27419011\&quot;,   \&quot;pubsub_perms\&quot;: {     \&quot;send\&quot;:[       \&quot;broadcast\&quot;     ]   } }  &#x60;&#x60;&#x60;  To send the message to all channels on which your extension is active, set the &#x60;channel_id&#x60; field to _all_ and set the &#x60;pubsub_perms.send&#x60; array to _global_.  &#x60;&#x60;&#x60; {   \&quot;exp\&quot;: 1503343947,   \&quot;user_id\&quot;: \&quot;27419011\&quot;,   \&quot;role\&quot;: \&quot;external\&quot;,   \&quot;channel_id\&quot;: \&quot;all\&quot;,   \&quot;pubsub_perms\&quot;: {     \&quot;send\&quot;:[       \&quot;global\&quot;     ]   } }  &#x60;&#x60;&#x60;
        /// </summary>
        /// <param name="sendExtensionPubSubMessageBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendExtensionPubsubMessageApiResponse"/>&gt;</returns>
        public async Task<ISendExtensionPubsubMessageApiResponse?> SendExtensionPubsubMessageOrDefaultAsync(Option<SendExtensionPubSubMessageBody> sendExtensionPubSubMessageBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendExtensionPubsubMessageAsync(sendExtensionPubSubMessageBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Sends a message to one or more viewers. Sends a message to one or more viewers. You can send messages to a specific channel or to all channels where your extension is active. This endpoint uses the same mechanism as the [send](https://dev.twitch.tv/docs/extensions/reference#send) JavaScript helper function used to send messages.  **Rate Limits**: You may send a maximum of 100 messages per minute per combination of extension client ID and broadcaster ID.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)) along with the &#x60;channel_id&#x60; and &#x60;pubsub_perms&#x60; fields. The &#x60;role&#x60; field must be set to _external_.  To send the message to a specific channel, set the &#x60;channel_id&#x60; field in the JWT to the channel’s ID and set the &#x60;pubsub_perms.send&#x60; array to _broadcast_.  &#x60;&#x60;&#x60; {   \&quot;exp\&quot;: 1503343947,   \&quot;user_id\&quot;: \&quot;27419011\&quot;,   \&quot;role\&quot;: \&quot;external\&quot;,   \&quot;channel_id\&quot;: \&quot;27419011\&quot;,   \&quot;pubsub_perms\&quot;: {     \&quot;send\&quot;:[       \&quot;broadcast\&quot;     ]   } }  &#x60;&#x60;&#x60;  To send the message to all channels on which your extension is active, set the &#x60;channel_id&#x60; field to _all_ and set the &#x60;pubsub_perms.send&#x60; array to _global_.  &#x60;&#x60;&#x60; {   \&quot;exp\&quot;: 1503343947,   \&quot;user_id\&quot;: \&quot;27419011\&quot;,   \&quot;role\&quot;: \&quot;external\&quot;,   \&quot;channel_id\&quot;: \&quot;all\&quot;,   \&quot;pubsub_perms\&quot;: {     \&quot;send\&quot;:[       \&quot;global\&quot;     ]   } }  &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sendExtensionPubSubMessageBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendExtensionPubsubMessageApiResponse"/>&gt;</returns>
        public async Task<ISendExtensionPubsubMessageApiResponse> SendExtensionPubsubMessageAsync(Option<SendExtensionPubSubMessageBody> sendExtensionPubSubMessageBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendExtensionPubsubMessage(sendExtensionPubSubMessageBody);

                FormatSendExtensionPubsubMessage(sendExtensionPubSubMessageBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/extensions/pubsub"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/extensions/pubsub");

                    if (sendExtensionPubSubMessageBody.IsSet)
                        httpRequestMessageLocalVar.Content = (sendExtensionPubSubMessageBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(sendExtensionPubSubMessageBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SendExtensionPubsubMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendExtensionPubsubMessageApiResponse>();

                        SendExtensionPubsubMessageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/extensions/pubsub", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSendExtensionPubsubMessageDefaultImplementation(apiResponseLocalVar, sendExtensionPubSubMessageBody);

                        Events.ExecuteOnSendExtensionPubsubMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendExtensionPubsubMessageDefaultImplementation(e, "/extensions/pubsub", uriBuilderLocalVar.Path, sendExtensionPubSubMessageBody);
                Events.ExecuteOnErrorSendExtensionPubsubMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendExtensionPubsubMessageApiResponse"/>
        /// </summary>
        public partial class SendExtensionPubsubMessageApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ISendExtensionPubsubMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendExtensionPubsubMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendExtensionPubsubMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendExtensionPubsubMessageApiResponse(ILogger<SendExtensionPubsubMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSetExtensionConfigurationSegment(Option<SetExtensionConfigurationSegmentBody> setExtensionConfigurationSegmentBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="setExtensionConfigurationSegmentBody"></param>
        /// <returns></returns>
        private void ValidateSetExtensionConfigurationSegment(Option<SetExtensionConfigurationSegmentBody> setExtensionConfigurationSegmentBody)
        {
            if (setExtensionConfigurationSegmentBody.IsSet && setExtensionConfigurationSegmentBody.Value == null)
                throw new ArgumentNullException(nameof(setExtensionConfigurationSegmentBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="setExtensionConfigurationSegmentBody"></param>
        private void AfterSetExtensionConfigurationSegmentDefaultImplementation(ISetExtensionConfigurationSegmentApiResponse apiResponseLocalVar, Option<SetExtensionConfigurationSegmentBody> setExtensionConfigurationSegmentBody)
        {
            bool suppressDefaultLog = false;
            AfterSetExtensionConfigurationSegment(ref suppressDefaultLog, apiResponseLocalVar, setExtensionConfigurationSegmentBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="setExtensionConfigurationSegmentBody"></param>
        partial void AfterSetExtensionConfigurationSegment(ref bool suppressDefaultLog, ISetExtensionConfigurationSegmentApiResponse apiResponseLocalVar, Option<SetExtensionConfigurationSegmentBody> setExtensionConfigurationSegmentBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="setExtensionConfigurationSegmentBody"></param>
        private void OnErrorSetExtensionConfigurationSegmentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<SetExtensionConfigurationSegmentBody> setExtensionConfigurationSegmentBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSetExtensionConfigurationSegment(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, setExtensionConfigurationSegmentBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="setExtensionConfigurationSegmentBody"></param>
        partial void OnErrorSetExtensionConfigurationSegment(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<SetExtensionConfigurationSegmentBody> setExtensionConfigurationSegmentBody);

        /// <summary>
        /// Updates a configuration segment. Updates a configuration segment. The segment is limited to 5 KB. Extensions that are active on a channel do not receive the updated configuration.  **Rate Limits**: You may update the configuration a maximum of 20 times per minute.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </summary>
        /// <param name="setExtensionConfigurationSegmentBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetExtensionConfigurationSegmentApiResponse"/>&gt;</returns>
        public async Task<ISetExtensionConfigurationSegmentApiResponse?> SetExtensionConfigurationSegmentOrDefaultAsync(Option<SetExtensionConfigurationSegmentBody> setExtensionConfigurationSegmentBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SetExtensionConfigurationSegmentAsync(setExtensionConfigurationSegmentBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Updates a configuration segment. Updates a configuration segment. The segment is limited to 5 KB. Extensions that are active on a channel do not receive the updated configuration.  **Rate Limits**: You may update the configuration a maximum of 20 times per minute.  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The &#x60;role&#x60; field must be set to _external_.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="setExtensionConfigurationSegmentBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetExtensionConfigurationSegmentApiResponse"/>&gt;</returns>
        public async Task<ISetExtensionConfigurationSegmentApiResponse> SetExtensionConfigurationSegmentAsync(Option<SetExtensionConfigurationSegmentBody> setExtensionConfigurationSegmentBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSetExtensionConfigurationSegment(setExtensionConfigurationSegmentBody);

                FormatSetExtensionConfigurationSegment(setExtensionConfigurationSegmentBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/extensions/configurations"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/extensions/configurations");

                    if (setExtensionConfigurationSegmentBody.IsSet)
                        httpRequestMessageLocalVar.Content = (setExtensionConfigurationSegmentBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(setExtensionConfigurationSegmentBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SetExtensionConfigurationSegmentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SetExtensionConfigurationSegmentApiResponse>();

                        SetExtensionConfigurationSegmentApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/extensions/configurations", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSetExtensionConfigurationSegmentDefaultImplementation(apiResponseLocalVar, setExtensionConfigurationSegmentBody);

                        Events.ExecuteOnSetExtensionConfigurationSegment(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSetExtensionConfigurationSegmentDefaultImplementation(e, "/extensions/configurations", uriBuilderLocalVar.Path, setExtensionConfigurationSegmentBody);
                Events.ExecuteOnErrorSetExtensionConfigurationSegment(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SetExtensionConfigurationSegmentApiResponse"/>
        /// </summary>
        public partial class SetExtensionConfigurationSegmentApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ISetExtensionConfigurationSegmentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SetExtensionConfigurationSegmentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SetExtensionConfigurationSegmentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SetExtensionConfigurationSegmentApiResponse(ILogger<SetExtensionConfigurationSegmentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSetExtensionRequiredConfiguration(ref string broadcasterId, Option<SetExtensionRequiredConfigurationBody> setExtensionRequiredConfigurationBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="setExtensionRequiredConfigurationBody"></param>
        /// <returns></returns>
        private void ValidateSetExtensionRequiredConfiguration(string broadcasterId, Option<SetExtensionRequiredConfigurationBody> setExtensionRequiredConfigurationBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (setExtensionRequiredConfigurationBody.IsSet && setExtensionRequiredConfigurationBody.Value == null)
                throw new ArgumentNullException(nameof(setExtensionRequiredConfigurationBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="setExtensionRequiredConfigurationBody"></param>
        private void AfterSetExtensionRequiredConfigurationDefaultImplementation(ISetExtensionRequiredConfigurationApiResponse apiResponseLocalVar, string broadcasterId, Option<SetExtensionRequiredConfigurationBody> setExtensionRequiredConfigurationBody)
        {
            bool suppressDefaultLog = false;
            AfterSetExtensionRequiredConfiguration(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, setExtensionRequiredConfigurationBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="setExtensionRequiredConfigurationBody"></param>
        partial void AfterSetExtensionRequiredConfiguration(ref bool suppressDefaultLog, ISetExtensionRequiredConfigurationApiResponse apiResponseLocalVar, string broadcasterId, Option<SetExtensionRequiredConfigurationBody> setExtensionRequiredConfigurationBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="setExtensionRequiredConfigurationBody"></param>
        private void OnErrorSetExtensionRequiredConfigurationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<SetExtensionRequiredConfigurationBody> setExtensionRequiredConfigurationBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSetExtensionRequiredConfiguration(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, setExtensionRequiredConfigurationBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="setExtensionRequiredConfigurationBody"></param>
        partial void OnErrorSetExtensionRequiredConfiguration(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<SetExtensionRequiredConfigurationBody> setExtensionRequiredConfigurationBody);

        /// <summary>
        /// Updates the extension’s required_configuration string. Updates the extension’s required\\_configuration string. Use this endpoint if your extension requires the broadcaster to configure the extension before activating it (to require configuration, you must select **Custom/My Own Service** in Extension [Capabilities](https://dev.twitch.tv/docs/extensions/life-cycle/#capabilities)). For more information, see [Required Configurations](https://dev.twitch.tv/docs/extensions/building#required-configurations) and [Setting Required Configuration](https://dev.twitch.tv/docs/extensions/building#setting-required-configuration-with-the-configuration-service-optional).  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an EBS. For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). Set the &#x60;role&#x60; field to _external_ and the &#x60;user_id&#x60; field to the ID of the user that owns the extension.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that installed the extension on their channel.</param>
        /// <param name="setExtensionRequiredConfigurationBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetExtensionRequiredConfigurationApiResponse"/>&gt;</returns>
        public async Task<ISetExtensionRequiredConfigurationApiResponse?> SetExtensionRequiredConfigurationOrDefaultAsync(string broadcasterId, Option<SetExtensionRequiredConfigurationBody> setExtensionRequiredConfigurationBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SetExtensionRequiredConfigurationAsync(broadcasterId, setExtensionRequiredConfigurationBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Updates the extension’s required_configuration string. Updates the extension’s required\\_configuration string. Use this endpoint if your extension requires the broadcaster to configure the extension before activating it (to require configuration, you must select **Custom/My Own Service** in Extension [Capabilities](https://dev.twitch.tv/docs/extensions/life-cycle/#capabilities)). For more information, see [Required Configurations](https://dev.twitch.tv/docs/extensions/building#required-configurations) and [Setting Required Configuration](https://dev.twitch.tv/docs/extensions/building#setting-required-configuration-with-the-configuration-service-optional).  __Authorization:__  Requires a signed JSON Web Token (JWT) created by an EBS. For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the &#x60;role&#x60;, &#x60;user_id&#x60;, and &#x60;exp&#x60; fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). Set the &#x60;role&#x60; field to _external_ and the &#x60;user_id&#x60; field to the ID of the user that owns the extension.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that installed the extension on their channel.</param>
        /// <param name="setExtensionRequiredConfigurationBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetExtensionRequiredConfigurationApiResponse"/>&gt;</returns>
        public async Task<ISetExtensionRequiredConfigurationApiResponse> SetExtensionRequiredConfigurationAsync(string broadcasterId, Option<SetExtensionRequiredConfigurationBody> setExtensionRequiredConfigurationBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSetExtensionRequiredConfiguration(broadcasterId, setExtensionRequiredConfigurationBody);

                FormatSetExtensionRequiredConfiguration(ref broadcasterId, setExtensionRequiredConfigurationBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/extensions/required_configuration"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/extensions/required_configuration");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (setExtensionRequiredConfigurationBody.IsSet)
                        httpRequestMessageLocalVar.Content = (setExtensionRequiredConfigurationBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(setExtensionRequiredConfigurationBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SetExtensionRequiredConfigurationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SetExtensionRequiredConfigurationApiResponse>();

                        SetExtensionRequiredConfigurationApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/extensions/required_configuration", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSetExtensionRequiredConfigurationDefaultImplementation(apiResponseLocalVar, broadcasterId, setExtensionRequiredConfigurationBody);

                        Events.ExecuteOnSetExtensionRequiredConfiguration(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSetExtensionRequiredConfigurationDefaultImplementation(e, "/extensions/required_configuration", uriBuilderLocalVar.Path, broadcasterId, setExtensionRequiredConfigurationBody);
                Events.ExecuteOnErrorSetExtensionRequiredConfiguration(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SetExtensionRequiredConfigurationApiResponse"/>
        /// </summary>
        public partial class SetExtensionRequiredConfigurationApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ISetExtensionRequiredConfigurationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SetExtensionRequiredConfigurationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SetExtensionRequiredConfigurationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SetExtensionRequiredConfigurationApiResponse(ILogger<SetExtensionRequiredConfigurationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateExtensionBitsProduct(Option<UpdateExtensionBitsProductBody> updateExtensionBitsProductBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="updateExtensionBitsProductBody"></param>
        /// <returns></returns>
        private void ValidateUpdateExtensionBitsProduct(Option<UpdateExtensionBitsProductBody> updateExtensionBitsProductBody)
        {
            if (updateExtensionBitsProductBody.IsSet && updateExtensionBitsProductBody.Value == null)
                throw new ArgumentNullException(nameof(updateExtensionBitsProductBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="updateExtensionBitsProductBody"></param>
        private void AfterUpdateExtensionBitsProductDefaultImplementation(IUpdateExtensionBitsProductApiResponse apiResponseLocalVar, Option<UpdateExtensionBitsProductBody> updateExtensionBitsProductBody)
        {
            bool suppressDefaultLog = false;
            AfterUpdateExtensionBitsProduct(ref suppressDefaultLog, apiResponseLocalVar, updateExtensionBitsProductBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="updateExtensionBitsProductBody"></param>
        partial void AfterUpdateExtensionBitsProduct(ref bool suppressDefaultLog, IUpdateExtensionBitsProductApiResponse apiResponseLocalVar, Option<UpdateExtensionBitsProductBody> updateExtensionBitsProductBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="updateExtensionBitsProductBody"></param>
        private void OnErrorUpdateExtensionBitsProductDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<UpdateExtensionBitsProductBody> updateExtensionBitsProductBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateExtensionBitsProduct(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, updateExtensionBitsProductBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="updateExtensionBitsProductBody"></param>
        partial void OnErrorUpdateExtensionBitsProduct(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<UpdateExtensionBitsProductBody> updateExtensionBitsProductBody);

        /// <summary>
        /// Adds or updates a Bits product that the extension created. Adds or updates a Bits product that the extension created. If the SKU doesn’t exist, the product is added. You may update all fields except the &#x60;sku&#x60; field.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must match the extension’s client ID.
        /// </summary>
        /// <param name="updateExtensionBitsProductBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateExtensionBitsProductApiResponse"/>&gt;</returns>
        public async Task<IUpdateExtensionBitsProductApiResponse?> UpdateExtensionBitsProductOrDefaultAsync(Option<UpdateExtensionBitsProductBody> updateExtensionBitsProductBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateExtensionBitsProductAsync(updateExtensionBitsProductBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Adds or updates a Bits product that the extension created. Adds or updates a Bits product that the extension created. If the SKU doesn’t exist, the product is added. You may update all fields except the &#x60;sku&#x60; field.  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must match the extension’s client ID.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateExtensionBitsProductBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateExtensionBitsProductApiResponse"/>&gt;</returns>
        public async Task<IUpdateExtensionBitsProductApiResponse> UpdateExtensionBitsProductAsync(Option<UpdateExtensionBitsProductBody> updateExtensionBitsProductBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateExtensionBitsProduct(updateExtensionBitsProductBody);

                FormatUpdateExtensionBitsProduct(updateExtensionBitsProductBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/bits/extensions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/bits/extensions");

                    if (updateExtensionBitsProductBody.IsSet)
                        httpRequestMessageLocalVar.Content = (updateExtensionBitsProductBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(updateExtensionBitsProductBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateExtensionBitsProductApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateExtensionBitsProductApiResponse>();

                        UpdateExtensionBitsProductApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/bits/extensions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateExtensionBitsProductDefaultImplementation(apiResponseLocalVar, updateExtensionBitsProductBody);

                        Events.ExecuteOnUpdateExtensionBitsProduct(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateExtensionBitsProductDefaultImplementation(e, "/bits/extensions", uriBuilderLocalVar.Path, updateExtensionBitsProductBody);
                Events.ExecuteOnErrorUpdateExtensionBitsProduct(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateExtensionBitsProductApiResponse"/>
        /// </summary>
        public partial class UpdateExtensionBitsProductApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IUpdateExtensionBitsProductApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateExtensionBitsProductApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateExtensionBitsProductApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateExtensionBitsProductApiResponse(ILogger<UpdateExtensionBitsProductApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateExtensionBitsProductResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateExtensionBitsProductResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateExtensionBitsProductResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
