// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;
using TwistedTaleweaver.Integration.Twitch.Helix.Model;
using System.Diagnostics.CodeAnalysis;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IEventSubApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        EventSubApiEvents Events { get; }

        /// <summary>
        /// Creates an EventSub subscription.
        /// </summary>
        /// <remarks>
        /// Creates an EventSub subscription.  __Authorization:__  If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token. If the subscription type requires user authorization, the user must have granted your app (client ID) permissions to receive those events before you subscribe to them. For example, to subscribe to [channel.subscribe](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#channelsubscribe) events, your app must get a user access token that includes the &#x60;channel:read:subscriptions&#x60; scope, which adds the required permission to your app access token’s client ID.  If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. If the subscription type requires user authorization, the token must include the required scope. However, if the subscription type doesn’t include user authorization, the token may include any scopes or no scopes.  If you use [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createEventSubSubscriptionBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateEventsubSubscriptionApiResponse"/>&gt;</returns>
        Task<ICreateEventsubSubscriptionApiResponse> CreateEventsubSubscriptionAsync(Option<CreateEventSubSubscriptionBody> createEventSubSubscriptionBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates an EventSub subscription.
        /// </summary>
        /// <remarks>
        /// Creates an EventSub subscription.  __Authorization:__  If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token. If the subscription type requires user authorization, the user must have granted your app (client ID) permissions to receive those events before you subscribe to them. For example, to subscribe to [channel.subscribe](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#channelsubscribe) events, your app must get a user access token that includes the &#x60;channel:read:subscriptions&#x60; scope, which adds the required permission to your app access token’s client ID.  If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. If the subscription type requires user authorization, the token must include the required scope. However, if the subscription type doesn’t include user authorization, the token may include any scopes or no scopes.  If you use [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.
        /// </remarks>
        /// <param name="createEventSubSubscriptionBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateEventsubSubscriptionApiResponse"/>?&gt;</returns>
        Task<ICreateEventsubSubscriptionApiResponse?> CreateEventsubSubscriptionOrDefaultAsync(Option<CreateEventSubSubscriptionBody> createEventSubSubscriptionBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes an EventSub subscription.
        /// </summary>
        /// <remarks>
        /// Deletes an EventSub subscription.  __Authorization:__  If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token.  If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the subscription to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteEventsubSubscriptionApiResponse"/>&gt;</returns>
        Task<IDeleteEventsubSubscriptionApiResponse> DeleteEventsubSubscriptionAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes an EventSub subscription.
        /// </summary>
        /// <remarks>
        /// Deletes an EventSub subscription.  __Authorization:__  If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token.  If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.
        /// </remarks>
        /// <param name="id">The ID of the subscription to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteEventsubSubscriptionApiResponse"/>?&gt;</returns>
        Task<IDeleteEventsubSubscriptionApiResponse?> DeleteEventsubSubscriptionOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of EventSub subscriptions that the client in the access token created.
        /// </summary>
        /// <remarks>
        /// Gets a list of EventSub subscriptions that the client in the access token created.  __Authorization:__  If you use [Webhooks](https://dev.twitch.tv/docs/eventsub/handling-webhook-events) or [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.  If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.  __Request Query Parameters:__  Use the _status_, _type_, and _user\\_id_ query parameters to filter the list of subscriptions that are returned. The filters are mutually exclusive; the request fails if you specify more than one filter.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Filter subscriptions by its status. Possible values are:      * enabled — The subscription is enabled. * webhook\\_callback\\_verification\\_pending — The subscription is pending verification of the specified callback URL. * webhook\\_callback\\_verification\\_failed — The specified callback URL failed verification. * notification\\_failures\\_exceeded — The notification delivery failure rate was too high. * authorization\\_revoked — The authorization was revoked for one or more users specified in the **Condition** object. * moderator\\_removed — The moderator that authorized the subscription is no longer one of the broadcaster&#39;s moderators. * user\\_removed — One of the users specified in the **Condition** object was removed. * chat\\_user\\_banned - The user specified in the **Condition** object was banned from the broadcaster&#39;s chat. * version\\_removed — The subscription to subscription type and version is no longer supported. * beta\\_maintenance — The subscription to the beta subscription type was removed due to maintenance. * websocket\\_disconnected — The client closed the connection. * websocket\\_failed\\_ping\\_pong — The client failed to respond to a ping message. * websocket\\_received\\_inbound\\_traffic — The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message). * websocket\\_connection\\_unused — The client failed to subscribe to events within the required time. * websocket\\_internal\\_error — The Twitch WebSocket server experienced an unexpected error. * websocket\\_network\\_timeout — The Twitch WebSocket server timed out writing the message to the client. * websocket\\_network\\_error — The Twitch WebSocket server experienced a network error writing the message to the client. * websocket\\_failed\\_to\\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message. (optional)</param>
        /// <param name="type">Filter subscriptions by subscription type. For a list of subscription types, see [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types). (optional)</param>
        /// <param name="userId">Filter subscriptions by user ID. The response contains subscriptions where this ID matches a user ID that you specified in the **Condition** object when you [created the subscription](https://dev.twitch.tv/docs/api/reference#create-eventsub-subscription). (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The &#x60;pagination&#x60; object in the response contains the cursor&#39;s value. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEventsubSubscriptionsApiResponse"/>&gt;</returns>
        Task<IGetEventsubSubscriptionsApiResponse> GetEventsubSubscriptionsAsync(Option<string> status = default, Option<string> type = default, Option<string> userId = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of EventSub subscriptions that the client in the access token created.
        /// </summary>
        /// <remarks>
        /// Gets a list of EventSub subscriptions that the client in the access token created.  __Authorization:__  If you use [Webhooks](https://dev.twitch.tv/docs/eventsub/handling-webhook-events) or [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.  If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.  __Request Query Parameters:__  Use the _status_, _type_, and _user\\_id_ query parameters to filter the list of subscriptions that are returned. The filters are mutually exclusive; the request fails if you specify more than one filter.
        /// </remarks>
        /// <param name="status">Filter subscriptions by its status. Possible values are:      * enabled — The subscription is enabled. * webhook\\_callback\\_verification\\_pending — The subscription is pending verification of the specified callback URL. * webhook\\_callback\\_verification\\_failed — The specified callback URL failed verification. * notification\\_failures\\_exceeded — The notification delivery failure rate was too high. * authorization\\_revoked — The authorization was revoked for one or more users specified in the **Condition** object. * moderator\\_removed — The moderator that authorized the subscription is no longer one of the broadcaster&#39;s moderators. * user\\_removed — One of the users specified in the **Condition** object was removed. * chat\\_user\\_banned - The user specified in the **Condition** object was banned from the broadcaster&#39;s chat. * version\\_removed — The subscription to subscription type and version is no longer supported. * beta\\_maintenance — The subscription to the beta subscription type was removed due to maintenance. * websocket\\_disconnected — The client closed the connection. * websocket\\_failed\\_ping\\_pong — The client failed to respond to a ping message. * websocket\\_received\\_inbound\\_traffic — The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message). * websocket\\_connection\\_unused — The client failed to subscribe to events within the required time. * websocket\\_internal\\_error — The Twitch WebSocket server experienced an unexpected error. * websocket\\_network\\_timeout — The Twitch WebSocket server timed out writing the message to the client. * websocket\\_network\\_error — The Twitch WebSocket server experienced a network error writing the message to the client. * websocket\\_failed\\_to\\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message. (optional)</param>
        /// <param name="type">Filter subscriptions by subscription type. For a list of subscription types, see [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types). (optional)</param>
        /// <param name="userId">Filter subscriptions by user ID. The response contains subscriptions where this ID matches a user ID that you specified in the **Condition** object when you [created the subscription](https://dev.twitch.tv/docs/api/reference#create-eventsub-subscription). (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The &#x60;pagination&#x60; object in the response contains the cursor&#39;s value. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEventsubSubscriptionsApiResponse"/>?&gt;</returns>
        Task<IGetEventsubSubscriptionsApiResponse?> GetEventsubSubscriptionsOrDefaultAsync(Option<string> status = default, Option<string> type = default, Option<string> userId = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateEventsubSubscriptionApiResponse"/>
    /// </summary>
    public interface ICreateEventsubSubscriptionApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IAccepted<TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateEventSubSubscriptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 202 Accepted
        /// </summary>
        /// <returns></returns>
        bool IsAccepted { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteEventsubSubscriptionApiResponse"/>
    /// </summary>
    public interface IDeleteEventsubSubscriptionApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetEventsubSubscriptionsApiResponse"/>
    /// </summary>
    public interface IGetEventsubSubscriptionsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetEventSubSubscriptionsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class EventSubApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateEventsubSubscription;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateEventsubSubscription;

        internal void ExecuteOnCreateEventsubSubscription(EventSubApi.CreateEventsubSubscriptionApiResponse apiResponse)
        {
            OnCreateEventsubSubscription?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateEventsubSubscription(Exception exception)
        {
            OnErrorCreateEventsubSubscription?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteEventsubSubscription;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteEventsubSubscription;

        internal void ExecuteOnDeleteEventsubSubscription(EventSubApi.DeleteEventsubSubscriptionApiResponse apiResponse)
        {
            OnDeleteEventsubSubscription?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteEventsubSubscription(Exception exception)
        {
            OnErrorDeleteEventsubSubscription?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetEventsubSubscriptions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetEventsubSubscriptions;

        internal void ExecuteOnGetEventsubSubscriptions(EventSubApi.GetEventsubSubscriptionsApiResponse apiResponse)
        {
            OnGetEventsubSubscriptions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEventsubSubscriptions(Exception exception)
        {
            OnErrorGetEventsubSubscriptions?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class EventSubApi : IEventSubApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<EventSubApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public EventSubApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="EventSubApi"/> class.
        /// </summary>
        /// <returns></returns>
        public EventSubApi(ILogger<EventSubApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, EventSubApiEvents eventSubApiEvents,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<EventSubApi>();
            HttpClient = httpClient;
            Events = eventSubApiEvents;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatCreateEventsubSubscription(Option<CreateEventSubSubscriptionBody> createEventSubSubscriptionBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createEventSubSubscriptionBody"></param>
        /// <returns></returns>
        private void ValidateCreateEventsubSubscription(Option<CreateEventSubSubscriptionBody> createEventSubSubscriptionBody)
        {
            if (createEventSubSubscriptionBody.IsSet && createEventSubSubscriptionBody.Value == null)
                throw new ArgumentNullException(nameof(createEventSubSubscriptionBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createEventSubSubscriptionBody"></param>
        private void AfterCreateEventsubSubscriptionDefaultImplementation(ICreateEventsubSubscriptionApiResponse apiResponseLocalVar, Option<CreateEventSubSubscriptionBody> createEventSubSubscriptionBody)
        {
            bool suppressDefaultLog = false;
            AfterCreateEventsubSubscription(ref suppressDefaultLog, apiResponseLocalVar, createEventSubSubscriptionBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createEventSubSubscriptionBody"></param>
        partial void AfterCreateEventsubSubscription(ref bool suppressDefaultLog, ICreateEventsubSubscriptionApiResponse apiResponseLocalVar, Option<CreateEventSubSubscriptionBody> createEventSubSubscriptionBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createEventSubSubscriptionBody"></param>
        private void OnErrorCreateEventsubSubscriptionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreateEventSubSubscriptionBody> createEventSubSubscriptionBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateEventsubSubscription(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, createEventSubSubscriptionBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createEventSubSubscriptionBody"></param>
        partial void OnErrorCreateEventsubSubscription(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreateEventSubSubscriptionBody> createEventSubSubscriptionBody);

        /// <summary>
        /// Creates an EventSub subscription. Creates an EventSub subscription.  __Authorization:__  If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token. If the subscription type requires user authorization, the user must have granted your app (client ID) permissions to receive those events before you subscribe to them. For example, to subscribe to [channel.subscribe](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#channelsubscribe) events, your app must get a user access token that includes the &#x60;channel:read:subscriptions&#x60; scope, which adds the required permission to your app access token’s client ID.  If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. If the subscription type requires user authorization, the token must include the required scope. However, if the subscription type doesn’t include user authorization, the token may include any scopes or no scopes.  If you use [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.
        /// </summary>
        /// <param name="createEventSubSubscriptionBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateEventsubSubscriptionApiResponse"/>&gt;</returns>
        public async Task<ICreateEventsubSubscriptionApiResponse?> CreateEventsubSubscriptionOrDefaultAsync(Option<CreateEventSubSubscriptionBody> createEventSubSubscriptionBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateEventsubSubscriptionAsync(createEventSubSubscriptionBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Creates an EventSub subscription. Creates an EventSub subscription.  __Authorization:__  If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token. If the subscription type requires user authorization, the user must have granted your app (client ID) permissions to receive those events before you subscribe to them. For example, to subscribe to [channel.subscribe](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#channelsubscribe) events, your app must get a user access token that includes the &#x60;channel:read:subscriptions&#x60; scope, which adds the required permission to your app access token’s client ID.  If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. If the subscription type requires user authorization, the token must include the required scope. However, if the subscription type doesn’t include user authorization, the token may include any scopes or no scopes.  If you use [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createEventSubSubscriptionBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateEventsubSubscriptionApiResponse"/>&gt;</returns>
        public async Task<ICreateEventsubSubscriptionApiResponse> CreateEventsubSubscriptionAsync(Option<CreateEventSubSubscriptionBody> createEventSubSubscriptionBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateEventsubSubscription(createEventSubSubscriptionBody);

                FormatCreateEventsubSubscription(createEventSubSubscriptionBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/eventsub/subscriptions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/eventsub/subscriptions");

                    if (createEventSubSubscriptionBody.IsSet)
                        httpRequestMessageLocalVar.Content = (createEventSubSubscriptionBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createEventSubSubscriptionBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateEventsubSubscriptionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateEventsubSubscriptionApiResponse>();

                        CreateEventsubSubscriptionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/eventsub/subscriptions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateEventsubSubscriptionDefaultImplementation(apiResponseLocalVar, createEventSubSubscriptionBody);

                        Events.ExecuteOnCreateEventsubSubscription(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateEventsubSubscriptionDefaultImplementation(e, "/eventsub/subscriptions", uriBuilderLocalVar.Path, createEventSubSubscriptionBody);
                Events.ExecuteOnErrorCreateEventsubSubscription(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateEventsubSubscriptionApiResponse"/>
        /// </summary>
        public partial class CreateEventsubSubscriptionApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ICreateEventsubSubscriptionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateEventsubSubscriptionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateEventsubSubscriptionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateEventsubSubscriptionApiResponse(ILogger<CreateEventsubSubscriptionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 202 Accepted
            /// </summary>
            /// <returns></returns>
            public bool IsAccepted => 202 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 202 Accepted
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateEventSubSubscriptionResponse? Accepted()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsAccepted
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateEventSubSubscriptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 202 Accepted and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryAccepted([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateEventSubSubscriptionResponse? result)
            {
                result = null;

                try
                {
                    result = Accepted();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)202);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteEventsubSubscription(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateDeleteEventsubSubscription(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDeleteEventsubSubscriptionDefaultImplementation(IDeleteEventsubSubscriptionApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterDeleteEventsubSubscription(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDeleteEventsubSubscription(ref bool suppressDefaultLog, IDeleteEventsubSubscriptionApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteEventsubSubscriptionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteEventsubSubscription(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDeleteEventsubSubscription(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Deletes an EventSub subscription. Deletes an EventSub subscription.  __Authorization:__  If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token.  If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.
        /// </summary>
        /// <param name="id">The ID of the subscription to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteEventsubSubscriptionApiResponse"/>&gt;</returns>
        public async Task<IDeleteEventsubSubscriptionApiResponse?> DeleteEventsubSubscriptionOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteEventsubSubscriptionAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Deletes an EventSub subscription. Deletes an EventSub subscription.  __Authorization:__  If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token.  If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the subscription to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteEventsubSubscriptionApiResponse"/>&gt;</returns>
        public async Task<IDeleteEventsubSubscriptionApiResponse> DeleteEventsubSubscriptionAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteEventsubSubscription(id);

                FormatDeleteEventsubSubscription(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/eventsub/subscriptions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/eventsub/subscriptions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteEventsubSubscriptionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteEventsubSubscriptionApiResponse>();

                        DeleteEventsubSubscriptionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/eventsub/subscriptions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteEventsubSubscriptionDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDeleteEventsubSubscription(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteEventsubSubscriptionDefaultImplementation(e, "/eventsub/subscriptions", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDeleteEventsubSubscription(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteEventsubSubscriptionApiResponse"/>
        /// </summary>
        public partial class DeleteEventsubSubscriptionApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IDeleteEventsubSubscriptionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteEventsubSubscriptionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteEventsubSubscriptionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteEventsubSubscriptionApiResponse(ILogger<DeleteEventsubSubscriptionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEventsubSubscriptions(ref Option<string> status, ref Option<string> type, ref Option<string> userId, ref Option<string> after);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="status"></param>
        /// <param name="type"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetEventsubSubscriptions(Option<string> status, Option<string> type, Option<string> userId, Option<string> after)
        {
            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type));

            if (userId.IsSet && userId.Value == null)
                throw new ArgumentNullException(nameof(userId));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="type"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        private void AfterGetEventsubSubscriptionsDefaultImplementation(IGetEventsubSubscriptionsApiResponse apiResponseLocalVar, Option<string> status, Option<string> type, Option<string> userId, Option<string> after)
        {
            bool suppressDefaultLog = false;
            AfterGetEventsubSubscriptions(ref suppressDefaultLog, apiResponseLocalVar, status, type, userId, after);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="type"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        partial void AfterGetEventsubSubscriptions(ref bool suppressDefaultLog, IGetEventsubSubscriptionsApiResponse apiResponseLocalVar, Option<string> status, Option<string> type, Option<string> userId, Option<string> after);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="type"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        private void OnErrorGetEventsubSubscriptionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> status, Option<string> type, Option<string> userId, Option<string> after)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEventsubSubscriptions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, status, type, userId, after);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="type"></param>
        /// <param name="userId"></param>
        /// <param name="after"></param>
        partial void OnErrorGetEventsubSubscriptions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> status, Option<string> type, Option<string> userId, Option<string> after);

        /// <summary>
        /// Gets a list of EventSub subscriptions that the client in the access token created. Gets a list of EventSub subscriptions that the client in the access token created.  __Authorization:__  If you use [Webhooks](https://dev.twitch.tv/docs/eventsub/handling-webhook-events) or [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.  If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.  __Request Query Parameters:__  Use the _status_, _type_, and _user\\_id_ query parameters to filter the list of subscriptions that are returned. The filters are mutually exclusive; the request fails if you specify more than one filter.
        /// </summary>
        /// <param name="status">Filter subscriptions by its status. Possible values are:      * enabled — The subscription is enabled. * webhook\\_callback\\_verification\\_pending — The subscription is pending verification of the specified callback URL. * webhook\\_callback\\_verification\\_failed — The specified callback URL failed verification. * notification\\_failures\\_exceeded — The notification delivery failure rate was too high. * authorization\\_revoked — The authorization was revoked for one or more users specified in the **Condition** object. * moderator\\_removed — The moderator that authorized the subscription is no longer one of the broadcaster&#39;s moderators. * user\\_removed — One of the users specified in the **Condition** object was removed. * chat\\_user\\_banned - The user specified in the **Condition** object was banned from the broadcaster&#39;s chat. * version\\_removed — The subscription to subscription type and version is no longer supported. * beta\\_maintenance — The subscription to the beta subscription type was removed due to maintenance. * websocket\\_disconnected — The client closed the connection. * websocket\\_failed\\_ping\\_pong — The client failed to respond to a ping message. * websocket\\_received\\_inbound\\_traffic — The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message). * websocket\\_connection\\_unused — The client failed to subscribe to events within the required time. * websocket\\_internal\\_error — The Twitch WebSocket server experienced an unexpected error. * websocket\\_network\\_timeout — The Twitch WebSocket server timed out writing the message to the client. * websocket\\_network\\_error — The Twitch WebSocket server experienced a network error writing the message to the client. * websocket\\_failed\\_to\\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message. (optional)</param>
        /// <param name="type">Filter subscriptions by subscription type. For a list of subscription types, see [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types). (optional)</param>
        /// <param name="userId">Filter subscriptions by user ID. The response contains subscriptions where this ID matches a user ID that you specified in the **Condition** object when you [created the subscription](https://dev.twitch.tv/docs/api/reference#create-eventsub-subscription). (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The &#x60;pagination&#x60; object in the response contains the cursor&#39;s value. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEventsubSubscriptionsApiResponse"/>&gt;</returns>
        public async Task<IGetEventsubSubscriptionsApiResponse?> GetEventsubSubscriptionsOrDefaultAsync(Option<string> status = default, Option<string> type = default, Option<string> userId = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEventsubSubscriptionsAsync(status, type, userId, after, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets a list of EventSub subscriptions that the client in the access token created. Gets a list of EventSub subscriptions that the client in the access token created.  __Authorization:__  If you use [Webhooks](https://dev.twitch.tv/docs/eventsub/handling-webhook-events) or [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.  If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.  __Request Query Parameters:__  Use the _status_, _type_, and _user\\_id_ query parameters to filter the list of subscriptions that are returned. The filters are mutually exclusive; the request fails if you specify more than one filter.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Filter subscriptions by its status. Possible values are:      * enabled — The subscription is enabled. * webhook\\_callback\\_verification\\_pending — The subscription is pending verification of the specified callback URL. * webhook\\_callback\\_verification\\_failed — The specified callback URL failed verification. * notification\\_failures\\_exceeded — The notification delivery failure rate was too high. * authorization\\_revoked — The authorization was revoked for one or more users specified in the **Condition** object. * moderator\\_removed — The moderator that authorized the subscription is no longer one of the broadcaster&#39;s moderators. * user\\_removed — One of the users specified in the **Condition** object was removed. * chat\\_user\\_banned - The user specified in the **Condition** object was banned from the broadcaster&#39;s chat. * version\\_removed — The subscription to subscription type and version is no longer supported. * beta\\_maintenance — The subscription to the beta subscription type was removed due to maintenance. * websocket\\_disconnected — The client closed the connection. * websocket\\_failed\\_ping\\_pong — The client failed to respond to a ping message. * websocket\\_received\\_inbound\\_traffic — The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message). * websocket\\_connection\\_unused — The client failed to subscribe to events within the required time. * websocket\\_internal\\_error — The Twitch WebSocket server experienced an unexpected error. * websocket\\_network\\_timeout — The Twitch WebSocket server timed out writing the message to the client. * websocket\\_network\\_error — The Twitch WebSocket server experienced a network error writing the message to the client. * websocket\\_failed\\_to\\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message. (optional)</param>
        /// <param name="type">Filter subscriptions by subscription type. For a list of subscription types, see [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types). (optional)</param>
        /// <param name="userId">Filter subscriptions by user ID. The response contains subscriptions where this ID matches a user ID that you specified in the **Condition** object when you [created the subscription](https://dev.twitch.tv/docs/api/reference#create-eventsub-subscription). (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The &#x60;pagination&#x60; object in the response contains the cursor&#39;s value. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEventsubSubscriptionsApiResponse"/>&gt;</returns>
        public async Task<IGetEventsubSubscriptionsApiResponse> GetEventsubSubscriptionsAsync(Option<string> status = default, Option<string> type = default, Option<string> userId = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEventsubSubscriptions(status, type, userId, after);

                FormatGetEventsubSubscriptions(ref status, ref type, ref userId, ref after);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/eventsub/subscriptions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/eventsub/subscriptions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    if (userId.IsSet)
                        parseQueryStringLocalVar["user_id"] = ClientUtils.ParameterToString(userId.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetEventsubSubscriptionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEventsubSubscriptionsApiResponse>();

                        GetEventsubSubscriptionsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/eventsub/subscriptions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetEventsubSubscriptionsDefaultImplementation(apiResponseLocalVar, status, type, userId, after);

                        Events.ExecuteOnGetEventsubSubscriptions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEventsubSubscriptionsDefaultImplementation(e, "/eventsub/subscriptions", uriBuilderLocalVar.Path, status, type, userId, after);
                Events.ExecuteOnErrorGetEventsubSubscriptions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEventsubSubscriptionsApiResponse"/>
        /// </summary>
        public partial class GetEventsubSubscriptionsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetEventsubSubscriptionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEventsubSubscriptionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEventsubSubscriptionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEventsubSubscriptionsApiResponse(ILogger<GetEventsubSubscriptionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetEventSubSubscriptionsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetEventSubSubscriptionsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetEventSubSubscriptionsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
