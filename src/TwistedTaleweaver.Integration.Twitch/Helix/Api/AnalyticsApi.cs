// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;
using TwistedTaleweaver.Integration.Twitch.Helix.Model;
using System.Diagnostics.CodeAnalysis;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IAnalyticsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        AnalyticsApiEvents Events { get; }

        /// <summary>
        /// Gets an analytics report for one or more extensions.
        /// </summary>
        /// <remarks>
        /// Gets an analytics report for one or more extensions. The response contains the URLs used to download the reports (CSV files). [Learn More](https://dev.twitch.tv/docs/insights)  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:extensions** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="extensionId">The extension&#39;s client ID. If specified, the response contains a report for the specified extension. If not specified, the response includes a report for each extension that the authenticated user owns. (optional)</param>
        /// <param name="type">The type of analytics report to get. Possible values are:      * overview\\_v2 (optional)</param>
        /// <param name="startedAt">The reporting window&#39;s start date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z).      The start date must be on or after January 31, 2018\\. If you specify an earlier date, the API ignores it and uses January 31, 2018\\. If you specify a start date, you must specify an end date. If you don&#39;t specify a start and end date, the report includes all available data since January 31, 2018.      The report contains one row of data for each day in the reporting window. (optional)</param>
        /// <param name="endedAt">The reporting window&#39;s end date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-27T00:00:00Z). The report is inclusive of the end date.      Specify an end date only if you provide a start date. Because it can take up to two days for the data to be available, you must specify an end date that&#39;s earlier than today minus one to two days. If not, the API ignores your end date and uses an end date that is today minus one to two days. (optional)</param>
        /// <param name="first">The maximum number of report URLs to return per page in the response. The minimum page size is 1 URL per page and the maximum is 100 URLs per page. The default is 20.      **NOTE**: While you may specify a maximum value of 100, the response will contain at most 20 URLs per page. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)      This parameter is ignored if the _extension\\_id_ parameter is set. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionAnalyticsApiResponse"/>&gt;</returns>
        Task<IGetExtensionAnalyticsApiResponse> GetExtensionAnalyticsAsync(Option<string> extensionId = default, Option<string> type = default, Option<DateTime> startedAt = default, Option<DateTime> endedAt = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets an analytics report for one or more extensions.
        /// </summary>
        /// <remarks>
        /// Gets an analytics report for one or more extensions. The response contains the URLs used to download the reports (CSV files). [Learn More](https://dev.twitch.tv/docs/insights)  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:extensions** scope.
        /// </remarks>
        /// <param name="extensionId">The extension&#39;s client ID. If specified, the response contains a report for the specified extension. If not specified, the response includes a report for each extension that the authenticated user owns. (optional)</param>
        /// <param name="type">The type of analytics report to get. Possible values are:      * overview\\_v2 (optional)</param>
        /// <param name="startedAt">The reporting window&#39;s start date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z).      The start date must be on or after January 31, 2018\\. If you specify an earlier date, the API ignores it and uses January 31, 2018\\. If you specify a start date, you must specify an end date. If you don&#39;t specify a start and end date, the report includes all available data since January 31, 2018.      The report contains one row of data for each day in the reporting window. (optional)</param>
        /// <param name="endedAt">The reporting window&#39;s end date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-27T00:00:00Z). The report is inclusive of the end date.      Specify an end date only if you provide a start date. Because it can take up to two days for the data to be available, you must specify an end date that&#39;s earlier than today minus one to two days. If not, the API ignores your end date and uses an end date that is today minus one to two days. (optional)</param>
        /// <param name="first">The maximum number of report URLs to return per page in the response. The minimum page size is 1 URL per page and the maximum is 100 URLs per page. The default is 20.      **NOTE**: While you may specify a maximum value of 100, the response will contain at most 20 URLs per page. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)      This parameter is ignored if the _extension\\_id_ parameter is set. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionAnalyticsApiResponse"/>?&gt;</returns>
        Task<IGetExtensionAnalyticsApiResponse?> GetExtensionAnalyticsOrDefaultAsync(Option<string> extensionId = default, Option<string> type = default, Option<DateTime> startedAt = default, Option<DateTime> endedAt = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets an analytics report for one or more games.
        /// </summary>
        /// <remarks>
        /// Gets an analytics report for one or more games. The response contains the URLs used to download the reports (CSV files). [Learn more](https://dev.twitch.tv/docs/insights)  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:games** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gameId">The game’s client ID. If specified, the response contains a report for the specified game. If not specified, the response includes a report for each of the authenticated user’s games. (optional)</param>
        /// <param name="type">The type of analytics report to get. Possible values are:      * overview\\_v2 (optional)</param>
        /// <param name="startedAt">The reporting window’s start date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z). If you specify a start date, you must specify an end date.      The start date must be within one year of today’s date. If you specify an earlier date, the API ignores it and uses a date that’s one year prior to today’s date. If you don’t specify a start and end date, the report includes all available data for the last 365 days from today.      The report contains one row of data for each day in the reporting window. (optional)</param>
        /// <param name="endedAt">The reporting window’s end date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z). The report is inclusive of the end date.      Specify an end date only if you provide a start date. Because it can take up to two days for the data to be available, you must specify an end date that’s earlier than today minus one to two days. If not, the API ignores your end date and uses an end date that is today minus one to two days. (optional)</param>
        /// <param name="first">The maximum number of report URLs to return per page in the response. The minimum page size is 1 URL per page and the maximum is 100 URLs per page. The default is 20.      **NOTE**: While you may specify a maximum value of 100, the response will contain at most 20 URLs per page. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)      This parameter is ignored if _game\\_id_ parameter is set. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGameAnalyticsApiResponse"/>&gt;</returns>
        Task<IGetGameAnalyticsApiResponse> GetGameAnalyticsAsync(Option<string> gameId = default, Option<string> type = default, Option<DateTime> startedAt = default, Option<DateTime> endedAt = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets an analytics report for one or more games.
        /// </summary>
        /// <remarks>
        /// Gets an analytics report for one or more games. The response contains the URLs used to download the reports (CSV files). [Learn more](https://dev.twitch.tv/docs/insights)  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:games** scope.
        /// </remarks>
        /// <param name="gameId">The game’s client ID. If specified, the response contains a report for the specified game. If not specified, the response includes a report for each of the authenticated user’s games. (optional)</param>
        /// <param name="type">The type of analytics report to get. Possible values are:      * overview\\_v2 (optional)</param>
        /// <param name="startedAt">The reporting window’s start date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z). If you specify a start date, you must specify an end date.      The start date must be within one year of today’s date. If you specify an earlier date, the API ignores it and uses a date that’s one year prior to today’s date. If you don’t specify a start and end date, the report includes all available data for the last 365 days from today.      The report contains one row of data for each day in the reporting window. (optional)</param>
        /// <param name="endedAt">The reporting window’s end date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z). The report is inclusive of the end date.      Specify an end date only if you provide a start date. Because it can take up to two days for the data to be available, you must specify an end date that’s earlier than today minus one to two days. If not, the API ignores your end date and uses an end date that is today minus one to two days. (optional)</param>
        /// <param name="first">The maximum number of report URLs to return per page in the response. The minimum page size is 1 URL per page and the maximum is 100 URLs per page. The default is 20.      **NOTE**: While you may specify a maximum value of 100, the response will contain at most 20 URLs per page. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)      This parameter is ignored if _game\\_id_ parameter is set. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGameAnalyticsApiResponse"/>?&gt;</returns>
        Task<IGetGameAnalyticsApiResponse?> GetGameAnalyticsOrDefaultAsync(Option<string> gameId = default, Option<string> type = default, Option<DateTime> startedAt = default, Option<DateTime> endedAt = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGetExtensionAnalyticsApiResponse"/>
    /// </summary>
    public interface IGetExtensionAnalyticsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionAnalyticsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetGameAnalyticsApiResponse"/>
    /// </summary>
    public interface IGetGameAnalyticsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetGameAnalyticsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class AnalyticsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetExtensionAnalytics;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetExtensionAnalytics;

        internal void ExecuteOnGetExtensionAnalytics(AnalyticsApi.GetExtensionAnalyticsApiResponse apiResponse)
        {
            OnGetExtensionAnalytics?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetExtensionAnalytics(Exception exception)
        {
            OnErrorGetExtensionAnalytics?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetGameAnalytics;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetGameAnalytics;

        internal void ExecuteOnGetGameAnalytics(AnalyticsApi.GetGameAnalyticsApiResponse apiResponse)
        {
            OnGetGameAnalytics?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetGameAnalytics(Exception exception)
        {
            OnErrorGetGameAnalytics?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class AnalyticsApi : IAnalyticsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<AnalyticsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public AnalyticsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AnalyticsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AnalyticsApi(ILogger<AnalyticsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, AnalyticsApiEvents analyticsApiEvents,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<AnalyticsApi>();
            HttpClient = httpClient;
            Events = analyticsApiEvents;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatGetExtensionAnalytics(ref Option<string> extensionId, ref Option<string> type, ref Option<DateTime> startedAt, ref Option<DateTime> endedAt, ref Option<int> first, ref Option<string> after);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="extensionId"></param>
        /// <param name="type"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetExtensionAnalytics(Option<string> extensionId, Option<string> type, Option<string> after)
        {
            if (extensionId.IsSet && extensionId.Value == null)
                throw new ArgumentNullException(nameof(extensionId));

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="type"></param>
        /// <param name="startedAt"></param>
        /// <param name="endedAt"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void AfterGetExtensionAnalyticsDefaultImplementation(IGetExtensionAnalyticsApiResponse apiResponseLocalVar, Option<string> extensionId, Option<string> type, Option<DateTime> startedAt, Option<DateTime> endedAt, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLog = false;
            AfterGetExtensionAnalytics(ref suppressDefaultLog, apiResponseLocalVar, extensionId, type, startedAt, endedAt, first, after);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="type"></param>
        /// <param name="startedAt"></param>
        /// <param name="endedAt"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void AfterGetExtensionAnalytics(ref bool suppressDefaultLog, IGetExtensionAnalyticsApiResponse apiResponseLocalVar, Option<string> extensionId, Option<string> type, Option<DateTime> startedAt, Option<DateTime> endedAt, Option<int> first, Option<string> after);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="type"></param>
        /// <param name="startedAt"></param>
        /// <param name="endedAt"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void OnErrorGetExtensionAnalyticsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> extensionId, Option<string> type, Option<DateTime> startedAt, Option<DateTime> endedAt, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetExtensionAnalytics(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, extensionId, type, startedAt, endedAt, first, after);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="extensionId"></param>
        /// <param name="type"></param>
        /// <param name="startedAt"></param>
        /// <param name="endedAt"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void OnErrorGetExtensionAnalytics(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> extensionId, Option<string> type, Option<DateTime> startedAt, Option<DateTime> endedAt, Option<int> first, Option<string> after);

        /// <summary>
        /// Gets an analytics report for one or more extensions. Gets an analytics report for one or more extensions. The response contains the URLs used to download the reports (CSV files). [Learn More](https://dev.twitch.tv/docs/insights)  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:extensions** scope.
        /// </summary>
        /// <param name="extensionId">The extension&#39;s client ID. If specified, the response contains a report for the specified extension. If not specified, the response includes a report for each extension that the authenticated user owns. (optional)</param>
        /// <param name="type">The type of analytics report to get. Possible values are:      * overview\\_v2 (optional)</param>
        /// <param name="startedAt">The reporting window&#39;s start date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z).      The start date must be on or after January 31, 2018\\. If you specify an earlier date, the API ignores it and uses January 31, 2018\\. If you specify a start date, you must specify an end date. If you don&#39;t specify a start and end date, the report includes all available data since January 31, 2018.      The report contains one row of data for each day in the reporting window. (optional)</param>
        /// <param name="endedAt">The reporting window&#39;s end date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-27T00:00:00Z). The report is inclusive of the end date.      Specify an end date only if you provide a start date. Because it can take up to two days for the data to be available, you must specify an end date that&#39;s earlier than today minus one to two days. If not, the API ignores your end date and uses an end date that is today minus one to two days. (optional)</param>
        /// <param name="first">The maximum number of report URLs to return per page in the response. The minimum page size is 1 URL per page and the maximum is 100 URLs per page. The default is 20.      **NOTE**: While you may specify a maximum value of 100, the response will contain at most 20 URLs per page. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)      This parameter is ignored if the _extension\\_id_ parameter is set. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionAnalyticsApiResponse"/>&gt;</returns>
        public async Task<IGetExtensionAnalyticsApiResponse?> GetExtensionAnalyticsOrDefaultAsync(Option<string> extensionId = default, Option<string> type = default, Option<DateTime> startedAt = default, Option<DateTime> endedAt = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetExtensionAnalyticsAsync(extensionId, type, startedAt, endedAt, first, after, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets an analytics report for one or more extensions. Gets an analytics report for one or more extensions. The response contains the URLs used to download the reports (CSV files). [Learn More](https://dev.twitch.tv/docs/insights)  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:extensions** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="extensionId">The extension&#39;s client ID. If specified, the response contains a report for the specified extension. If not specified, the response includes a report for each extension that the authenticated user owns. (optional)</param>
        /// <param name="type">The type of analytics report to get. Possible values are:      * overview\\_v2 (optional)</param>
        /// <param name="startedAt">The reporting window&#39;s start date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z).      The start date must be on or after January 31, 2018\\. If you specify an earlier date, the API ignores it and uses January 31, 2018\\. If you specify a start date, you must specify an end date. If you don&#39;t specify a start and end date, the report includes all available data since January 31, 2018.      The report contains one row of data for each day in the reporting window. (optional)</param>
        /// <param name="endedAt">The reporting window&#39;s end date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-27T00:00:00Z). The report is inclusive of the end date.      Specify an end date only if you provide a start date. Because it can take up to two days for the data to be available, you must specify an end date that&#39;s earlier than today minus one to two days. If not, the API ignores your end date and uses an end date that is today minus one to two days. (optional)</param>
        /// <param name="first">The maximum number of report URLs to return per page in the response. The minimum page size is 1 URL per page and the maximum is 100 URLs per page. The default is 20.      **NOTE**: While you may specify a maximum value of 100, the response will contain at most 20 URLs per page. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)      This parameter is ignored if the _extension\\_id_ parameter is set. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetExtensionAnalyticsApiResponse"/>&gt;</returns>
        public async Task<IGetExtensionAnalyticsApiResponse> GetExtensionAnalyticsAsync(Option<string> extensionId = default, Option<string> type = default, Option<DateTime> startedAt = default, Option<DateTime> endedAt = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetExtensionAnalytics(extensionId, type, after);

                FormatGetExtensionAnalytics(ref extensionId, ref type, ref startedAt, ref endedAt, ref first, ref after);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/analytics/extensions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/analytics/extensions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (extensionId.IsSet)
                        parseQueryStringLocalVar["extension_id"] = ClientUtils.ParameterToString(extensionId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    if (startedAt.IsSet)
                        parseQueryStringLocalVar["started_at"] = ClientUtils.ParameterToString(startedAt.Value);

                    if (endedAt.IsSet)
                        parseQueryStringLocalVar["ended_at"] = ClientUtils.ParameterToString(endedAt.Value);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetExtensionAnalyticsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetExtensionAnalyticsApiResponse>();

                        GetExtensionAnalyticsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/analytics/extensions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetExtensionAnalyticsDefaultImplementation(apiResponseLocalVar, extensionId, type, startedAt, endedAt, first, after);

                        Events.ExecuteOnGetExtensionAnalytics(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetExtensionAnalyticsDefaultImplementation(e, "/analytics/extensions", uriBuilderLocalVar.Path, extensionId, type, startedAt, endedAt, first, after);
                Events.ExecuteOnErrorGetExtensionAnalytics(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetExtensionAnalyticsApiResponse"/>
        /// </summary>
        public partial class GetExtensionAnalyticsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetExtensionAnalyticsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetExtensionAnalyticsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetExtensionAnalyticsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetExtensionAnalyticsApiResponse(ILogger<GetExtensionAnalyticsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionAnalyticsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionAnalyticsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetExtensionAnalyticsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetGameAnalytics(ref Option<string> gameId, ref Option<string> type, ref Option<DateTime> startedAt, ref Option<DateTime> endedAt, ref Option<int> first, ref Option<string> after);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="gameId"></param>
        /// <param name="type"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetGameAnalytics(Option<string> gameId, Option<string> type, Option<string> after)
        {
            if (gameId.IsSet && gameId.Value == null)
                throw new ArgumentNullException(nameof(gameId));

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gameId"></param>
        /// <param name="type"></param>
        /// <param name="startedAt"></param>
        /// <param name="endedAt"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void AfterGetGameAnalyticsDefaultImplementation(IGetGameAnalyticsApiResponse apiResponseLocalVar, Option<string> gameId, Option<string> type, Option<DateTime> startedAt, Option<DateTime> endedAt, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLog = false;
            AfterGetGameAnalytics(ref suppressDefaultLog, apiResponseLocalVar, gameId, type, startedAt, endedAt, first, after);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gameId"></param>
        /// <param name="type"></param>
        /// <param name="startedAt"></param>
        /// <param name="endedAt"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void AfterGetGameAnalytics(ref bool suppressDefaultLog, IGetGameAnalyticsApiResponse apiResponseLocalVar, Option<string> gameId, Option<string> type, Option<DateTime> startedAt, Option<DateTime> endedAt, Option<int> first, Option<string> after);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="gameId"></param>
        /// <param name="type"></param>
        /// <param name="startedAt"></param>
        /// <param name="endedAt"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void OnErrorGetGameAnalyticsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> gameId, Option<string> type, Option<DateTime> startedAt, Option<DateTime> endedAt, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetGameAnalytics(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, gameId, type, startedAt, endedAt, first, after);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="gameId"></param>
        /// <param name="type"></param>
        /// <param name="startedAt"></param>
        /// <param name="endedAt"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void OnErrorGetGameAnalytics(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> gameId, Option<string> type, Option<DateTime> startedAt, Option<DateTime> endedAt, Option<int> first, Option<string> after);

        /// <summary>
        /// Gets an analytics report for one or more games. Gets an analytics report for one or more games. The response contains the URLs used to download the reports (CSV files). [Learn more](https://dev.twitch.tv/docs/insights)  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:games** scope.
        /// </summary>
        /// <param name="gameId">The game’s client ID. If specified, the response contains a report for the specified game. If not specified, the response includes a report for each of the authenticated user’s games. (optional)</param>
        /// <param name="type">The type of analytics report to get. Possible values are:      * overview\\_v2 (optional)</param>
        /// <param name="startedAt">The reporting window’s start date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z). If you specify a start date, you must specify an end date.      The start date must be within one year of today’s date. If you specify an earlier date, the API ignores it and uses a date that’s one year prior to today’s date. If you don’t specify a start and end date, the report includes all available data for the last 365 days from today.      The report contains one row of data for each day in the reporting window. (optional)</param>
        /// <param name="endedAt">The reporting window’s end date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z). The report is inclusive of the end date.      Specify an end date only if you provide a start date. Because it can take up to two days for the data to be available, you must specify an end date that’s earlier than today minus one to two days. If not, the API ignores your end date and uses an end date that is today minus one to two days. (optional)</param>
        /// <param name="first">The maximum number of report URLs to return per page in the response. The minimum page size is 1 URL per page and the maximum is 100 URLs per page. The default is 20.      **NOTE**: While you may specify a maximum value of 100, the response will contain at most 20 URLs per page. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)      This parameter is ignored if _game\\_id_ parameter is set. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGameAnalyticsApiResponse"/>&gt;</returns>
        public async Task<IGetGameAnalyticsApiResponse?> GetGameAnalyticsOrDefaultAsync(Option<string> gameId = default, Option<string> type = default, Option<DateTime> startedAt = default, Option<DateTime> endedAt = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetGameAnalyticsAsync(gameId, type, startedAt, endedAt, first, after, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets an analytics report for one or more games. Gets an analytics report for one or more games. The response contains the URLs used to download the reports (CSV files). [Learn more](https://dev.twitch.tv/docs/insights)  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:games** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gameId">The game’s client ID. If specified, the response contains a report for the specified game. If not specified, the response includes a report for each of the authenticated user’s games. (optional)</param>
        /// <param name="type">The type of analytics report to get. Possible values are:      * overview\\_v2 (optional)</param>
        /// <param name="startedAt">The reporting window’s start date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z). If you specify a start date, you must specify an end date.      The start date must be within one year of today’s date. If you specify an earlier date, the API ignores it and uses a date that’s one year prior to today’s date. If you don’t specify a start and end date, the report includes all available data for the last 365 days from today.      The report contains one row of data for each day in the reporting window. (optional)</param>
        /// <param name="endedAt">The reporting window’s end date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z). The report is inclusive of the end date.      Specify an end date only if you provide a start date. Because it can take up to two days for the data to be available, you must specify an end date that’s earlier than today minus one to two days. If not, the API ignores your end date and uses an end date that is today minus one to two days. (optional)</param>
        /// <param name="first">The maximum number of report URLs to return per page in the response. The minimum page size is 1 URL per page and the maximum is 100 URLs per page. The default is 20.      **NOTE**: While you may specify a maximum value of 100, the response will contain at most 20 URLs per page. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)      This parameter is ignored if _game\\_id_ parameter is set. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGameAnalyticsApiResponse"/>&gt;</returns>
        public async Task<IGetGameAnalyticsApiResponse> GetGameAnalyticsAsync(Option<string> gameId = default, Option<string> type = default, Option<DateTime> startedAt = default, Option<DateTime> endedAt = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetGameAnalytics(gameId, type, after);

                FormatGetGameAnalytics(ref gameId, ref type, ref startedAt, ref endedAt, ref first, ref after);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/analytics/games"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/analytics/games");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gameId.IsSet)
                        parseQueryStringLocalVar["game_id"] = ClientUtils.ParameterToString(gameId.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    if (startedAt.IsSet)
                        parseQueryStringLocalVar["started_at"] = ClientUtils.ParameterToString(startedAt.Value);

                    if (endedAt.IsSet)
                        parseQueryStringLocalVar["ended_at"] = ClientUtils.ParameterToString(endedAt.Value);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetGameAnalyticsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetGameAnalyticsApiResponse>();

                        GetGameAnalyticsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/analytics/games", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetGameAnalyticsDefaultImplementation(apiResponseLocalVar, gameId, type, startedAt, endedAt, first, after);

                        Events.ExecuteOnGetGameAnalytics(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetGameAnalyticsDefaultImplementation(e, "/analytics/games", uriBuilderLocalVar.Path, gameId, type, startedAt, endedAt, first, after);
                Events.ExecuteOnErrorGetGameAnalytics(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetGameAnalyticsApiResponse"/>
        /// </summary>
        public partial class GetGameAnalyticsApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetGameAnalyticsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetGameAnalyticsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetGameAnalyticsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetGameAnalyticsApiResponse(ILogger<GetGameAnalyticsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetGameAnalyticsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetGameAnalyticsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetGameAnalyticsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
