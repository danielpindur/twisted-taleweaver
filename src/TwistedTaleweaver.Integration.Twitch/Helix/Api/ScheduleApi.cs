// <auto-generated>
/*
 * Twitch API Swagger UI (Unofficial)
 *
 * Unofficial Swagger UI for Twitch API.  All endpoints are generated automatically from the [twitch docs](https://dev.twitch.tv/docs/api/reference) page.  __Features:__  * Swagger UI for all Twitch API endpoints * Schemas for _Request Query Parameters_, _Request Body_, _Response Body_ * Some additional schemas like _Clip_, _ChatBadge_, _Prediction_, _Game_, _Channel_, _Video_ etc. * Response codes and examples * Generated types for TypeScript: [ts-twitch-api](https://github.com/DmitryScaletta/ts-twitch-api)  __Repository:__ [github.com/DmitryScaletta/twitch-api-swagger](https://github.com/DmitryScaletta/twitch-api-swagger)
 *
 * The version of the OpenAPI document: helix
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using TwistedTaleweaver.Integration.Twitch.Helix.Client;
using TwistedTaleweaver.Integration.Twitch.Helix.Model;
using System.Diagnostics.CodeAnalysis;

namespace TwistedTaleweaver.Integration.Twitch.Helix.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IScheduleApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ScheduleApiEvents Events { get; }

        /// <summary>
        /// Adds a single or recurring broadcast to the broadcaster’s streaming schedule.
        /// </summary>
        /// <remarks>
        /// Adds a single or recurring broadcast to the broadcaster’s streaming schedule. For information about scheduling broadcasts, see [Stream Schedule](https://help.twitch.tv/s/article/channel-page-setup#Schedule).  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the schedule to add the broadcast segment to. This ID must match the user ID in the user access token.</param>
        /// <param name="createChannelStreamScheduleSegmentBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateChannelStreamScheduleSegmentApiResponse"/>&gt;</returns>
        Task<ICreateChannelStreamScheduleSegmentApiResponse> CreateChannelStreamScheduleSegmentAsync(string broadcasterId, Option<CreateChannelStreamScheduleSegmentBody> createChannelStreamScheduleSegmentBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Adds a single or recurring broadcast to the broadcaster’s streaming schedule.
        /// </summary>
        /// <remarks>
        /// Adds a single or recurring broadcast to the broadcaster’s streaming schedule. For information about scheduling broadcasts, see [Stream Schedule](https://help.twitch.tv/s/article/channel-page-setup#Schedule).  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the schedule to add the broadcast segment to. This ID must match the user ID in the user access token.</param>
        /// <param name="createChannelStreamScheduleSegmentBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateChannelStreamScheduleSegmentApiResponse"/>?&gt;</returns>
        Task<ICreateChannelStreamScheduleSegmentApiResponse?> CreateChannelStreamScheduleSegmentOrDefaultAsync(string broadcasterId, Option<CreateChannelStreamScheduleSegmentBody> createChannelStreamScheduleSegmentBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes a broadcast from the broadcaster’s streaming schedule.
        /// </summary>
        /// <remarks>
        /// Removes a broadcast segment from the broadcaster’s streaming schedule.  **NOTE**: For recurring segments, removing a segment removes all segments in the recurring schedule.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the streaming schedule. This ID must match the user ID in the user access token.</param>
        /// <param name="id">The ID of the broadcast segment to remove.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteChannelStreamScheduleSegmentApiResponse"/>&gt;</returns>
        Task<IDeleteChannelStreamScheduleSegmentApiResponse> DeleteChannelStreamScheduleSegmentAsync(string broadcasterId, string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes a broadcast from the broadcaster’s streaming schedule.
        /// </summary>
        /// <remarks>
        /// Removes a broadcast segment from the broadcaster’s streaming schedule.  **NOTE**: For recurring segments, removing a segment removes all segments in the recurring schedule.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the streaming schedule. This ID must match the user ID in the user access token.</param>
        /// <param name="id">The ID of the broadcast segment to remove.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteChannelStreamScheduleSegmentApiResponse"/>?&gt;</returns>
        Task<IDeleteChannelStreamScheduleSegmentApiResponse?> DeleteChannelStreamScheduleSegmentOrDefaultAsync(string broadcasterId, string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s streaming schedule as an iCalendar.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s streaming schedule as an [iCalendar](https://datatracker.ietf.org/doc/html/rfc5545).  __Authorization:__  The Client-Id and Authorization headers are not required.  __Response Body:__  The response body contains the iCalendar data (see [RFC5545](https://datatracker.ietf.org/doc/html/rfc5545)).  The Content-Type response header is set to &#x60;text/calendar&#x60;.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the streaming schedule you want to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelIcalendarApiResponse"/>&gt;</returns>
        Task<IGetChannelIcalendarApiResponse> GetChannelIcalendarAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s streaming schedule as an iCalendar.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s streaming schedule as an [iCalendar](https://datatracker.ietf.org/doc/html/rfc5545).  __Authorization:__  The Client-Id and Authorization headers are not required.  __Response Body:__  The response body contains the iCalendar data (see [RFC5545](https://datatracker.ietf.org/doc/html/rfc5545)).  The Content-Type response header is set to &#x60;text/calendar&#x60;.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the streaming schedule you want to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelIcalendarApiResponse"/>?&gt;</returns>
        Task<IGetChannelIcalendarApiResponse?> GetChannelIcalendarOrDefaultAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s streaming schedule.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s streaming schedule. You can get the entire schedule or specific segments of the schedule. [Learn More](https://help.twitch.tv/s/article/channel-page-setup#Schedule)  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the streaming schedule you want to get.</param>
        /// <param name="id">The ID of the scheduled segment to return. To specify more than one segment, include the ID of each segment you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 100 IDs. (optional)</param>
        /// <param name="startTime">The UTC date and time that identifies when in the broadcaster’s schedule to start returning segments. If not specified, the request returns segments starting after the current UTC date and time. Specify the date and time in RFC3339 format (for example, &#x60;2022-09-01T00:00:00Z&#x60;). (optional)</param>
        /// <param name="utcOffset">Not supported. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 25 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelStreamScheduleApiResponse"/>&gt;</returns>
        Task<IGetChannelStreamScheduleApiResponse> GetChannelStreamScheduleAsync(string broadcasterId, Option<List<string>> id = default, Option<DateTime> startTime = default, Option<string> utcOffset = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the broadcaster’s streaming schedule.
        /// </summary>
        /// <remarks>
        /// Gets the broadcaster’s streaming schedule. You can get the entire schedule or specific segments of the schedule. [Learn More](https://help.twitch.tv/s/article/channel-page-setup#Schedule)  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the streaming schedule you want to get.</param>
        /// <param name="id">The ID of the scheduled segment to return. To specify more than one segment, include the ID of each segment you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 100 IDs. (optional)</param>
        /// <param name="startTime">The UTC date and time that identifies when in the broadcaster’s schedule to start returning segments. If not specified, the request returns segments starting after the current UTC date and time. Specify the date and time in RFC3339 format (for example, &#x60;2022-09-01T00:00:00Z&#x60;). (optional)</param>
        /// <param name="utcOffset">Not supported. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 25 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelStreamScheduleApiResponse"/>?&gt;</returns>
        Task<IGetChannelStreamScheduleApiResponse?> GetChannelStreamScheduleOrDefaultAsync(string broadcasterId, Option<List<string>> id = default, Option<DateTime> startTime = default, Option<string> utcOffset = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the broadcaster’s schedule settings, such as scheduling a vacation.
        /// </summary>
        /// <remarks>
        /// Updates the broadcaster’s schedule settings, such as scheduling a vacation.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose schedule settings you want to update. The ID must match the user ID in the user access token.</param>
        /// <param name="isVacationEnabled">A Boolean value that indicates whether the broadcaster has scheduled a vacation. Set to **true** to enable Vacation Mode and add vacation dates, or **false** to cancel a previously scheduled vacation. (optional)</param>
        /// <param name="vacationStartTime">The UTC date and time of when the broadcaster’s vacation starts. Specify the date and time in RFC3339 format (for example, 2021-05-16T00:00:00Z). Required if _is\\_vacation\\_enabled_ is **true**. (optional)</param>
        /// <param name="vacationEndTime">The UTC date and time of when the broadcaster’s vacation ends. Specify the date and time in RFC3339 format (for example, 2021-05-30T23:59:59Z). Required if _is\\_vacation\\_enabled_ is **true**. (optional)</param>
        /// <param name="timezone">The time zone that the broadcaster broadcasts from. Specify the time zone using [IANA time zone database](https://www.iana.org/time-zones) format (for example, America/New\\_York). Required if _is\\_vacation\\_enabled_ is **true**. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateChannelStreamScheduleApiResponse"/>&gt;</returns>
        Task<IUpdateChannelStreamScheduleApiResponse> UpdateChannelStreamScheduleAsync(string broadcasterId, Option<bool> isVacationEnabled = default, Option<DateTime> vacationStartTime = default, Option<DateTime> vacationEndTime = default, Option<string> timezone = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates the broadcaster’s schedule settings, such as scheduling a vacation.
        /// </summary>
        /// <remarks>
        /// Updates the broadcaster’s schedule settings, such as scheduling a vacation.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster whose schedule settings you want to update. The ID must match the user ID in the user access token.</param>
        /// <param name="isVacationEnabled">A Boolean value that indicates whether the broadcaster has scheduled a vacation. Set to **true** to enable Vacation Mode and add vacation dates, or **false** to cancel a previously scheduled vacation. (optional)</param>
        /// <param name="vacationStartTime">The UTC date and time of when the broadcaster’s vacation starts. Specify the date and time in RFC3339 format (for example, 2021-05-16T00:00:00Z). Required if _is\\_vacation\\_enabled_ is **true**. (optional)</param>
        /// <param name="vacationEndTime">The UTC date and time of when the broadcaster’s vacation ends. Specify the date and time in RFC3339 format (for example, 2021-05-30T23:59:59Z). Required if _is\\_vacation\\_enabled_ is **true**. (optional)</param>
        /// <param name="timezone">The time zone that the broadcaster broadcasts from. Specify the time zone using [IANA time zone database](https://www.iana.org/time-zones) format (for example, America/New\\_York). Required if _is\\_vacation\\_enabled_ is **true**. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateChannelStreamScheduleApiResponse"/>?&gt;</returns>
        Task<IUpdateChannelStreamScheduleApiResponse?> UpdateChannelStreamScheduleOrDefaultAsync(string broadcasterId, Option<bool> isVacationEnabled = default, Option<DateTime> vacationStartTime = default, Option<DateTime> vacationEndTime = default, Option<string> timezone = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates a scheduled broadcast segment.
        /// </summary>
        /// <remarks>
        /// Updates a scheduled broadcast segment.  For recurring segments, updating a segment’s title, category, duration, and timezone, changes all segments in the recurring schedule, not just the specified segment.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster who owns the broadcast segment to update. This ID must match the user ID in the user access token.</param>
        /// <param name="id">The ID of the broadcast segment to update.</param>
        /// <param name="updateChannelStreamScheduleSegmentBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateChannelStreamScheduleSegmentApiResponse"/>&gt;</returns>
        Task<IUpdateChannelStreamScheduleSegmentApiResponse> UpdateChannelStreamScheduleSegmentAsync(string broadcasterId, string id, Option<UpdateChannelStreamScheduleSegmentBody> updateChannelStreamScheduleSegmentBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Updates a scheduled broadcast segment.
        /// </summary>
        /// <remarks>
        /// Updates a scheduled broadcast segment.  For recurring segments, updating a segment’s title, category, duration, and timezone, changes all segments in the recurring schedule, not just the specified segment.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </remarks>
        /// <param name="broadcasterId">The ID of the broadcaster who owns the broadcast segment to update. This ID must match the user ID in the user access token.</param>
        /// <param name="id">The ID of the broadcast segment to update.</param>
        /// <param name="updateChannelStreamScheduleSegmentBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateChannelStreamScheduleSegmentApiResponse"/>?&gt;</returns>
        Task<IUpdateChannelStreamScheduleSegmentApiResponse?> UpdateChannelStreamScheduleSegmentOrDefaultAsync(string broadcasterId, string id, Option<UpdateChannelStreamScheduleSegmentBody> updateChannelStreamScheduleSegmentBody = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateChannelStreamScheduleSegmentApiResponse"/>
    /// </summary>
    public interface ICreateChannelStreamScheduleSegmentApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateChannelStreamScheduleSegmentResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteChannelStreamScheduleSegmentApiResponse"/>
    /// </summary>
    public interface IDeleteChannelStreamScheduleSegmentApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetChannelIcalendarApiResponse"/>
    /// </summary>
    public interface IGetChannelIcalendarApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IGetChannelStreamScheduleApiResponse"/>
    /// </summary>
    public interface IGetChannelStreamScheduleApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChannelStreamScheduleResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateChannelStreamScheduleApiResponse"/>
    /// </summary>
    public interface IUpdateChannelStreamScheduleApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateChannelStreamScheduleSegmentApiResponse"/>
    /// </summary>
    public interface IUpdateChannelStreamScheduleSegmentApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.IApiResponse, IOk<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateChannelStreamScheduleSegmentResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ScheduleApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateChannelStreamScheduleSegment;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateChannelStreamScheduleSegment;

        internal void ExecuteOnCreateChannelStreamScheduleSegment(ScheduleApi.CreateChannelStreamScheduleSegmentApiResponse apiResponse)
        {
            OnCreateChannelStreamScheduleSegment?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateChannelStreamScheduleSegment(Exception exception)
        {
            OnErrorCreateChannelStreamScheduleSegment?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteChannelStreamScheduleSegment;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteChannelStreamScheduleSegment;

        internal void ExecuteOnDeleteChannelStreamScheduleSegment(ScheduleApi.DeleteChannelStreamScheduleSegmentApiResponse apiResponse)
        {
            OnDeleteChannelStreamScheduleSegment?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteChannelStreamScheduleSegment(Exception exception)
        {
            OnErrorDeleteChannelStreamScheduleSegment?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetChannelIcalendar;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetChannelIcalendar;

        internal void ExecuteOnGetChannelIcalendar(ScheduleApi.GetChannelIcalendarApiResponse apiResponse)
        {
            OnGetChannelIcalendar?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetChannelIcalendar(Exception exception)
        {
            OnErrorGetChannelIcalendar?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetChannelStreamSchedule;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetChannelStreamSchedule;

        internal void ExecuteOnGetChannelStreamSchedule(ScheduleApi.GetChannelStreamScheduleApiResponse apiResponse)
        {
            OnGetChannelStreamSchedule?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetChannelStreamSchedule(Exception exception)
        {
            OnErrorGetChannelStreamSchedule?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateChannelStreamSchedule;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateChannelStreamSchedule;

        internal void ExecuteOnUpdateChannelStreamSchedule(ScheduleApi.UpdateChannelStreamScheduleApiResponse apiResponse)
        {
            OnUpdateChannelStreamSchedule?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateChannelStreamSchedule(Exception exception)
        {
            OnErrorUpdateChannelStreamSchedule?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateChannelStreamScheduleSegment;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateChannelStreamScheduleSegment;

        internal void ExecuteOnUpdateChannelStreamScheduleSegment(ScheduleApi.UpdateChannelStreamScheduleSegmentApiResponse apiResponse)
        {
            OnUpdateChannelStreamScheduleSegment?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateChannelStreamScheduleSegment(Exception exception)
        {
            OnErrorUpdateChannelStreamScheduleSegment?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ScheduleApi : IScheduleApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ScheduleApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ScheduleApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScheduleApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ScheduleApi(ILogger<ScheduleApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ScheduleApiEvents scheduleApiEvents,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ScheduleApi>();
            HttpClient = httpClient;
            Events = scheduleApiEvents;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatCreateChannelStreamScheduleSegment(ref string broadcasterId, Option<CreateChannelStreamScheduleSegmentBody> createChannelStreamScheduleSegmentBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="createChannelStreamScheduleSegmentBody"></param>
        /// <returns></returns>
        private void ValidateCreateChannelStreamScheduleSegment(string broadcasterId, Option<CreateChannelStreamScheduleSegmentBody> createChannelStreamScheduleSegmentBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (createChannelStreamScheduleSegmentBody.IsSet && createChannelStreamScheduleSegmentBody.Value == null)
                throw new ArgumentNullException(nameof(createChannelStreamScheduleSegmentBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="createChannelStreamScheduleSegmentBody"></param>
        private void AfterCreateChannelStreamScheduleSegmentDefaultImplementation(ICreateChannelStreamScheduleSegmentApiResponse apiResponseLocalVar, string broadcasterId, Option<CreateChannelStreamScheduleSegmentBody> createChannelStreamScheduleSegmentBody)
        {
            bool suppressDefaultLog = false;
            AfterCreateChannelStreamScheduleSegment(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, createChannelStreamScheduleSegmentBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="createChannelStreamScheduleSegmentBody"></param>
        partial void AfterCreateChannelStreamScheduleSegment(ref bool suppressDefaultLog, ICreateChannelStreamScheduleSegmentApiResponse apiResponseLocalVar, string broadcasterId, Option<CreateChannelStreamScheduleSegmentBody> createChannelStreamScheduleSegmentBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="createChannelStreamScheduleSegmentBody"></param>
        private void OnErrorCreateChannelStreamScheduleSegmentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<CreateChannelStreamScheduleSegmentBody> createChannelStreamScheduleSegmentBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateChannelStreamScheduleSegment(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, createChannelStreamScheduleSegmentBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="createChannelStreamScheduleSegmentBody"></param>
        partial void OnErrorCreateChannelStreamScheduleSegment(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<CreateChannelStreamScheduleSegmentBody> createChannelStreamScheduleSegmentBody);

        /// <summary>
        /// Adds a single or recurring broadcast to the broadcaster’s streaming schedule. Adds a single or recurring broadcast to the broadcaster’s streaming schedule. For information about scheduling broadcasts, see [Stream Schedule](https://help.twitch.tv/s/article/channel-page-setup#Schedule).  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the schedule to add the broadcast segment to. This ID must match the user ID in the user access token.</param>
        /// <param name="createChannelStreamScheduleSegmentBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateChannelStreamScheduleSegmentApiResponse"/>&gt;</returns>
        public async Task<ICreateChannelStreamScheduleSegmentApiResponse?> CreateChannelStreamScheduleSegmentOrDefaultAsync(string broadcasterId, Option<CreateChannelStreamScheduleSegmentBody> createChannelStreamScheduleSegmentBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateChannelStreamScheduleSegmentAsync(broadcasterId, createChannelStreamScheduleSegmentBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Adds a single or recurring broadcast to the broadcaster’s streaming schedule. Adds a single or recurring broadcast to the broadcaster’s streaming schedule. For information about scheduling broadcasts, see [Stream Schedule](https://help.twitch.tv/s/article/channel-page-setup#Schedule).  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the schedule to add the broadcast segment to. This ID must match the user ID in the user access token.</param>
        /// <param name="createChannelStreamScheduleSegmentBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateChannelStreamScheduleSegmentApiResponse"/>&gt;</returns>
        public async Task<ICreateChannelStreamScheduleSegmentApiResponse> CreateChannelStreamScheduleSegmentAsync(string broadcasterId, Option<CreateChannelStreamScheduleSegmentBody> createChannelStreamScheduleSegmentBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateChannelStreamScheduleSegment(broadcasterId, createChannelStreamScheduleSegmentBody);

                FormatCreateChannelStreamScheduleSegment(ref broadcasterId, createChannelStreamScheduleSegmentBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/schedule/segment"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/schedule/segment");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (createChannelStreamScheduleSegmentBody.IsSet)
                        httpRequestMessageLocalVar.Content = (createChannelStreamScheduleSegmentBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createChannelStreamScheduleSegmentBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateChannelStreamScheduleSegmentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateChannelStreamScheduleSegmentApiResponse>();

                        CreateChannelStreamScheduleSegmentApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/schedule/segment", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateChannelStreamScheduleSegmentDefaultImplementation(apiResponseLocalVar, broadcasterId, createChannelStreamScheduleSegmentBody);

                        Events.ExecuteOnCreateChannelStreamScheduleSegment(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateChannelStreamScheduleSegmentDefaultImplementation(e, "/schedule/segment", uriBuilderLocalVar.Path, broadcasterId, createChannelStreamScheduleSegmentBody);
                Events.ExecuteOnErrorCreateChannelStreamScheduleSegment(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateChannelStreamScheduleSegmentApiResponse"/>
        /// </summary>
        public partial class CreateChannelStreamScheduleSegmentApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, ICreateChannelStreamScheduleSegmentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateChannelStreamScheduleSegmentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateChannelStreamScheduleSegmentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateChannelStreamScheduleSegmentApiResponse(ILogger<CreateChannelStreamScheduleSegmentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateChannelStreamScheduleSegmentResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateChannelStreamScheduleSegmentResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.CreateChannelStreamScheduleSegmentResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteChannelStreamScheduleSegment(ref string broadcasterId, ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateDeleteChannelStreamScheduleSegment(string broadcasterId, string id)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        private void AfterDeleteChannelStreamScheduleSegmentDefaultImplementation(IDeleteChannelStreamScheduleSegmentApiResponse apiResponseLocalVar, string broadcasterId, string id)
        {
            bool suppressDefaultLog = false;
            AfterDeleteChannelStreamScheduleSegment(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        partial void AfterDeleteChannelStreamScheduleSegment(ref bool suppressDefaultLog, IDeleteChannelStreamScheduleSegmentApiResponse apiResponseLocalVar, string broadcasterId, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteChannelStreamScheduleSegmentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteChannelStreamScheduleSegment(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        partial void OnErrorDeleteChannelStreamScheduleSegment(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string id);

        /// <summary>
        /// Deletes a broadcast from the broadcaster’s streaming schedule. Removes a broadcast segment from the broadcaster’s streaming schedule.  **NOTE**: For recurring segments, removing a segment removes all segments in the recurring schedule.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the streaming schedule. This ID must match the user ID in the user access token.</param>
        /// <param name="id">The ID of the broadcast segment to remove.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteChannelStreamScheduleSegmentApiResponse"/>&gt;</returns>
        public async Task<IDeleteChannelStreamScheduleSegmentApiResponse?> DeleteChannelStreamScheduleSegmentOrDefaultAsync(string broadcasterId, string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteChannelStreamScheduleSegmentAsync(broadcasterId, id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Deletes a broadcast from the broadcaster’s streaming schedule. Removes a broadcast segment from the broadcaster’s streaming schedule.  **NOTE**: For recurring segments, removing a segment removes all segments in the recurring schedule.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the streaming schedule. This ID must match the user ID in the user access token.</param>
        /// <param name="id">The ID of the broadcast segment to remove.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteChannelStreamScheduleSegmentApiResponse"/>&gt;</returns>
        public async Task<IDeleteChannelStreamScheduleSegmentApiResponse> DeleteChannelStreamScheduleSegmentAsync(string broadcasterId, string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteChannelStreamScheduleSegment(broadcasterId, id);

                FormatDeleteChannelStreamScheduleSegment(ref broadcasterId, ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/schedule/segment"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/schedule/segment");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteChannelStreamScheduleSegmentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteChannelStreamScheduleSegmentApiResponse>();

                        DeleteChannelStreamScheduleSegmentApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/schedule/segment", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteChannelStreamScheduleSegmentDefaultImplementation(apiResponseLocalVar, broadcasterId, id);

                        Events.ExecuteOnDeleteChannelStreamScheduleSegment(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteChannelStreamScheduleSegmentDefaultImplementation(e, "/schedule/segment", uriBuilderLocalVar.Path, broadcasterId, id);
                Events.ExecuteOnErrorDeleteChannelStreamScheduleSegment(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteChannelStreamScheduleSegmentApiResponse"/>
        /// </summary>
        public partial class DeleteChannelStreamScheduleSegmentApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IDeleteChannelStreamScheduleSegmentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteChannelStreamScheduleSegmentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteChannelStreamScheduleSegmentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteChannelStreamScheduleSegmentApiResponse(ILogger<DeleteChannelStreamScheduleSegmentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetChannelIcalendar(ref string broadcasterId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <returns></returns>
        private void ValidateGetChannelIcalendar(string broadcasterId)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        private void AfterGetChannelIcalendarDefaultImplementation(IGetChannelIcalendarApiResponse apiResponseLocalVar, string broadcasterId)
        {
            bool suppressDefaultLog = false;
            AfterGetChannelIcalendar(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        partial void AfterGetChannelIcalendar(ref bool suppressDefaultLog, IGetChannelIcalendarApiResponse apiResponseLocalVar, string broadcasterId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        private void OnErrorGetChannelIcalendarDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetChannelIcalendar(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        partial void OnErrorGetChannelIcalendar(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId);

        /// <summary>
        /// Gets the broadcaster’s streaming schedule as an iCalendar. Gets the broadcaster’s streaming schedule as an [iCalendar](https://datatracker.ietf.org/doc/html/rfc5545).  __Authorization:__  The Client-Id and Authorization headers are not required.  __Response Body:__  The response body contains the iCalendar data (see [RFC5545](https://datatracker.ietf.org/doc/html/rfc5545)).  The Content-Type response header is set to &#x60;text/calendar&#x60;.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the streaming schedule you want to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelIcalendarApiResponse"/>&gt;</returns>
        public async Task<IGetChannelIcalendarApiResponse?> GetChannelIcalendarOrDefaultAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetChannelIcalendarAsync(broadcasterId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the broadcaster’s streaming schedule as an iCalendar. Gets the broadcaster’s streaming schedule as an [iCalendar](https://datatracker.ietf.org/doc/html/rfc5545).  __Authorization:__  The Client-Id and Authorization headers are not required.  __Response Body:__  The response body contains the iCalendar data (see [RFC5545](https://datatracker.ietf.org/doc/html/rfc5545)).  The Content-Type response header is set to &#x60;text/calendar&#x60;.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the streaming schedule you want to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelIcalendarApiResponse"/>&gt;</returns>
        public async Task<IGetChannelIcalendarApiResponse> GetChannelIcalendarAsync(string broadcasterId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetChannelIcalendar(broadcasterId);

                FormatGetChannelIcalendar(ref broadcasterId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/schedule/icalendar"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/schedule/icalendar");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "text/calendar"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetChannelIcalendarApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetChannelIcalendarApiResponse>();

                        GetChannelIcalendarApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/schedule/icalendar", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetChannelIcalendarDefaultImplementation(apiResponseLocalVar, broadcasterId);

                        Events.ExecuteOnGetChannelIcalendar(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetChannelIcalendarDefaultImplementation(e, "/schedule/icalendar", uriBuilderLocalVar.Path, broadcasterId);
                Events.ExecuteOnErrorGetChannelIcalendar(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetChannelIcalendarApiResponse"/>
        /// </summary>
        public partial class GetChannelIcalendarApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetChannelIcalendarApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetChannelIcalendarApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetChannelIcalendarApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetChannelIcalendarApiResponse(ILogger<GetChannelIcalendarApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetChannelStreamSchedule(ref string broadcasterId, Option<List<string>> id, ref Option<DateTime> startTime, ref Option<string> utcOffset, ref Option<int> first, ref Option<string> after);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="utcOffset"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        private void ValidateGetChannelStreamSchedule(string broadcasterId, Option<List<string>> id, Option<string> utcOffset, Option<string> after)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id));

            if (utcOffset.IsSet && utcOffset.Value == null)
                throw new ArgumentNullException(nameof(utcOffset));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="startTime"></param>
        /// <param name="utcOffset"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void AfterGetChannelStreamScheduleDefaultImplementation(IGetChannelStreamScheduleApiResponse apiResponseLocalVar, string broadcasterId, Option<List<string>> id, Option<DateTime> startTime, Option<string> utcOffset, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLog = false;
            AfterGetChannelStreamSchedule(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, id, startTime, utcOffset, first, after);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="startTime"></param>
        /// <param name="utcOffset"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void AfterGetChannelStreamSchedule(ref bool suppressDefaultLog, IGetChannelStreamScheduleApiResponse apiResponseLocalVar, string broadcasterId, Option<List<string>> id, Option<DateTime> startTime, Option<string> utcOffset, Option<int> first, Option<string> after);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="startTime"></param>
        /// <param name="utcOffset"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        private void OnErrorGetChannelStreamScheduleDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<List<string>> id, Option<DateTime> startTime, Option<string> utcOffset, Option<int> first, Option<string> after)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetChannelStreamSchedule(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, id, startTime, utcOffset, first, after);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="startTime"></param>
        /// <param name="utcOffset"></param>
        /// <param name="first"></param>
        /// <param name="after"></param>
        partial void OnErrorGetChannelStreamSchedule(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<List<string>> id, Option<DateTime> startTime, Option<string> utcOffset, Option<int> first, Option<string> after);

        /// <summary>
        /// Gets the broadcaster’s streaming schedule. Gets the broadcaster’s streaming schedule. You can get the entire schedule or specific segments of the schedule. [Learn More](https://help.twitch.tv/s/article/channel-page-setup#Schedule)  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the streaming schedule you want to get.</param>
        /// <param name="id">The ID of the scheduled segment to return. To specify more than one segment, include the ID of each segment you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 100 IDs. (optional)</param>
        /// <param name="startTime">The UTC date and time that identifies when in the broadcaster’s schedule to start returning segments. If not specified, the request returns segments starting after the current UTC date and time. Specify the date and time in RFC3339 format (for example, &#x60;2022-09-01T00:00:00Z&#x60;). (optional)</param>
        /// <param name="utcOffset">Not supported. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 25 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelStreamScheduleApiResponse"/>&gt;</returns>
        public async Task<IGetChannelStreamScheduleApiResponse?> GetChannelStreamScheduleOrDefaultAsync(string broadcasterId, Option<List<string>> id = default, Option<DateTime> startTime = default, Option<string> utcOffset = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetChannelStreamScheduleAsync(broadcasterId, id, startTime, utcOffset, first, after, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the broadcaster’s streaming schedule. Gets the broadcaster’s streaming schedule. You can get the entire schedule or specific segments of the schedule. [Learn More](https://help.twitch.tv/s/article/channel-page-setup#Schedule)  __Authorization:__  Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster that owns the streaming schedule you want to get.</param>
        /// <param name="id">The ID of the scheduled segment to return. To specify more than one segment, include the ID of each segment you want to get. For example, &#x60;id&#x3D;1234&amp;id&#x3D;5678&#x60;. You may specify a maximum of 100 IDs. (optional)</param>
        /// <param name="startTime">The UTC date and time that identifies when in the broadcaster’s schedule to start returning segments. If not specified, the request returns segments starting after the current UTC date and time. Specify the date and time in RFC3339 format (for example, &#x60;2022-09-01T00:00:00Z&#x60;). (optional)</param>
        /// <param name="utcOffset">Not supported. (optional)</param>
        /// <param name="first">The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 25 items per page. The default is 20. (optional)</param>
        /// <param name="after">The cursor used to get the next page of results. The **Pagination** object in the response contains the cursor’s value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelStreamScheduleApiResponse"/>&gt;</returns>
        public async Task<IGetChannelStreamScheduleApiResponse> GetChannelStreamScheduleAsync(string broadcasterId, Option<List<string>> id = default, Option<DateTime> startTime = default, Option<string> utcOffset = default, Option<int> first = default, Option<string> after = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetChannelStreamSchedule(broadcasterId, id, utcOffset, after);

                FormatGetChannelStreamSchedule(ref broadcasterId, id, ref startTime, ref utcOffset, ref first, ref after);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/schedule"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/schedule");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (startTime.IsSet)
                        parseQueryStringLocalVar["start_time"] = ClientUtils.ParameterToString(startTime.Value);

                    if (utcOffset.IsSet)
                        parseQueryStringLocalVar["utc_offset"] = ClientUtils.ParameterToString(utcOffset.Value);

                    if (first.IsSet)
                        parseQueryStringLocalVar["first"] = ClientUtils.ParameterToString(first.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetChannelStreamScheduleApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetChannelStreamScheduleApiResponse>();

                        GetChannelStreamScheduleApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/schedule", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetChannelStreamScheduleDefaultImplementation(apiResponseLocalVar, broadcasterId, id, startTime, utcOffset, first, after);

                        Events.ExecuteOnGetChannelStreamSchedule(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetChannelStreamScheduleDefaultImplementation(e, "/schedule", uriBuilderLocalVar.Path, broadcasterId, id, startTime, utcOffset, first, after);
                Events.ExecuteOnErrorGetChannelStreamSchedule(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetChannelStreamScheduleApiResponse"/>
        /// </summary>
        public partial class GetChannelStreamScheduleApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IGetChannelStreamScheduleApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetChannelStreamScheduleApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetChannelStreamScheduleApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetChannelStreamScheduleApiResponse(ILogger<GetChannelStreamScheduleApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChannelStreamScheduleResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChannelStreamScheduleResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.GetChannelStreamScheduleResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateChannelStreamSchedule(ref string broadcasterId, ref Option<bool> isVacationEnabled, ref Option<DateTime> vacationStartTime, ref Option<DateTime> vacationEndTime, ref Option<string> timezone);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="timezone"></param>
        /// <returns></returns>
        private void ValidateUpdateChannelStreamSchedule(string broadcasterId, Option<string> timezone)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (timezone.IsSet && timezone.Value == null)
                throw new ArgumentNullException(nameof(timezone));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="isVacationEnabled"></param>
        /// <param name="vacationStartTime"></param>
        /// <param name="vacationEndTime"></param>
        /// <param name="timezone"></param>
        private void AfterUpdateChannelStreamScheduleDefaultImplementation(IUpdateChannelStreamScheduleApiResponse apiResponseLocalVar, string broadcasterId, Option<bool> isVacationEnabled, Option<DateTime> vacationStartTime, Option<DateTime> vacationEndTime, Option<string> timezone)
        {
            bool suppressDefaultLog = false;
            AfterUpdateChannelStreamSchedule(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, isVacationEnabled, vacationStartTime, vacationEndTime, timezone);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="isVacationEnabled"></param>
        /// <param name="vacationStartTime"></param>
        /// <param name="vacationEndTime"></param>
        /// <param name="timezone"></param>
        partial void AfterUpdateChannelStreamSchedule(ref bool suppressDefaultLog, IUpdateChannelStreamScheduleApiResponse apiResponseLocalVar, string broadcasterId, Option<bool> isVacationEnabled, Option<DateTime> vacationStartTime, Option<DateTime> vacationEndTime, Option<string> timezone);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="isVacationEnabled"></param>
        /// <param name="vacationStartTime"></param>
        /// <param name="vacationEndTime"></param>
        /// <param name="timezone"></param>
        private void OnErrorUpdateChannelStreamScheduleDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<bool> isVacationEnabled, Option<DateTime> vacationStartTime, Option<DateTime> vacationEndTime, Option<string> timezone)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateChannelStreamSchedule(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, isVacationEnabled, vacationStartTime, vacationEndTime, timezone);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="isVacationEnabled"></param>
        /// <param name="vacationStartTime"></param>
        /// <param name="vacationEndTime"></param>
        /// <param name="timezone"></param>
        partial void OnErrorUpdateChannelStreamSchedule(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, Option<bool> isVacationEnabled, Option<DateTime> vacationStartTime, Option<DateTime> vacationEndTime, Option<string> timezone);

        /// <summary>
        /// Updates the broadcaster’s schedule settings, such as scheduling a vacation. Updates the broadcaster’s schedule settings, such as scheduling a vacation.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster whose schedule settings you want to update. The ID must match the user ID in the user access token.</param>
        /// <param name="isVacationEnabled">A Boolean value that indicates whether the broadcaster has scheduled a vacation. Set to **true** to enable Vacation Mode and add vacation dates, or **false** to cancel a previously scheduled vacation. (optional)</param>
        /// <param name="vacationStartTime">The UTC date and time of when the broadcaster’s vacation starts. Specify the date and time in RFC3339 format (for example, 2021-05-16T00:00:00Z). Required if _is\\_vacation\\_enabled_ is **true**. (optional)</param>
        /// <param name="vacationEndTime">The UTC date and time of when the broadcaster’s vacation ends. Specify the date and time in RFC3339 format (for example, 2021-05-30T23:59:59Z). Required if _is\\_vacation\\_enabled_ is **true**. (optional)</param>
        /// <param name="timezone">The time zone that the broadcaster broadcasts from. Specify the time zone using [IANA time zone database](https://www.iana.org/time-zones) format (for example, America/New\\_York). Required if _is\\_vacation\\_enabled_ is **true**. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateChannelStreamScheduleApiResponse"/>&gt;</returns>
        public async Task<IUpdateChannelStreamScheduleApiResponse?> UpdateChannelStreamScheduleOrDefaultAsync(string broadcasterId, Option<bool> isVacationEnabled = default, Option<DateTime> vacationStartTime = default, Option<DateTime> vacationEndTime = default, Option<string> timezone = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateChannelStreamScheduleAsync(broadcasterId, isVacationEnabled, vacationStartTime, vacationEndTime, timezone, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Updates the broadcaster’s schedule settings, such as scheduling a vacation. Updates the broadcaster’s schedule settings, such as scheduling a vacation.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster whose schedule settings you want to update. The ID must match the user ID in the user access token.</param>
        /// <param name="isVacationEnabled">A Boolean value that indicates whether the broadcaster has scheduled a vacation. Set to **true** to enable Vacation Mode and add vacation dates, or **false** to cancel a previously scheduled vacation. (optional)</param>
        /// <param name="vacationStartTime">The UTC date and time of when the broadcaster’s vacation starts. Specify the date and time in RFC3339 format (for example, 2021-05-16T00:00:00Z). Required if _is\\_vacation\\_enabled_ is **true**. (optional)</param>
        /// <param name="vacationEndTime">The UTC date and time of when the broadcaster’s vacation ends. Specify the date and time in RFC3339 format (for example, 2021-05-30T23:59:59Z). Required if _is\\_vacation\\_enabled_ is **true**. (optional)</param>
        /// <param name="timezone">The time zone that the broadcaster broadcasts from. Specify the time zone using [IANA time zone database](https://www.iana.org/time-zones) format (for example, America/New\\_York). Required if _is\\_vacation\\_enabled_ is **true**. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateChannelStreamScheduleApiResponse"/>&gt;</returns>
        public async Task<IUpdateChannelStreamScheduleApiResponse> UpdateChannelStreamScheduleAsync(string broadcasterId, Option<bool> isVacationEnabled = default, Option<DateTime> vacationStartTime = default, Option<DateTime> vacationEndTime = default, Option<string> timezone = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateChannelStreamSchedule(broadcasterId, timezone);

                FormatUpdateChannelStreamSchedule(ref broadcasterId, ref isVacationEnabled, ref vacationStartTime, ref vacationEndTime, ref timezone);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/schedule/settings"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/schedule/settings");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);

                    if (isVacationEnabled.IsSet)
                        parseQueryStringLocalVar["is_vacation_enabled"] = ClientUtils.ParameterToString(isVacationEnabled.Value);

                    if (vacationStartTime.IsSet)
                        parseQueryStringLocalVar["vacation_start_time"] = ClientUtils.ParameterToString(vacationStartTime.Value);

                    if (vacationEndTime.IsSet)
                        parseQueryStringLocalVar["vacation_end_time"] = ClientUtils.ParameterToString(vacationEndTime.Value);

                    if (timezone.IsSet)
                        parseQueryStringLocalVar["timezone"] = ClientUtils.ParameterToString(timezone.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateChannelStreamScheduleApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateChannelStreamScheduleApiResponse>();

                        UpdateChannelStreamScheduleApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/schedule/settings", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateChannelStreamScheduleDefaultImplementation(apiResponseLocalVar, broadcasterId, isVacationEnabled, vacationStartTime, vacationEndTime, timezone);

                        Events.ExecuteOnUpdateChannelStreamSchedule(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateChannelStreamScheduleDefaultImplementation(e, "/schedule/settings", uriBuilderLocalVar.Path, broadcasterId, isVacationEnabled, vacationStartTime, vacationEndTime, timezone);
                Events.ExecuteOnErrorUpdateChannelStreamSchedule(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateChannelStreamScheduleApiResponse"/>
        /// </summary>
        public partial class UpdateChannelStreamScheduleApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IUpdateChannelStreamScheduleApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateChannelStreamScheduleApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateChannelStreamScheduleApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateChannelStreamScheduleApiResponse(ILogger<UpdateChannelStreamScheduleApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateChannelStreamScheduleSegment(ref string broadcasterId, ref string id, Option<UpdateChannelStreamScheduleSegmentBody> updateChannelStreamScheduleSegmentBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="updateChannelStreamScheduleSegmentBody"></param>
        /// <returns></returns>
        private void ValidateUpdateChannelStreamScheduleSegment(string broadcasterId, string id, Option<UpdateChannelStreamScheduleSegmentBody> updateChannelStreamScheduleSegmentBody)
        {
            if (broadcasterId == null)
                throw new ArgumentNullException(nameof(broadcasterId));

            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (updateChannelStreamScheduleSegmentBody.IsSet && updateChannelStreamScheduleSegmentBody.Value == null)
                throw new ArgumentNullException(nameof(updateChannelStreamScheduleSegmentBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="updateChannelStreamScheduleSegmentBody"></param>
        private void AfterUpdateChannelStreamScheduleSegmentDefaultImplementation(IUpdateChannelStreamScheduleSegmentApiResponse apiResponseLocalVar, string broadcasterId, string id, Option<UpdateChannelStreamScheduleSegmentBody> updateChannelStreamScheduleSegmentBody)
        {
            bool suppressDefaultLog = false;
            AfterUpdateChannelStreamScheduleSegment(ref suppressDefaultLog, apiResponseLocalVar, broadcasterId, id, updateChannelStreamScheduleSegmentBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="updateChannelStreamScheduleSegmentBody"></param>
        partial void AfterUpdateChannelStreamScheduleSegment(ref bool suppressDefaultLog, IUpdateChannelStreamScheduleSegmentApiResponse apiResponseLocalVar, string broadcasterId, string id, Option<UpdateChannelStreamScheduleSegmentBody> updateChannelStreamScheduleSegmentBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="updateChannelStreamScheduleSegmentBody"></param>
        private void OnErrorUpdateChannelStreamScheduleSegmentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string id, Option<UpdateChannelStreamScheduleSegmentBody> updateChannelStreamScheduleSegmentBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateChannelStreamScheduleSegment(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, broadcasterId, id, updateChannelStreamScheduleSegmentBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="broadcasterId"></param>
        /// <param name="id"></param>
        /// <param name="updateChannelStreamScheduleSegmentBody"></param>
        partial void OnErrorUpdateChannelStreamScheduleSegment(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string broadcasterId, string id, Option<UpdateChannelStreamScheduleSegmentBody> updateChannelStreamScheduleSegmentBody);

        /// <summary>
        /// Updates a scheduled broadcast segment. Updates a scheduled broadcast segment.  For recurring segments, updating a segment’s title, category, duration, and timezone, changes all segments in the recurring schedule, not just the specified segment.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </summary>
        /// <param name="broadcasterId">The ID of the broadcaster who owns the broadcast segment to update. This ID must match the user ID in the user access token.</param>
        /// <param name="id">The ID of the broadcast segment to update.</param>
        /// <param name="updateChannelStreamScheduleSegmentBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateChannelStreamScheduleSegmentApiResponse"/>&gt;</returns>
        public async Task<IUpdateChannelStreamScheduleSegmentApiResponse?> UpdateChannelStreamScheduleSegmentOrDefaultAsync(string broadcasterId, string id, Option<UpdateChannelStreamScheduleSegmentBody> updateChannelStreamScheduleSegmentBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateChannelStreamScheduleSegmentAsync(broadcasterId, id, updateChannelStreamScheduleSegmentBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Updates a scheduled broadcast segment. Updates a scheduled broadcast segment.  For recurring segments, updating a segment’s title, category, duration, and timezone, changes all segments in the recurring schedule, not just the specified segment.  __Authorization:__  Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcasterId">The ID of the broadcaster who owns the broadcast segment to update. This ID must match the user ID in the user access token.</param>
        /// <param name="id">The ID of the broadcast segment to update.</param>
        /// <param name="updateChannelStreamScheduleSegmentBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateChannelStreamScheduleSegmentApiResponse"/>&gt;</returns>
        public async Task<IUpdateChannelStreamScheduleSegmentApiResponse> UpdateChannelStreamScheduleSegmentAsync(string broadcasterId, string id, Option<UpdateChannelStreamScheduleSegmentBody> updateChannelStreamScheduleSegmentBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateChannelStreamScheduleSegment(broadcasterId, id, updateChannelStreamScheduleSegmentBody);

                FormatUpdateChannelStreamScheduleSegment(ref broadcasterId, ref id, updateChannelStreamScheduleSegmentBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/schedule/segment"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/schedule/segment");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["broadcaster_id"] = ClientUtils.ParameterToString(broadcasterId);
                    parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (updateChannelStreamScheduleSegmentBody.IsSet)
                        httpRequestMessageLocalVar.Content = (updateChannelStreamScheduleSegmentBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(updateChannelStreamScheduleSegmentBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateChannelStreamScheduleSegmentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateChannelStreamScheduleSegmentApiResponse>();

                        UpdateChannelStreamScheduleSegmentApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/schedule/segment", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateChannelStreamScheduleSegmentDefaultImplementation(apiResponseLocalVar, broadcasterId, id, updateChannelStreamScheduleSegmentBody);

                        Events.ExecuteOnUpdateChannelStreamScheduleSegment(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateChannelStreamScheduleSegmentDefaultImplementation(e, "/schedule/segment", uriBuilderLocalVar.Path, broadcasterId, id, updateChannelStreamScheduleSegmentBody);
                Events.ExecuteOnErrorUpdateChannelStreamScheduleSegment(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateChannelStreamScheduleSegmentApiResponse"/>
        /// </summary>
        public partial class UpdateChannelStreamScheduleSegmentApiResponse : TwistedTaleweaver.Integration.Twitch.Helix.Client.ApiResponse, IUpdateChannelStreamScheduleSegmentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateChannelStreamScheduleSegmentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateChannelStreamScheduleSegmentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateChannelStreamScheduleSegmentApiResponse(ILogger<UpdateChannelStreamScheduleSegmentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateChannelStreamScheduleSegmentResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateChannelStreamScheduleSegmentResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out TwistedTaleweaver.Integration.Twitch.Helix.Model.UpdateChannelStreamScheduleSegmentResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
